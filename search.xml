<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringAOP底层原理</title>
      <link href="/sunfy-framework/2021/10/13/resource-Spring-Spring-SpringAOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/sunfy-framework/2021/10/13/resource-Spring-Spring-SpringAOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="理解Spring-AOP"><a href="#理解Spring-AOP" class="headerlink" title="理解Spring AOP"></a>理解Spring AOP</h1><p>提到AOP那我们自然会想到初学java时经常提到的OOP，OOP表示的是面向对象编程，是一种编程思想。AOP则是面向切面编程，同样也是一种编程思想。从Spring作为一个框架的角度来说，提供了一整套的面向切面编程的机制，让我们更容易进行开发，这套机制在Spring中就称为Spring AOP。</p><p>知道了AOP是一种编程思想，那又是一种什么样的编程思想呢？</p><p><strong>AOP</strong>：将程序中的交叉业务（日志、安全、事务等），封装成一个切面，然后注入到目标对象的具体逻辑中去。AOP可以对某个对象或某些对象的功能进行增强，具体来说，对某个对象的方法进行增强，可以在执行方法之余额外做一些事情，可以在方法前、方法后等。</p><h1 id="Spring-AOP中的概念"><a href="#Spring-AOP中的概念" class="headerlink" title="Spring AOP中的概念"></a>Spring AOP中的概念</h1><ul><li><strong>Aspect</strong>：切面，比如被@Aspect注解的类就是切面，可以在切面中去定义Pointcut、advice等等</li><li><strong>Join point</strong>：连接点，表示一个程序在执行过程中的一个点，比如一个方法的运行，比如一个异常的处理。在Spring AOP中，一个连接点通常表示一个方法的执行。</li><li><strong>Advice</strong>：通知，表示在一个特定连接点上所采取的动作。</li><li><strong>Pointcut</strong>：切点，用来匹配一个或多个连接点，Advice与切点表达式时关联在一起的，Advice将会执行在和切点表达式所匹配的连接点上</li><li><strong>Introduction</strong>：可以使用@DeclareParents来给所匹配的类添加一个接口，并指定一个默认实现</li><li><strong>Target object</strong>：目标对象，被代理对象</li><li><strong>AOP proxy</strong>：代理工厂，用来创建代理对象的。在Spring Framework中，要么是JDK动态代理，要么是CGLIB代理</li><li><strong>Weaving</strong>：织入，表示创建代理对象的动作，这个动作Aspejctij发生在编译时期，Spring AOP在运行时</li></ul><h1 id="实现方式（动态代理）"><a href="#实现方式（动态代理）" class="headerlink" title="实现方式（动态代理）"></a>实现方式（动态代理）<sunfy-line></h1><p>站内文章：</p><p>web访问：<a href="/2020/08/11/resource-designpattern-structure-proxy/">java设计模式之动态代理实现与原理详细分析</a></p><p>文章中介绍了什么是代理模式、常见的代理模式的类型、动态代理的原理、以及在Spring AOP中的应用</p><p>我们先回顾下上述文章中说到的Spring AOP在源码中的体现</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Spring AOP 解析切面源码入口 <code>@EnableAspectJAutoProxy</code> —&gt; <code>AspectJAutoProxyRegistrar</code> —&gt;<code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</code><br>通过上面的注册一个Bean定义 <code>AnnotationAwareAspectJAutoProxyCreator.class</code><br>查看注册的bean的结构，可以知道注册的是一个bean的后置处理器；此处就是ioc的一个扩展点。</p><p><img src="../../../../img/SpringAOP底层原理/image-20210812145750817-16348060527742.png" alt="image-20210812145750817"></p><p>接下来我们重点看几个重要的类</p><h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><p>这个就是应用代理技术，Spring经过封装后，生成的代理工厂类，会由它来负责创建具体的代理类。</p><p><img src="../../../../img/SpringAOP底层原理/image-20211021165948587.png" alt="image-20211021165948587"></p><p>通过<code>ProxyFactory</code>，我们在使用过程中不需要去关注到底使用cglib，还是jdk动态代理，Spring实现的PorxyFactory会帮助我们去判断通过何种方式生成代理类</p><ul><li>如果被代理类实现了接口，那么底层就会自动使用jdk动态代理，生成对应接口类型的代理对象</li><li>如果被代理类没有实现接口，那么就选择cglib技术</li></ul><h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><p>五个注解，表示代理逻辑以及执行时机</p><ul><li>@Before：接口MethodBeforeAdvice，继承了接口BeforeAdvice</li><li>@AfterReturning：接口AfterReturningAdvice</li><li>@AfterThrowing：接口ThrowsAdvice</li><li>@After：接口AfterAdvice</li><li>@Around：接口AfterAdvice</li></ul><p>Spring会把五个注解解析为对应的Advice类：</p><ul><li>@Before：AspectJMethodBeforeAdvice，实际上就是一个MethodBeforeAdvice</li><li>@AfterReturning：AspectJAfterReturningAdvice，实际上就是一个AfterReturningAdvice</li><li>@AfterThrowing：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</li><li>@After：AspectJAfterAdvice，实际上就是一个MethodInterceptor</li><li>@Around：AspectJAroundAdvice，实际上就是一个MethodInterceptor</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动装配原理</title>
      <link href="/sunfy-framework/2021/10/06/resource-Spring-SpringBoot-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
      <url>/sunfy-framework/2021/10/06/resource-Spring-SpringBoot-SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties" target="_blank" rel="noopener">配置文件属性参照</a><a id="more"></a></p><h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2><p>@Import + @Configuration + Spring spi </p><p>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-INF/spring.factories下 使用Spring spi扫描META-INF/spring.factories下的配置类 使用@Import导入自动配置类</p><p><img src="../../../../img/SpringBoot自动装配原理/image-20210809172533498.png" alt="image-20210809172533498"></p><ul><li><p>源码查看入口 <sunfy-line></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication</span><br></pre></td></tr></table></figure></li><li><p><code>@SpringBootApplication</code>: Spring Boot应用标注在某个类上说明这个类是Spring Boot的主配置类，Spring Boot需要运行这个类的main方法来启动Spring Boot应用；</p></li><li><p><code>@EnableAutoConfiguration</code> 开启自动配置功能；自动扫描所有的配置类，扫描到并满足条件才会生效</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><ul><li><p><code>@Import(AutoConfigurationImportSelector.class)</code> SpringBoot实现自动配置的关键类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现接口DeferredImportSelector（一个ImportSelector的变种，不会执行ImportSelector）</span></span><br><span class="line"><span class="comment">// 解析@Import(AutoConfigurationImportSelector.class)注解时，调用getAutoConfigurationEntry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="comment">// sunfy-AutoConf 自动配置重要入口</span></span><br></pre></td></tr></table></figure></li><li><p><code>AutoConfigurationImportSelector</code> 实现接口 <code>DeferredImportSelector</code>，判断是否重写<code>getImportGroup</code>方法，如果没有重写<code>selectImports</code>返回一个数组，将数组中的完整类名注册为bean</p></li><li>重写<code>getImportGroup</code>方法，返回一个自定义的实现了<code>DeferredImportSelector.Group</code>的类</li></ul></li><li><p>SpringBoot通过重写，返回自定义的<code>DeferredImportSelector.Group</code>的类</p></li><li><p>process中获取所有的配置并根据实际引入进行过滤</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">    Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">                 () -&gt; String.format(<span class="string">"Only %s implementations are supported, got %s"</span>,</span><br><span class="line">                                     AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>(),</span></span><br><span class="line"><span class="class">                                     <span class="title">deferredImportSelector</span>.<span class="title">getClass</span>().<span class="title">getName</span>()))</span>;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">        <span class="comment">// sunfy-autoConf 获取所有的有效自动配置类</span></span><br><span class="line">        .getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="comment">// selectImports 方法中获取到的配置</span></span><br><span class="line">    <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">    <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>getAutoConfigurationEntry</code>获取所有有效自动配置类，进入方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sunfy-autoConf 获取所有的有效自动配置类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// sunfy-autoconf 获取所有的配置类1XX个</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// sunfy-AutoConf 根据pom依赖中添加starter过滤出来的有效配置类</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>getCandidateConfigurations</code>中获取到SpringBoot项目中所有的Stater配置，总共有<code>1xx</code>多个</p><p> <img src="../../../../img/SpringBoot自动装配原理/image-20210118114003369.png" alt="image-20210118114003369"></p><p> 进入<code>getCandidateConfigurations</code>方法中</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sunfy-autoconf 加载所有配置文件，jar中可能都存在，都进行读取</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">                                                                         getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>loadFactoryNames</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要获取的自动配置类的全限定名</span></span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../img/SpringBoot自动装配原理/image-20210118210142763.png" alt="image-20210118210142763"></p><p>   <code>loadSpringFactories</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">      <span class="comment">// 此时会尝试从缓存中进行获取，因为在SpringBoot启动时就会加载其他配置文件，因为加载所有的配置文件是一个很耗时耗内存的过程，在第一次加载完成后会放在cache中，方便后续获取</span></span><br><span class="line">      MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";</span></span><br><span class="line">          <span class="comment">// 不难看出都会到对应的jar包中读取META-INF/spring.factories文件中的内容</span></span><br><span class="line">          Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                                   classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                                   ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">          result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">          <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">              URL url = urls.nextElement();</span><br><span class="line">              UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">              Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                  String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                  <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                      result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将获取到的内容放入到缓存中</span></span><br><span class="line">          cache.put(classLoader, result);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  <img src="../../../../img/SpringBoot自动装配原理/image-20210118114603645.png" alt="image-20210118114603645"></p><p>   遍历每个jar包下的每个<code>META-INF/spring.factories</code>文件内容</p><p>   ​       <img src="../../../../img/SpringBoot自动装配原理/image-20210118115041776.png" alt="image-20210118115041776"></p><ol><li><p><code>getConfigurationClassFilter().filter(configurations)</code>根据<code>pom</code>依赖中添加starter过滤出来的有效配置类</p><p>至此所有的自动配置就全部获取到了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring启动过程源码解析</title>
      <link href="/sunfy-framework/2021/09/26/resource-Spring-Spring-Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/sunfy-framework/2021/09/26/resource-Spring-Spring-Spring%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring启动过程源码解析"><a href="#Spring启动过程源码解析" class="headerlink" title="Spring启动过程源码解析"></a>Spring启动过程源码解析</h1><p>通常，我们说的Spring启动，就是构造ApplicationContext对象以及调用refresh()方法的过程。 </p><p>首先，Spring启动过程主要做了这么几件事情：</p><ul><li>构造一个BeanFactory对象</li><li>解析配置类，得到BeanDefinition，并注册到BeanFactory中<ul><li>解析@ComponentScan，此时就会完成扫描</li><li>解析@Import</li><li>解析@Bean</li><li>…<sunfy-line></li></ul></li><li>因为ApplicationContext还支持国际化，所以还需要初始化MessageSource对象</li><li>因为ApplicationContext还支持事件机制，所以还需要初始化ApplicationEventMulticaster对象</li><li>把用户定义的ApplicationListener对象添加到ApplicationContext中，等Spring启动完了就要发布事件了</li><li>创建<strong>非懒加载的单例</strong>Bean对象，并存在BeanFactory的单例池中。</li><li>调用Lifecycle Bean的start()方法</li><li>发布<strong>ContextRefreshedEvent</strong>事件</li></ul><p>由于Spring启动过程中要创建非懒加载的单例Bean对象，那么就需要用到BeanPostProcessor，所以Spring在启动过程中就需要做两件事：</p><ul><li>生成默认的BeanPostProcessor对象，并添加到BeanFactory中<ul><li>AutowiredAnnotationBeanPostProcessor：处理@Autowired、@Value</li><li>CommonAnnotationBeanPostProcessor：处理@Resource、@PostConstruct、@PreDestroy</li><li>ApplicationContextAwareProcessor：处理ApplicationContextAware等回调</li></ul></li><li>找到外部用户所定义的BeanPostProcessor对象（类型为BeanPostProcessor的Bean对象），并添加到BeanFactory中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBean的销毁</title>
      <link href="/sunfy-framework/2021/09/15/resource-Spring-Spring-SpringBean%E7%9A%84%E9%94%80%E6%AF%81/"/>
      <url>/sunfy-framework/2021/09/15/resource-Spring-Spring-SpringBean%E7%9A%84%E9%94%80%E6%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中Bean的销毁"><a href="#Spring中Bean的销毁" class="headerlink" title="Spring中Bean的销毁"></a>Spring中Bean的销毁</h1><p>Bean销毁是发生在Spring容器关闭过程中的。 </p><p>在Spring容器关闭时，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">UserService userService = (UserService) context.getBean(<span class="string">"userService"</span>);</span><br><span class="line">userService.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器关闭</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p>在Bean创建过程中，在最后（初始化之后），有一个步骤会去判断当前创建的Bean是不是DisposableBean：</p><ul><li>当前Bean是否实现了DisposableBean接口</li><li>或者，当前Bean是否实现了AutoCloseable接口</li><li>BeanDefinition中是否指定了destroyMethod</li><li>调用DestructionAwareBeanPostProcessor.requiresDestruction(bean)进行判断<ul><li>ApplicationListenerDetector中直接使得ApplicationListener是DisposableBean</li><li>InitDestroyAnnotationBeanPostProcessor中使得拥有@PreDestroy注解了的方法就是DisposableBean</li></ul></li><li>把符合上述任意一个条件的Bean适配成DisposableBeanAdapter对象，并存入disposableBeans中（一个LinkedHashMap）<sunfy-line></li></ul><p>在Spring容器关闭过程时：</p><ul><li>首先发布ContextClosedEvent事件</li><li>调用lifecycleProcessor的onCloese()方法</li><li>销毁单例Bean<ul><li>遍历disposableBeans<ul><li>把每个disposableBean从单例池中移除</li><li>调用disposableBean的destroy()</li><li>如果这个disposableBean还被其他Bean依赖了，那么也得销毁其他Bean</li><li>如果这个disposableBean还包含了inner beans，将这些Bean从单例池中移除掉 (inner bean参考<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans</a>)</li></ul></li><li>清空manualSingletonNames，是一个Set，存的是用户手动注册的单例Bean的beanName</li><li>清空allBeanNamesByType，是一个Map，key是bean类型，value是该类型所有的beanName数组</li><li>清空singletonBeanNamesByType，和allBeanNamesByType类似，只不过只存了单例Bean</li></ul></li></ul><p>这里涉及到一个设计模式：<strong>适配器模式</strong></p><p>在销毁时，Spring会找出实现了DisposableBean接口的Bean。 </p><p>但是我们在定义一个Bean时，如果这个Bean实现了DisposableBean接口，或者实现了AutoCloseable接口，或者在BeanDefinition中指定了destroyMethodName，那么这个Bean都属于“DisposableBean”，这些Bean在容器关闭时都要调用相应的销毁方法。</p><p>所以，这里就需要进行适配，将实现了DisposableBean接口、或者AutoCloseable接口等适配成实现了DisposableBean接口，所以就用到了DisposableBeanAdapter。</p><p>会把实现了AutoCloseable接口的类封装成DisposableBeanAdapter，而DisposableBeanAdapter实现了DisposableBean接口。</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring依赖注入方式和源码分析</title>
      <link href="/sunfy-framework/2021/09/14/resource-Spring-Spring-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/sunfy-framework/2021/09/14/resource-Spring-Spring-Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中Bean的依赖注入"><a href="#Spring中Bean的依赖注入" class="headerlink" title="Spring中Bean的依赖注入"></a>Spring中Bean的依赖注入</h1><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><h3 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h3><p>这种方式主要通过<code>xml配置文件</code>进行扫描。配置信息如下</p><p>从源码角度来说，手动注入又分为set方法注入和构造方法注入。</p><h4 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.OrderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.UserService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(orderService);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明，使用set方法注入时，在代码中必须添加相应的set方法，依赖注入时会根据set后面的名称去ioc容器中查找相应的方法，找到后进行赋值。</p><h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入<sunfy-line></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.OrderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.UserService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"orderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(orderService);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明，使用构造方法注入时，在代码中必须重写构造方法，并根据注入配置重写相对应的构造方法，依赖注入时会根据参数名称去IOC容器中查找相应的方法，找到后进行赋值。</p><h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><h4 id="XML的autowire自动注入"><a href="#XML的autowire自动注入" class="headerlink" title="XML的autowire自动注入"></a>XML的autowire自动注入</h4><p><img src="../../../../img/Spring依赖注入方式和源码分析/image-20210915150329433.png" alt="image-20210915150329433"></p><p>XML中，在定义一个bean时，我们可以通过autowire设置自动注入模式：</p><ul><li>byName</li><li>byType</li><li>constructor</li><li>default</li><li>no</li></ul><p>XML配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.UserService"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如上配置，spring会自动给<code>UserService</code>类中所有的属性自动赋值，不需要在属性上配置<code>@Autowired</code>注解，但是必须有set方法。</p><p><strong>ByName自动填充属性时流程：</strong></p><ul><li>找到所有set方法所对应的属性名称部分的名字。</li><li>根据属性名称的名字去获取bean。</li></ul><p><strong>ByType自动填充属性时流程：</strong></p><ul><li>获取set方法中的唯一参数的参数类型，并且根据类型去IOC容器中获取Bean。</li><li>如果找到多个，会报错。</li></ul><p><strong>Constructor自动填充属性:</strong></p><ul><li>使用这种方式时，就不需要写属性的set方法了，这个就是使用构造方法的方式进行注入，spring会利用构造方法中的参数信息去Spring容器中找bean，找到bean之后作为参数传给构造方法，从而实例化得到一个bean对象，并完成属性赋值，此时属性赋值需要我们在构造方法中自行编写。</li><li>这块目前只考虑只有一个构造方法的情况，如果多个构造方法时，会涉及推断构造方法，这个具体后续有单独说明。</li><li>这种方式中，就相当于ByType和ByName两种方式，和普通的ByType不同，如果采用Constructor进行自动填充，会通过ByType先在容器中查找，如果找到多个，会再根据名称去进行比对，最终确定唯一的内容，进行填充。通过一个示例说明：</li></ul><p><code>spring.xml</code>配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.OrderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"orderService1"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.OrderService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"top.sunfy.service.UserService"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>UserService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="comment">// 构造方法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.orderService = orderService1;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 构造方法2</span></span><br><span class="line"><span class="comment">//public UserService(OrderService orderService1) &#123;</span></span><br><span class="line"><span class="comment">//this.orderService = orderService1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(orderService);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:/spring.xml"</span>);</span><br><span class="line">UserService userService = xmlApplicationContext.getBean(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 打印出了注入到UserService中的bean</span></span><br><span class="line">userService.test();</span><br><span class="line">        <span class="comment">// 分别打印IOC容器中的两个OrderService</span></span><br><span class="line">System.out.println(xmlApplicationContext.getBean(<span class="string">"orderService"</span>));</span><br><span class="line">System.out.println(xmlApplicationContext.getBean(<span class="string">"orderService1"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">构造方法一：</span><br><span class="line">top.sunfy.service.OrderService@27d415d9</span><br><span class="line">top.sunfy.service.OrderService@27d415d9</span><br><span class="line">top.sunfy.service.OrderService@5c18298f</span><br><span class="line">构造方法二：</span><br><span class="line">top.sunfy.service.OrderService@27d415d9</span><br><span class="line">top.sunfy.service.OrderService@5c18298f</span><br><span class="line">top.sunfy.service.OrderService@27d415d9</span><br></pre></td></tr></table></figure><p>结果分析，我们可以看出，通过上面的测试，我们证明了，在使用XML中使用Constructor自动属性填充时，会先根据Type进行查找，如果找到多个，会再根据名称进行找到。</p><p><strong>no：</strong>表示关闭了autowire</p><p><strong>default：</strong>这个表示默认值，我们刚才的使用过程中都是在<code>&lt;bean&gt;</code>标签中使用的，<code>autowrite</code>也可以使用在<code>&lt;beans&gt;</code>标签上，这样的设置表示，如果beans中设置了，那么bean中设置为default会模式使用beans中设置的。</p><p><strong>通过上述的说明，可以看出XML中的Autowrite功能还是很强大，但是我们在平时中更多的使用的还是<code>@Autowrite</code>注解的方式，那这又是为什么呢？二者之间的区别是什么呢？</strong></p><p>要回答这个问题，我们首先来了解一下@Autowired注解的使用和特点</p><h4 id="Autowired注解自动注入"><a href="#Autowired注解自动注入" class="headerlink" title="@Autowired注解自动注入"></a>@Autowired注解自动注入</h4><p>@Autowired注解可以写在：</p><ul><li>属性上：先根据属性类型去找bean，如果找到多个再根据属性名确定。</li><li>构造方法上：先根据方法参数类型去找bean，如果找到多个再根据属性名确定。</li><li>set方法上：先根据方法参数类型去找bean，如果找到多个再根据参数名确定。</li></ul><p>从底层来看，到了</p><ul><li>属性注入</li><li>set方法注入</li><li>构造方法注入</li></ul><p>XML中的Autowrite和@Autowrite注解的区别？</p><ul><li>@Autowirte相当于XML中的autowrite属性的注解方式的替代。看一个官网中的说明 <code>Essentially, the @Autowired annotation provides the same capabilities as described in Autowiring Collaborators but with more fine-grained control and wider applicability</code>（本质上，@Autowired注释提供了与Autowiring collaborator中描述的相同的功能，但具有<strong>更细粒度的控制</strong>和更广泛的适用性）</li><li>看官网描述中提到的<font color="red"><strong>更细粒度的控制</strong></font></li><li>XML中的autowirte控制的是整个bean的所有属性，而@Autowirte注解可以写在某个属性上，某个set方法上，某个构造方法上。假如一个bean有多个构造方法，那XML配置中使用构造方法注入时则无法控制到底使用哪个构造方法，而@Autowrite可以直接指定想用哪个构造方法。</li><li>@Autowrite可以控制哪些属性想被自动注入，哪些属性不想，这也体现了@Autowrite的细粒度控制。</li><li>@Autowrite无法区分ByType和ByName，会先ByType，如果找到多个再通过ByName。源码中的具体实现不同</li><li>XML的自动注入底层其实也就是set方法注入和构造方法注入。</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>什么是属性描述器 <code>PropertyDescriptor</code></p><p><img src="../../../../img/Spring依赖注入方式和源码分析/image-20210914135343558.png" alt="image-20210914135343558"></p><p>什么样的属性能进行自动注入？</p><p><img src="../../../../img/Spring依赖注入方式和源码分析/image-20210914140832924.png" alt="image-20210914140832924"></p><p>简单值检查方法：</p><p><img src="../../../../img/Spring依赖注入方式和源码分析/image-20210914140944745.png" alt="image-20210914140944745"></p><p>为什么使用@Autowrite注解的属性是static时，不会进行赋值呢。</p><p>@Autowrite注解的required属性的使用说明</p><p>@Autowrite注解注入时获取的是，参数的类型和名称，和方法名称并没有关系，都可以注入</p><p>构建自动装配元数据时，桥接方法的作用？ </p><p><img src="../../../../img/Spring依赖注入方式和源码分析/image-20210914155649171.png" alt="image-20210914155649171"></p><p>同时使用@Autowrite注解和BeanDefinition给某个对象赋值，最终会是什么样的结果呢？</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBean的生命周期详解</title>
      <link href="/sunfy-framework/2021/09/09/resource-Spring-Spring-SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>/sunfy-framework/2021/09/09/resource-Spring-Spring-SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中Bean的生成过程"><a href="#Spring中Bean的生成过程" class="headerlink" title="Spring中Bean的生成过程"></a>Spring中Bean的生成过程</h1><p>先从整理看下，Bean的生成过程中都包含了哪些步骤。</p><blockquote><p>生成<code>BeanDefinition</code></p><p>合成<code>BeanDefinition</code></p><p>加载类</p><p>实例化前</p><p>实例化</p><p><code>BeanDefinition</code>的后置处理</p><p>实例化后</p><p>自动注入</p><p>处理属性</p><p>执行Aware</p><p>初始化前</p><p>初始化</p><p>初始化后</p></blockquote><p><a href="/img/image-20210914143837446.png">Bean生命周期流程图</a></p><p><img src="../../../../img/SpringBean的生命周期详解/image-20210914143837446.png" alt="image-20210914143837446"></p><ul><li>InstantiationAwareBeanPostProcessor.postProcessBeforeinstantiation()</li><li>实例化</li><li>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</li><li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(bean)</li><li>属性赋值（Spring自带的依赖注入）</li><li>InstantiationAwareBeanPostProcessor.postProcessProperties(@Autowired)</li><li>初始化前</li><li>初始化</li><li>初始化后<sunfy-line></li></ul><p>首先我们了解到的，在Spring的启动过程中，针对bean的处理主要做了两个方面的</p><ul><li>扫描指定路径</li><li>实例化bean（此处的实例化准确的说是实例化非懒加载的单例bean）。</li></ul><p>那我们先来分析，Spring是如何去扫描路径、加载所需要的class文件。</p><p>从Spring启动过程来看，在refresh方法中，<code>invokeBeanFactoryPostProcessors(beanFactory)</code>中会调用<code>Scanner.scan</code>方法，进行bean的扫描，<code>finishBeanFactoryInitialization</code>中对扫描到的bean进行真正的实例化，完成bean工厂的初始化。</p><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>先看下扫描方法的调用栈信息</p><p><img src="../../../../img/SpringBean的生命周期详解/image-20210909101911892.png" alt="image-20210909101911892"></p><p>看代码</p><p><code>ClassPathScanningCandidateComponentProvider.scanCandidateComponents</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取资源文件，扫描所有文件资源</span></span><br><span class="line">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">            resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">        <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">        <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 元数据读取器，读取当前类的基本信息（ASM技术）</span></span><br><span class="line">                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">                    <span class="comment">// excludeFilters和includeFilters判断</span></span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                        ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">                        sbd.setSource(resource);</span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                            candidates.add(sbd);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                            logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中读取到了传入路径的所有class文件，并按照需要进行了路径处理。然后遍历所有文件，通过元数据读取器，遍历读取每一个文件的元数据信息，然后根据元数据信息判断当前类是否需要注册成为一个bean，最终返回。</p><p>在遍历元数据时，实现了<code>excludeFilters和includeFilters</code>判断，其中<code>Conditional</code>条件加载功能也在这块进行了实现，<code>Conditional</code>注解在我们实际使用中不多，但是在SpringBoot源码中使用的会很多。<code>Conditional</code>实现方式也很简单，创建一个类实现<code>Condition</code>接口，实现其中的<code>matches</code>方法，根据需要判断是否加载某个类就可以，在spring启动加载的时候，会根据某个类中是否添加了<code>@Conditional</code>，如果有则会调用注解中指明的类实现的<code>matches</code>方法。</p><p>源码中的位置在<code>ConditionEvaluator.shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)</code>，具体代码就不贴了，有兴趣的可以直接从源码中找到。</p><p>返回到上面的代码中，判断了当前class是一个bean之后，就开始创建<code>beanDefinition</code>，new 除 <code>beanDefinition</code>并做基本的属性赋值，然后又再一次判断了当前的bean是不是内部类、接口、抽象类、或者是（是一个抽象类，同时该类中具有被Lookup注解的方法），根据判断结果决定是否要将当前的类加入到最终返回的<code>candidates</code>对象中。</p><p>这样基本的<code>BeanDefinition</code>就完成了，在扫描过程中涉及到了<code>Lookup</code>注解的使用。但是到目前为止，<code>beanDefinition</code>中大部分属性还没有赋值，目前主要是保存了beanClass内容。</p><p>得到<code>BeanDefinition</code>的set集合后，接下来就需要遍历，然后对<code>BeanDefinition</code>中的属性进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历BeanDefinition,对其属性进行赋值</span></span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">    <span class="comment">// 赋值scope</span></span><br><span class="line">    candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        <span class="comment">// 解析@lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class="line">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">        BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">        definitionHolder =</span><br><span class="line">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        beanDefinitions.add(definitionHolder);</span><br><span class="line">        registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里面有一个细节，在生成beanName的时候，如果我们定义的BeanName名称首字母大写，且第二个字符小写的时候会将首字母小写作为默认的BeanName，但是如果第一个字母和第二个字母都是大写则不会处理。</p><p>例如：User —&gt; user URL —&gt; URL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成默认的beanName，在生成默认的beanName之前会先判断自定义类的注解中是否有手动设置beanName</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    String beanClassName = definition.getBeanClassName();</span><br><span class="line">    Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">"No bean class name set"</span>);</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">    <span class="comment">// 判断首字母大写，但是字符开始有多个大写时不做操作</span></span><br><span class="line">    <span class="comment">// 例如  User --&gt; user URL --&gt; URL</span></span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：下面这个方法是jdk中自带的方法，并不是spring中所提供的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decapitalize</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class="number">1</span>)) &amp;&amp;</span><br><span class="line">        Character.isUpperCase(name.charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> chars[] = name.toCharArray();</span><br><span class="line">    chars[<span class="number">0</span>] = Character.toLowerCase(chars[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这，所有的扫描工作就告一段落了。</p><h2 id="生成BeanDefinition"><a href="#生成BeanDefinition" class="headerlink" title="生成BeanDefinition"></a>生成BeanDefinition</h2><p>Spring启动的时候会进行扫描，会先调用<code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents(String basePackage)</code> 扫描某个包路径，并得到BeanDefinition的Set集合。 </p><p>Spring扫描底层流程：</p><ul><li>首先，通过ResourcePatternResolver获得指定包路径下的所有<code>.class</code>文件（Spring源码中将此文件包装成了Resource对象）</li><li>遍历每个Resource对象</li><li>利用MetadataReaderFactory解析Resource对象得到MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为SimpleMetadataReader）</li><li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li><li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li><li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li><li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li></ul><p>MetadataReader表示类的元数据读取器，主要包含了一个AnnotationMetadata，功能有</p><ul><li>获取类的名字、</li><li>获取父类的名字</li><li>获取所实现的所有接口名</li><li>获取所有内部类的名字</li><li>判断是不是抽象类</li><li>判断是不是接口</li><li>判断是不是一个注解</li><li>获取拥有某个注解的方法集合</li><li>获取类上添加的所有注解信息</li><li>获取类上添加的所有注解类型集合</li></ul><p>值得注意的是，CachingMetadataReaderFactory解析某个.class文件得到MetadataReader对象是利用的<strong>ASM</strong>技术，并没有加载这个类到JVM。并且，最终得到的ScannedGenericBeanDefinition对象，<strong>beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象） </p><p>最后，上面是说的通过扫描得到BeanDefinition对象，我们还可以通过直接定义BeanDefinition，或解析spring.xml文件的&lt;bean/&gt;，或者@Bean注解得到BeanDefinition对象。（后续课程会分析@Bean注解是怎么生成BeanDefinition的）。</p><p>实例化非懒加载的Bean查看入口<code>finishBeanFactoryInitialization(beanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环我们所有的bean定义名称</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">//获得合并后的bean定义，这个合并的RootBeanDefinition是判断当前的bean是不是存在父子关系的bean，</span></span><br><span class="line">    <span class="comment">// 如果存在父bean那就会继承父类中的属性，但是如果自己本身也有定义的还是会使用自身配置的属性</span></span><br><span class="line">    <span class="comment">// 子类和父类合并后会生成一个新的BeanDefinition</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据bean定义判断是不是抽象的&amp;&amp; 不是单例的 &amp;&amp;不是懒加载的</span></span><br><span class="line"><span class="comment">     * 此处判断的是BeanDefinite是不是抽象的，和Bean没有关系</span></span><br><span class="line"><span class="comment">     * 这个是在xml文件配置的时候，设置abstract="true",如果有以上配置那对应的beanDefinite将会是抽象的</span></span><br><span class="line"><span class="comment">     * 抽象bean的作用，如果是抽象的，首先是不会去创建bean对象的</span></span><br><span class="line"><span class="comment">     * 还有一个就是抽象的beanDefinite自己不会创建Bean对象，但是可以集成给别的bean去用，xml配置文件中配置parent=“xxx抽象bean定义”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">        <span class="comment">//是不是工厂bean</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">//是的话 给beanName+前缀&amp;符号</span></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                        (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断是否实现了SmartFactoryBean，如果实现了这个接口，就可以重写isEagerInit()返回true,在Spring容器创建的过程中就可以做一些事情</span></span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                   ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//调用真正的getBean的流程</span></span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非工厂Bean 就是普通的bean</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一遍历所有的beanNames，首先此处有一个概念是<code>RootBeanDefinition</code>，获得合并后的bean定义</p><h2 id="合并BeanDefinition"><a href="#合并BeanDefinition" class="headerlink" title="合并BeanDefinition"></a>合并BeanDefinition</h2><p>通过扫描得到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了，但是在Spring中支持父子BeanDefinition，和Java父子类类似，但是完全不是一回事。</p><p>父子BeanDefinition实际用的比较少，使用是这样的，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.sunfy.service.Parent"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">class</span>=<span class="string">"com.sunfy.service.Child"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这么定义的情况下，child是单例Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">class</span>=<span class="string">"com.sunfy.service.Parent"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">class</span>=<span class="string">"com.sunfy.service.Child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是这么定义的情况下，child就是原型Bean了。 </p><p>因为child的父BeanDefinition是parent，所以会继承parent上所定义的scope属性。 </p><p>而在根据child来生成Bean对象之前，需要进行BeanDefinition的合并，得到完整的child的BeanDefinition。 </p><p>再次遍历所有的bean，是否实现了SmartInitializingSingleton接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有的bean的名称</span></span><br><span class="line"><span class="comment">// 到这里所有的单实例的bean已经记载到单实例bean到缓存中</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">//从单例缓存池中获取所有的对象</span></span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//判断当前的bean是否实现了SmartInitializingSingleton接口</span></span><br><span class="line">    <span class="comment">// sunfy- 这个也是Spring提供的一个扩展点之一，在所有的非懒加载的单例bean都创建完成之后会调用的方法</span></span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="comment">// 安全管理器</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//触发实例化之后的方法afterSingletonsInstantiated</span></span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加载类"><a href="#加载类" class="headerlink" title="加载类"></a>加载类</h2><p>BeanDefinition合并之后，就可以去创建Bean对象了，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure><p>这行代码就是去加载类，该方法是这么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class="line">doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.beanClass <span class="keyword">instanceof</span> Class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果beanClass属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）</p><p>会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用<strong>ClassUtils.getDefaultClassLoader()</strong>所返回的类加载器来加载。</p><h3 id="ClassUtils-getDefaultClassLoader"><a href="#ClassUtils-getDefaultClassLoader" class="headerlink" title="ClassUtils.getDefaultClassLoader()"></a><strong>ClassUtils.getDefaultClassLoader()</strong></h3><ul><li>优先返回当前线程中的ClassLoader</li><li>线程中类加载器为null的情况下，返回ClassUtils类的类加载器</li><li>如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring底层核心原理</title>
      <link href="/sunfy-framework/2021/09/04/resource-Spring-Spring-Spring%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/sunfy-framework/2021/09/04/resource-Spring-Spring-Spring%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring如何创建一个对象"><a href="#Spring如何创建一个对象" class="headerlink" title="Spring如何创建一个对象"></a>Spring如何创建一个对象</h1><p>首先来看一个类<code>org.springframework.context.support.ClassPathXmlApplicationContext</code></p><p>这个类就是我们一开始使用Spring的时候会首先认识的一个类，在Spring 3的时候增加了一个<code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>, 经常使用Spring的人都应该知道第一个类的作用，创建了spring的容器，并指定了扫描路径。其实这两个类的作用基本相同，只不过在一些具体形式上有一些区别，比如前者主要是去读取指定路径下的<code>xml</code>配置文件，后者则是通过java配置类的形式去配置Spring容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring.xml"</span>);</span><br><span class="line"></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>这里之所以提及<code>AnnotationConfigApplicationContext</code>，是因为我们目前主流使用的<code>SpringBoot</code>就是基于这个类来实现的。</p><p>通过以上代码后，我们通常就可以使用<code>context</code>容器对象通过<code>getBean</code>方法去获取对象，在这个过程中就创建了Bean对象。那接下来就了解Spring是如何创建一个对象的。</p><p><font color=red>那么此处有一个问题可以思考下：通过Spring容器获得的Bean和java中<code>new xxx</code>得到的bean有什么区别呢？</font><sunfy-line></p><h1 id="Spring中bean的创建生命周期"><a href="#Spring中bean的创建生命周期" class="headerlink" title="Spring中bean的创建生命周期"></a>Spring中bean的创建生命周期</h1><p><code>xxx.class</code> —&gt; 判断使用哪个构造方法 —&gt; 普通对象 —&gt; Aware回调 —&gt; 依赖注入(属性赋值<code>@Autowrite</code>)  —&gt; 初始化前(<code>@PostConstruct</code>) —&gt; 初始化 ( <code>InitializingBean</code>)—&gt; 初始化后(AOP) —&gt; AOP之后会生成一个代理对象 —&gt; Bean</p><ol><li>Spring扫描class得到BeanDefinition</li><li>根据得到的BeanDefinition去生成bean</li><li>首先根据class推断构造方法</li><li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li><li>填充原始对象中的属性（依赖注入）</li><li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li><li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h2><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过car对象获取其属性，并遍历属性中查找带有Autowired注解的</span></span><br><span class="line"><span class="keyword">for</span> (Field field : car.getClass().getFields()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      <span class="comment">// 给属性进行赋值（赋值的值从何而来？？？）</span></span><br><span class="line">field.set(xxxx, ????)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化前"><a href="#初始化前" class="headerlink" title="初始化前"></a><strong>初始化前</strong></h2><p><code>@PostConstruct</code>注解，初始化前调用，可以对bean进行一些赋值工作，使用和依赖注入类似 </p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><p>判断当前bean是否实现了<code>InitializingBean</code>， 通过 <code>instance of InitializingBean</code>判断是否实现接口，实现了该接口后，就将当前bean转换成<code>InitializingBean</code>对象，然后通过该对象去调用实现接口需要重写的<code>afterPropertiesSet()</code>方法</p><p>Spring源码中对用的位置 <code>AbstractAutowireCapableBeanFactory.initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断我们的容器中是否实现了InitializingBean接口</span></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Spring的安全管理器</span></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//回调InitializingBean的afterPropertiesSet()方法</span></span><br><span class="line"><span class="comment">// 这块就是上述关键的位置</span></span><br><span class="line"><span class="comment">// 这块就是上述关键的位置</span></span><br><span class="line"><span class="comment">// 这块就是上述关键的位置</span></span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">//我们beanclass中看是否有自己定义的init方法</span></span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="comment">//判断自定义的init方法名称不叫afterPropertiesSet</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line"><span class="comment">//调用我们自己的初始化方法</span></span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的过程就是上述的，Spring源码中会比这个更多，支持更多的扩展点，比如<code>Aware</code>、<code>beanPostProcess</code>，就是spring提供的很多的扩展点，以及一些常见主流款框架如何通过扩展点集成到Spring中，见<a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring扩展点">本站链接</a></p><h1 id="手写Spring"><a href="#手写Spring" class="headerlink" title="手写Spring"></a>手写Spring</h1><p>本代码中包含了Spring读取配置文件，实现了<code>@ComponentScan</code>注解，读取指定路径下的所有文件。读取所有文件下的<code>Component</code>标记的类。<code>@Scope</code>注解实现简单的单例bean和原型bean。此处的构造方法使用默认的无参构造方法，并 没有实现复杂判断构造方法的功能。生成普通对象后，实现了简单的<code>BeanNameAware</code>扩展点，并实现了基于<code>@Autowrited</code>依赖注入。</p><p>实现<code>InitializingBean</code>接口，在创建bean的时候，如果实现了<code>InitializingBean</code>接口，会自动执行<code>afterPropertiesSet</code>方法。</p><p>实现<code>BeanPostProcessor</code>接口，bean的后置处理器，两个默认的方法<code>postProcessBeforeInitialization</code>、<code>postProcessAfterInitialization</code>。</p><p>理解了bean的创建过程，bean从读取class文件、通过<code>ClassLoader</code>进行类的加载、创建<code>BeanDefinition</code>对象、保存类的<code>Scope</code>属性保存至<code>BeanDefinition</code>、将<code>BeanDefinition</code>放入Map缓存中、在获取bean的时候，通过scope不同属性创建bean，并将创建的bean保存至相应的map缓存池中。创建bean的时候实现了依赖注入（属性赋值）、判断<code>Aware</code>接口、<code>BeanPostProcessor</code>后置处理器初始化前、<code>InitializingBean</code>初始化接口、<code>`BeanPostProcessor</code>后置处理器初始化后。</p><p><code>BeanPostProcessor</code>类似AOP的实现过程。</p><p>此处只贴出了<code>Application</code>的代码，具体的接口代码就不贴了，那些就是一些注解和接口，很简单，不会的直接从Spring中取一下也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.spring.annotations.Autowrited;</span><br><span class="line"><span class="keyword">import</span> com.spring.annotations.Component;</span><br><span class="line"><span class="keyword">import</span> com.spring.annotations.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.spring.annotations.Scope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sunfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> SunfyAppliction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-9-4 21:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SunfyAppliction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存所有对象的一定定义信息</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; beanPostProcessorList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SunfyAppliction</span><span class="params">(Class configClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(this.getClass().getName() + "构造方法开始运行！");</span></span><br><span class="line">        <span class="comment">// 扫描路径下的class</span></span><br><span class="line">        scan(configClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for (Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) &#123;</span></span><br><span class="line">        <span class="comment">//    String beanName = entry.getKey();</span></span><br><span class="line">        <span class="comment">//    BeanDefinition beanDefinition = entry.getValue();</span></span><br><span class="line">        <span class="comment">//    if (beanDefinition.getScope().equals("singleton")) &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//        Object bean = createBean(beanName, beanDefinition);</span></span><br><span class="line">        <span class="comment">//        singletonMap.put(beanName, bean);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(Class configClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前闯入的类是否有ComponentScan注解</span></span><br><span class="line">        <span class="keyword">if</span> (configClass.isAnnotationPresent(ComponentScan<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 获得注解中配置的路径</span></span><br><span class="line">            ComponentScan componentScan = (ComponentScan) configClass.getAnnotation(ComponentScan<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            String path = componentScan.value();</span><br><span class="line">            <span class="comment">//System.out.println("配置文件路径" + path);</span></span><br><span class="line">            <span class="comment">// 处理文件路径</span></span><br><span class="line">            path = path.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">//System.out.println("配置文件路径替换后" + path);</span></span><br><span class="line">            <span class="comment">// 获得ClassLoader</span></span><br><span class="line">            ClassLoader classLoader = SunfyAppliction<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">            URL resource = classLoader.getResource(path);</span><br><span class="line">            <span class="comment">//System.out.println("通过ClassLoader获取完整文件路径" + resource.getPath());</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(resource.getFile());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始处理获取的文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File f :</span><br><span class="line">                        file.listFiles()) &#123;</span><br><span class="line">                    String absolutePath = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                        <span class="comment">//System.out.println("当前问文件夹，跳过" + f.getName());</span></span><br><span class="line">                        <span class="keyword">for</span> (File f1 :</span><br><span class="line">                                f.listFiles()) &#123;</span><br><span class="line">                            <span class="comment">//System.out.println("获取到的文件为：" + f.getPath());</span></span><br><span class="line">                            absolutePath = f1.getAbsolutePath();</span><br><span class="line">                            <span class="comment">//System.out.println("获取到的文件绝对路径为：" + absolutePath);</span></span><br><span class="line">                            absolutePath = absolutePath.substring(absolutePath.indexOf(<span class="string">"com"</span>), absolutePath.indexOf(<span class="string">".class"</span>));</span><br><span class="line">                            absolutePath = absolutePath.replace(<span class="string">"\\"</span>, <span class="string">"."</span>);</span><br><span class="line">                            <span class="comment">//System.out.println("修改文件路径为：" + absolutePath);</span></span><br><span class="line">                            loadClass(classLoader, absolutePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//System.out.println("获取到的文件为：" + f.getPath());</span></span><br><span class="line">                        absolutePath = f.getAbsolutePath();</span><br><span class="line">                        <span class="comment">//System.out.println("获取到的文件绝对路径为：" + absolutePath);</span></span><br><span class="line">                        absolutePath = absolutePath.substring(absolutePath.indexOf(<span class="string">"com"</span>), absolutePath.indexOf(<span class="string">".class"</span>));</span><br><span class="line">                        absolutePath = absolutePath.replace(<span class="string">"\\"</span>, <span class="string">"."</span>);</span><br><span class="line">                        <span class="comment">//System.out.println("修改文件路径为：" + absolutePath);</span></span><br><span class="line">                        loadClass(classLoader, absolutePath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前路径不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前配置类不存在ComponentScan注解"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(ClassLoader classLoader, String absolutePath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备通过类加载器加载文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(absolutePath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(Component<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否有实现了BeanPostProcessor接口</span></span><br><span class="line">                <span class="keyword">if</span> (BeanPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">aClass</span>)) </span>&#123;</span><br><span class="line">                    BeanPostProcessor instance = (BeanPostProcessor) aClass.getConstructor().newInstance();</span><br><span class="line">                    beanPostProcessorList.add(instance);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Component componentAnnotation = aClass.getAnnotation(Component<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (componentAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"该类没有添加Component注解，不处理"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String beanName = componentAnnotation.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(beanName)) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    获得一个字符串并将它转换成普通 java 变量名称大写形式的实用工具方法。</span></span><br><span class="line"><span class="comment">                    这通常意味着将首字符从大写转换成小写，但在（不平常的）特殊情况下，</span></span><br><span class="line"><span class="comment">                    当有多个字符且第一个和第二个字符都是大写字符时，不执行任何操作。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    beanName = Introspector.decapitalize(aClass.getSimpleName());</span><br><span class="line">                    <span class="comment">//System.out.println("没有配置value，自动获取的名字为：" + beanName);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// beanDefinition，Spring中很关键的一个概念</span></span><br><span class="line">                BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">                beanDefinition.setType(aClass);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据Scope注解设置bean的属性</span></span><br><span class="line">                <span class="keyword">if</span> (aClass.isAnnotationPresent(Scope<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    Scope scope = aClass.getAnnotation(Scope<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    String value = scope.value();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">""</span>.equals(value)) value = <span class="string">"singleton"</span>;</span><br><span class="line">                    beanDefinition.setScope(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanDefinition.setScope(<span class="string">"singleton"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将bean放在一个缓存Map中供后续获取使用，此时只是放入了一个bean定义，并没有真正的创建bean对象</span></span><br><span class="line">                beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinitionMap.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 不存在当前bean定义，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);</span><br><span class="line">        <span class="comment">// 根据Scope的属性创建bean</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"singleton"</span>.equals(beanDefinition.getScope())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singletonMap.containsKey(beanName)) &#123;</span><br><span class="line">                bean = singletonMap.get(beanName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bean = createBean(beanName, beanDefinition);</span><br><span class="line">                singletonMap.put(beanName, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bean = createBean(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createBean</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        Class type = beanDefinition.getType();</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 通过反射创建对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过构造函数反射创建对象</span></span><br><span class="line">            instance = type.getConstructor().newInstance();</span><br><span class="line">            <span class="comment">//System.out.println("基础对象创建成功");</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实现依赖注入（属性赋值）</span></span><br><span class="line">            <span class="keyword">for</span> (Field field :</span><br><span class="line">                    type.getDeclaredFields()) &#123;</span><br><span class="line">                <span class="comment">//System.out.println("获取到的相关属性" + field.getName());</span></span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(Autowrited<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(instance, getBean(field.getName()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建了bean之后，判断是否实现Aware接口，Spring一个重要的扩展点</span></span><br><span class="line">            <span class="comment">//System.out.println("判断是否实现了Aware接口");</span></span><br><span class="line">            <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">                ((BeanNameAware) instance).setBeanName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bean的后置处理器（Spirng中AOP采用的就是这种实现方式）-初始化前</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor beanPostprocessor :</span><br><span class="line">                    beanPostProcessorList) &#123;</span><br><span class="line">                instance = beanPostprocessor.postProcessBeforeInitialization(instance, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建bean之后，判断bean是否实现了InitializingBean接口，这也是Spring的一个重要的扩展点</span></span><br><span class="line">            <span class="comment">//System.out.println("判断是否实现了InitializingBean接口");</span></span><br><span class="line">            <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> InitializingBean) &#123;</span><br><span class="line">                ((InitializingBean) instance).afterPropertiesSet();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bean的后置处理器（Spirng中AOP采用的就是这种实现方式）-初始化后</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor beanPostprocessor :</span><br><span class="line">                    beanPostProcessorList) &#123;</span><br><span class="line">                instance = beanPostprocessor.postProcessAfterInitialization(instance, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>BeanPostProcessor</code>：这属于面向切面的扩展，针对具有默写共同点的类进行统一的扩展。</p><p><code>Aware</code>：面向实现指定接口的类进行扩展。</p><p><code>InitializingBean</code>：面向实现指定接口的类进行扩展。</p><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a><code>BeanDefinition</code></h2><p>表示Bean定义，<code>BeanDefinition</code>中存在很多属性用来描述一个Bean的特点。通常使用Bean标签（<code>&lt;Bean/&gt;</code>）、<code>@Bean注解</code>、<code>@Component（@Service、@COntroller）</code>等方式来声明一个bean，以上几种方式统称为申明式定义Bean，同时还可以使用编程式定义Bean，在Spring源码中更多的都是通过<code>BeanDefinition</code>来编程式的创建bean的。</p><h2 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a><code>BeanDefinitionReader</code></h2><p>Spring源码中提供的<code>BeanDefinition</code>读取器，这些我们通常不会使用到，但是在Spring源码中使用的很多。<code>AnnotatedBeanDefinitionReader</code>、<code>XmlBeanDefinitionReader</code>等。</p><h2 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a><code>ClassPathBeanDefinitionScanner</code></h2><p>扫描器，作用和<code>BeanDefinitionReader</code>类似，可以进行扫描，扫描某个包的路径，对扫描到的类进行解析。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><code>BeanFactory</code></h2><p>表示Bean工厂，负责创建Bean，并且提供获取Bean的API。IOCbean工厂的顶级接口 定义一系列对bean的操作。</p><p><img src="../../../../img/Spring底层核心原理/image-20210906110715684.png" alt="image-20210906110715684"></p><p>而<code>ApplicationContext</code>是<code>BeanFactory</code>的一种，在Spring源码中，是这么定义的：</p><p><img src="../../../../img/Spring底层核心原理/image-20210906110841507.png" alt="image-20210906110841507"></p><p>首先，在Java中，接口是可以<strong>多继承</strong>的，我们发现<code>ApplicationContext</code>继承了<code>ListableBeanFactory</code>和<code>HierarchicalBeanFactory</code>，而<code>ListableBeanFactory</code>和<code>HierarchicalBeanFactory</code>都继承至<code>BeanFactory</code>，所以我们可以认为ApplicationContext继承了<code>BeanFactory</code>，<code>ApplicationContext</code>也是<code>BeanFactory</code>的一种，拥有<code>BeanFactory</code>支持的所有功能，不过<code>ApplicationContext</code>比<code>BeanFactory</code>更加强大，<code>ApplicationContext</code>还继承了其他接口，也就表示<code>ApplicationContext</code>还拥有其他功能，</p><p>比如</p><ul><li><code>MessageSource</code>表示国际化，</li><li><code>ApplicationEventPublisher</code>表示事件发布，</li><li><code>EnvironmentCapable</code>表示获取环境变量，等等，关于ApplicationContext后面再详细讨论。</li></ul><p>在Spring的源码实现中，当我们new一个<code>ApplicationContext</code>时，其底层会new一个<code>BeanFactory</code>出来，当使用<code>ApplicationContext</code>的某些方法时，比如<code>getBean()</code>，底层调用的是<code>BeanFactory</code>的<code>getBean()</code>方法。</p><p>在Spring源码中，<code>BeanFactory</code>接口存在一个非常重要的实现类是：<strong><code>DefaultListableBeanFactory</code>，也是非常核心的。</strong></p><p>所以，我们可以直接来使用<strong><code>DefaultListableBeanFactory</code></strong>，而不用使用<code>ApplicationContext</code>的某个实现类，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();</span><br><span class="line">beanDefinition.setBeanClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">"user"</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">System.out.println(beanFactory.getBean(<span class="string">"user"</span>));</span><br></pre></td></tr></table></figure></p><p><strong><code>DefaultListableBeanFactory</code>是非常强大的，支持很多功能，可以通过查看<code>DefaultListableBeanFactory</code>的类继承实现结构来看</strong></p><p><img src="../../../../img/Spring底层核心原理/image-20210906110428991.png" alt="image-20210906110428991"></p><p>它实现了很多接口，表示，它拥有很多功能：</p><ol><li><code>AliasRegistry</code>：支持别名功能，一个名字可以对应多个别名</li><li><code>BeanDefinitionRegistry</code>：可以注册、保存、移除、获取某个<code>BeanDefinition</code></li><li><code>BeanFactory</code>：Bean工厂，可以根据某个bean的名字、或类型、或别名获取某个Bean对象</li><li><code>SingletonBeanRegistry</code>：可以直接注册、获取某个<strong>单例</strong>Bean</li><li><code>SimpleAliasRegistry</code>：它是一个类，实现了<code>AliasRegistry</code>接口中所定义的功能，支持别名功能</li><li><code>ListableBeanFactory</code>：在<code>BeanFactory</code>的基础上，增加了其他功能，可以获取所有<code>BeanDefinition</code>的<code>beanNames</code>，可以根据某个类型获取对应的<code>beanNames</code>，可以根据某个类型获取{类型：对应的Bean}的映射关系</li><li><code>HierarchicalBeanFactory</code>：在<code>BeanFactory</code>的基础上，添加了获取父<code>BeanFactory</code>的功能</li><li><code>DefaultSingletonBeanRegistry</code>：它是一个类，实现了<code>SingletonBeanRegistry</code>接口，拥有了直接注册、获取某个<strong>单例</strong>Bean的功能</li><li><code>ConfigurableBeanFactory</code>：在<code>HierarchicalBeanFactory</code>和<code>SingletonBeanRegistry</code>的基础上，添加了设置父<code>BeanFactory</code>、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL表达式解析器（表示该<code>BeanFactory</code>可以解析EL表达式）、设置类型转化服务（表示该<code>BeanFactory</code>可以进行类型转化）、可以添加<code>BeanPostProcessor</code>（表示该<code>BeanFactory</code>支持Bean的后置处理器），可以合并<code>BeanDefinition</code>，可以销毁某个Bean等等功能</li><li><code>FactoryBeanRegistrySupport</code>：支持了<code>FactoryBean</code>的功能</li><li><code>AutowireCapableBeanFactory</code>：是直接继承了<code>BeanFactory</code>，在<code>BeanFactory</code>的基础上，支持在创建Bean的过程中能对Bean进行自动装配</li><li><code>AbstractBeanFactory</code>：实现了<code>ConfigurableBeanFactory</code>接口，继承了<code>FactoryBeanRegistrySupport</code>，这个<code>BeanFactory</code>的功能已经很全面了，但是不能自动装配和获取<code>beanNames</code></li><li><code>ConfigurableListableBeanFactory</code>：继承了<code>ListableBeanFactory</code>、<code>AutowireCapableBeanFactory</code>、<code>ConfigurableBeanFactory</code></li><li><code>AbstractAutowireCapableBeanFactory</code>：继承了<code>AbstractBeanFactory</code>，实现了<code>AutowireCapableBeanFactory</code>，拥有了自动装配的功能</li><li><code>DefaultListableBeanFactory</code>：继承了<code>AbstractAutowireCapableBeanFactory</code>，实现了<code>ConfigurableListableBeanFactory</code>接口和<code>BeanDefinitionRegistry</code>接口，所以<code>DefaultListableBeanFactory</code>的功能很强大</li></ol><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h2><p><code>ApplicationContext</code>是一个接口，实际上也是一个<code>BeanFactory</code>，不过相较于<code>BeanFactory</code>更为强大。</p><ol><li><code>HierarchicalBeanFactory</code>：拥有获取父<code>BeanFactory</code>的功能</li><li><code>ListableBeanFactory</code>：拥有获取beanNames的功能</li><li><code>ResourcePatternResolver</code>：资源加载器，可以一次性获取多个资源（文件资源等等）</li><li><code>EnvironmentCapable</code>：可以获取运行时环境（没有设置运行时环境功能）</li><li><code>ApplicationEventPublisher</code>：拥有广播事件的功能（没有添加事件监听器的功能）</li><li><code>MessageSource</code>：拥有国际化功能</li></ol><p>两个比较重要的实现类</p><h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a><code>AnnotationConfigApplicationContext</code></h3><p><img src="../../../../img/Spring底层核心原理/image-20210906110040192.png" alt="image-20210906110040192"></p><ol><li><code>ConfigurableApplicationContext</code>：继承了<code>ApplicationContext</code>接口，增加了，添加事件监听器、添加<code>BeanFactoryPostProcessor</code>、设置<code>Environment</code>，获取<code>ConfigurableListableBeanFactory</code>等功能</li><li><code>AbstractApplicationContext</code>：实现了<code>ConfigurableApplicationContext</code>接口</li><li><code>GenericApplicationContext</code>：继承了<code>AbstractApplicationContext</code>，实现了<code>BeanDefinitionRegistry</code>接口，拥有了所有ApplicationContext的功能，并且可以注册<code>BeanDefinition</code>，注意这个类中有一个属性(<code>DefaultListableBeanFactory</code> <strong><code>beanFactory</code></strong>)</li><li><code>AnnotationConfigRegistry</code>：可以单独注册某个为类为<code>BeanDefinition</code>（可以处理该类上的<strong>@Configuration注解</strong>，已经可以处理<strong>@Bean注解</strong>），同时可以扫描</li><li><code>AnnotationConfigApplicationContext</code>：继承了<code>GenericApplicationContext</code>，实现了<code>AnnotationConfigRegistry</code>接口，拥有了以上所有的功能</li></ol><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a><code>ClassPathXmlApplicationContext</code></h3><p><img src="../../../../img/Spring底层核心原理/image-20210906110239801.png" alt="image-20210906110239801"></p><p>也是继承了<code>AbstractApplicationContext</code>，但是相对于<code>AnnotationConfigApplicationContext</code>而言，功能没有<code>AnnotationConfigApplicationContext</code>强大，比如不能注册<code>BeanDefinition</code></p><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>（MessageSource）</p><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>可以直接利用ApplicationContext获得某个文件的内容</p><h3 id="获取运行时环境"><a href="#获取运行时环境" class="headerlink" title="获取运行时环境"></a>获取运行时环境</h3><h3 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h3><h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p>在Spring源码中，有可能需要把String转换成其他类型，所以在Spring源码中提供了一些技术来更方便的对对象进行类型转化</p><p><code>PropertyEditor</code>：JDK中提供的类型转化工具类</p><p><code>ConversionService</code>：Spring中提供的类型转化服务，比<code>propertyEditor</code>更强大</p><p><code>TypeConverter</code>：整合了上面两个功能，Spring源码中使用的</p><h2 id="OrderComparator"><a href="#OrderComparator" class="headerlink" title="OrderComparator"></a><code>OrderComparator</code></h2><p>是Spring所提供的一种比较器，可以用来根据<code>@Order</code>注解或实现<code>Ordered</code>接口来执行比较从而进行排序的工具类。</p><p>另外，Spring中还提供了一个<code>OrderComparator</code>的子类：<code>AnnotationAwareOrderComparator</code>，它支持用<code>@Order</code>来指定<code>order</code>值。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a><code>BeanPostProcessor</code></h2><p>表示Bean的后置处理器，我们可以定义一个或多个<code>BeanPostProcessor</code></p><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a><code>BeanFactoryPostProcessor</code></h2><p>表示bean工厂的后置处理器，其实和<code>BeanPostProcessor</code>类似，<code>BeanPostProcessor</code>是干涉<code>Bean</code>的创建过程，<code>BeanFactoryPostProcessor</code>是干涉<code>BeanFactory</code>的创建过程。</p><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a><code>FactoryBean</code></h2><p>上面提到的<code>BeanPostProcessor</code>是用来干涉<code>Bean</code>的创建过程，但是如果我们想让一个Bean完全由我们来创建，也是可以的，可以通过<code>FactoryBean</code>来创建，这样创建出来的bean不会经过完成的Bean的生命周期，<strong>只会经过初始化后</strong>，其他的依赖注入等是不会经过的。</p><p>通过<code>FactoryBean</code>创建的bean和我们常用的申明式创建的bean主要区别在于是否有完整的Spring的生命周期，自然申明式创建的bean是具备完整的生命周期的。</p><h2 id="ExcludeFilter、IncludeFileter"><a href="#ExcludeFilter、IncludeFileter" class="headerlink" title="ExcludeFilter、IncludeFileter"></a><code>ExcludeFilter</code>、<code>IncludeFileter</code></h2><p>这两个过滤器是Spring扫描过程中用来过滤的，见名知意，<code>ExcludeFilter</code>表示排除过滤器，<code>IncludeFileter</code>表示包含过滤器。</p><p>在Spring的扫描逻辑中，默认会添加一个<code>AnnotationTypeFilter</code>给<code>includeFilters</code>，表示默认情况下Spring扫描过程中会认为类上有<code>@Component</code>注解的就是Bean。</p><h2 id="MetadataReader、ClassMetadata、AnntationMetadata"><a href="#MetadataReader、ClassMetadata、AnntationMetadata" class="headerlink" title="MetadataReader、ClassMetadata、AnntationMetadata"></a><code>MetadataReader</code>、<code>ClassMetadata</code>、<code>AnntationMetadata</code></h2><p>在Spring中需要取解析类的信息，比如类名、类中的方法、类上的注解等信息，这些都称之为类的元数据，Spring中对上述信息做了一些封装，提供了一些工具类，可以很方便的获取元数据信息。</p><p><code>SimpleMetadataReader</code>解析类的时候，使用的是<strong>ASM技术</strong></p><p>为什么要使用ASM技术呢？</p><p>Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，那如果在Spring启动的时候就把这些类全部加载进<code>JVM</code>中，这样不太好，就使用了ASM</p><blockquote><p>扩展：</p><p><a href="https://blog.csdn.net/zhuoxiuwu/article/details/78619645" target="_blank" rel="noopener">ASM技术</a>：ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关的面试题</title>
      <link href="/sunfy-framework/2021/08/18/resource-Spring-Spring-Spring%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/sunfy-framework/2021/08/18/resource-Spring-Spring-Spring%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://spring.io/why-spring" target="_blank" rel="noopener">Why Spring?</a></p><p>Spring makes programming Java quicker, easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the <a href="https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/" target="_blank" rel="noopener">world’s most popular</a> Java framework.（Spring使Java编程对每个人来说更快、更容易、更安全。Spring对速度、简单性和生产率的关注使它成为世界上最流行的Java框架。）<a id="more"></a></p><hr><blockquote><p>“We use a lot of the tools that come with the Spring framework and reap the benefits of having a lot of the out of the box solutions, and not having to worry about writing a ton of additional code—so that really saves us some time and energy.”</p><p>“我们使用了Spring框架附带的许多工具，并获得了许多开箱即用的解决方案的好处，而不必担心编写大量额外的代码——因此，这确实节省了我们一些时间和精力。”</p><p>SEAN GRAHAM, APPLICATION TRANSFORMATION LEAD, DICK’S SPORTING GOODS</p></blockquote><ul><li><p>Spring is everywhere(无处不在)</p></li><li><p>Spring is flexible(灵活的)</p></li><li><p>Spring is productive(多产的)</p></li><li><p>Spring is fast(快)</p></li><li><p>Spring is secure(安全)</p></li><li><p>Spring is supportive(支持的)</p></li></ul><p>以上都是来自于Spring官网的一些内容，下面正式开始了解面试中常见的spring的相关问题。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E6%98%AF%E4%BB%80%E4%B9%88">Spring是什么？读过源码介绍一下大致流程？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#%E5%AF%B9IOC%E7%9A%84%E7%90%86%E8%A7%A3">谈谈你对IOC的理解？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3">谈谈你对AOP的理解？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#%E5%AE%9E%E7%8E%B0IOC%E5%AE%B9%E5%99%A8">如何实现一个IOC容器？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">BeanFactory和ApplicationContext有什么区别？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%9C%E7%94%A8">Spring中后置处理器的作用？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">描述一下Spring Bean的生命周期？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97">Spring中的单例bean是线程安全的吗？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">解释一下Spring支持的几种bean的作用域？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Spring框架中都用到了那些设计模式？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">Spring事务的实现方式和原理以及隔离级别？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6">Spring事务传播机制？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99-Transactional%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F">Spring事务什么时候会失效？什么时候@Transactional会失效？</a></li><li><a href="/2021/08/18/resource-file-Interview-105-springAbout/#bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">什么是bean的自动装配，有哪些方式？</a><sunfy-line></li></ul><h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h1><p>轻量级的开源的J2EE框架。它是一个容器框架，用来装java bean（java对象），中间层框架（万能胶）可以起一个连接作用，比如说把Struts和hibernate粘合在一起运用，可以让我们的企业开发更快、更简洁。</p><p>Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架</p><ul><li>从大小与开销两方面而言Spring都是轻量级的。</li><li>通过控制反转（IoC）的技术达到松耦合的目的。</li><li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。</li><li>包含并管理应用对象(Bean)的配置和生命周期，这个意义上是一个容器。</li><li>将简单的组件配置、组合成为复杂的应用，这个意义上是一个框架。</li></ul><p><a href="http://sunfy.top/2021/08/10/resource-file-Interview-102-sAsbAsc/" target="_blank" rel="noopener">Spring、SpringMVC、SpringBoot区别和联系</a></p><ul><li>Spring是⼀个快速开发框架，Spring帮助程序员来管理对象</li><li>Spring的源码实现的是⾮常优秀的，设计模式的应⽤、并发安全的实现、⾯向接⼝的设计等</li><li>在创建Spring容器，也就是启动Spring时：<ul><li>⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中</li><li>然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建</li><li>利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化后这⼀步骤中</li></ul></li><li>单例Bean创建完了之后，Spring会发布⼀个容器启动事件</li><li>Spring启动结束</li><li>在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的</li><li>在Spring启动过程中还会去处理@Import等注解</li></ul><h1 id="对IOC的理解"><a href="#对IOC的理解" class="headerlink" title="对IOC的理解"></a>对IOC的理解</h1><h2 id="ioc容器（容器概念）"><a href="#ioc容器（容器概念）" class="headerlink" title="ioc容器（容器概念）"></a>ioc容器（容器概念）</h2><p>实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。<br>这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性，根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</p><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。<br>全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><h1 id="对AOP的理解"><a href="#对AOP的理解" class="headerlink" title="对AOP的理解"></a>对AOP的理解</h1><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为<code>横切关注点</code>，因为它们会跨越系统的多个组件。</p><p>当我们需要为<strong>分散的对象引入公共行为</strong>的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。</p><p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个<code>切面</code>，然后注入到目标对象（具体业务逻辑）中去。AOP可以对<strong>某个</strong>对象或<strong>某些</strong>对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情</p><h1 id="实现IOC容器"><a href="#实现IOC容器" class="headerlink" title="实现IOC容器"></a>实现IOC容器</h1><ul><li>配置文件配置包扫描路径</li><li>递归包扫描获取.class文件</li><li>反射、确定需要交给IOC管理的类</li><li>对需要注入的类进行<a href="https://sunfy.top/2021/08/18/resource-file-Interview-105-springAbout/#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener"><strong>依赖注入</strong></a><ul><li>配置文件中指定需要扫描的包路径【<code>确定包路径</code>】</li><li>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解【<code>定义私有注解</code>】</li><li>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储【<code>读取class文件并保存至Set集合</code>】</li><li>遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象【<code>遍历集合，根据注解交给IOC，保存至缓存Map</code>】</li><li>遍历这个IOC容器，获取到每一个类的实例，判断里面是否有依赖其他的类的实例，然后进行递归注入【<code>遍历IOC容器，判断注入</code>】</li></ul></li></ul>   <font size=5 color="red" face="楷书">IOC通过依赖注入实现控制反转</font><h1 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h1><p>ApplicationContext是BeanFactory的子接口</p><p><img src="../../../../img/Spring相关的面试题/image-20210819161143563.png" alt="image-20210819161143563"></p><p>ApplicationContext提供了更完整的功能：</p><ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><hr><ul><li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li><li>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</li><li>相对于基本的BeanFactory，ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</li><li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ul><h1 id="Spring后置处理器作用"><a href="#Spring后置处理器作用" class="headerlink" title="Spring后置处理器作用"></a>Spring后置处理器作用</h1><p>Spring中的后置处理器分为<strong>BeanFactory后置处理器</strong>和<strong>Bean后置处理器</strong>，它们是Spring底层源码架构设计中⾮常重要的⼀种机制，同时开发者也可以利⽤这两种后置处理器来进⾏扩展。</p><h2 id="BeanFactory后置处理器"><a href="#BeanFactory后置处理器" class="headerlink" title="BeanFactory后置处理器"></a>BeanFactory后置处理器</h2><p>表示针对BeanFactory的处理器，Spring启动过程中，会先创建出BeanFactory实例，然后利⽤BeanFactory处理器来加⼯BeanFactory，⽐如Spring的扫描就是基于BeanFactory后置处理器来实现的。</p><h2 id="Bean后置处理器"><a href="#Bean后置处理器" class="headerlink" title="Bean后置处理器"></a>Bean后置处理器</h2><p>也类似，Spring在创建⼀个Bean的过程中，⾸先会实例化得到⼀个对象，然后再利⽤Bean后置处理器来对该实例对象进⾏加⼯，⽐如我们常说的<code>依赖注⼊就是基于⼀个Bean后置处理器来实现</code>的，通过该Bean后置处理器来给实例对象中加了@Autowired注解的属性⾃动赋值，还⽐如我们常说的AOP，也是利⽤⼀个Bean后置处理器来实现的，基于原实例对象，判断是否需要进⾏AOP，如果需要，那么就基于原实例对象进⾏动态代理，⽣成⼀个代理对象。</p><p><img src="../../../../img/Spring相关的面试题/image-20210819160854872.png" alt="image-20210819160854872"></p><p><img src="../../../../img/Spring相关的面试题/image-20210819160415377.png" alt="image-20210819160415377"></p><p><img src="../../../../img/Spring相关的面试题/image-20210819160602471.png" alt="image-20210819160602471"></p><p><img src="../../../../img/Spring相关的面试题/image-20210819141413088.png" alt="image-20210819141413088"></p><p><img src="../../../../img/Spring相关的面试题/image-20210819160319867.png" alt="image-20210819160319867"></p><h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1><p><a href="https://www.processon.com/view/link/5eafa609f346fb177ba8091f" target="_blank" rel="noopener">Spring生命周期图</a></p><p><a href="/img/image-20210819165326564.png"><img src="../../../../img/Spring相关的面试题/image-20210819165326564.png" alt="image-20210819165326564"></a></p><ul><li>解析类得到BeanDefinition</li><li>如果有多个构造方法，则要推断构造方法</li><li>确定好构造方法后，进行实例化得到一个对象</li><li>对对象中的加了@Autowired注解的属性进行属性填充</li><li>回调Aware方法，比如BeanNameAware，BeanFactoryAware</li><li>调用BeanPostProcessor的初始化前的方法</li><li>调用初始化方法</li><li>调用BeanPostProcessor的初始化后的方法，在这里会进行AOP</li><li>如果当前创建的bean是单例的则会把bean放入单例池</li><li>使用bean</li><li>Spring容器关闭时调用DisposableBean中destory()方法</li></ul><h1 id="Spring中的单例bean是线程安全的吗"><a href="#Spring中的单例bean是线程安全的吗" class="headerlink" title="Spring中的单例bean是线程安全的吗"></a>Spring中的单例bean是线程安全的吗</h1><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。</p><p>如果Bean是有状态的那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域把”singleton”改为’‘protopyte’这样每次请求Bean就相当于是new Bean()这样就可以保证线程的安全了。</p><ul><li>有状态就是有数据存储功能</li><li>无状态就是不会保存数据controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</li></ul><p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响（Spring是如何保证事务获取同一个Connection的）</p><p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了。</p><h1 id="Spring中bean的作用域"><a href="#Spring中bean的作用域" class="headerlink" title="Spring中bean的作用域"></a>Spring中bean的作用域</h1><ul><li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。</li><li>prototype：为每一个bean请求提供一个实例。在每次注入时都会创建一个新的对象request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</li><li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。</li><li>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</li><li>global-session：全局作用域，</li><li>global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</li></ul><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><p>简单工厂：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p><blockquote><p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p></blockquote><p>工厂方法：</p><blockquote><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p></blockquote><p>单例模式：</p><blockquote><p>spring对单例的实现： spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p></blockquote><p>适配器模式：</p><blockquote><p>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p></blockquote><p>装饰器模式：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p><blockquote><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p></blockquote><p>动态代理：</p><blockquote><p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。<br>织入：把切面应用到目标对象并创建新的代理对象的过程。</p></blockquote><p>观察者模式：</p><blockquote><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p></blockquote><p>策略模式：</p><blockquote><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了<br>Resource 接口来访问底层资源。    </p></blockquote><p>模板方法：父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</p><p>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。</p><blockquote><p>refresh方法</p></blockquote><h1 id="Spring事务的实现方式和原理以及隔离级别"><a href="#Spring事务的实现方式和原理以及隔离级别" class="headerlink" title="Spring事务的实现方式和原理以及隔离级别"></a>Spring事务的实现方式和原理以及隔离级别</h1><p>在使用Spring框架时，可以有两种使用事务的方式，一种是编程式的，一种是申明式的，@Transactional注解就是申明式的。</p><p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p><p>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。</p><p>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。</p><p>当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p><p>spring事务隔离级别就是数据库的隔离级别：外加一个默认级别</p><ul><li>read uncommitted（未提交读）</li><li>read committed（提交读、不可重复读）</li><li>repeatable read（可重复读）</li><li>serializable（可串行化）</li></ul><blockquote><p>数据库的配置隔离级别是Read Commited,而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准？<br>以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</p></blockquote><h1 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h1><p>多个事务方法相互调用时,事务如何在这些方法间传播</p><blockquote><p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都<br>会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就<br>由两个方法所定义的事务传播类型所决定。</p></blockquote><ul><li>REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</li><li>SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</li><li>MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</li><li>REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。</li><li>NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务</li><li>NEVER：不使用事务，如果当前事务存在，则抛出异常</li><li>NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</li></ul><blockquote><p>和REQUIRES_NEW的区别<br>REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我<br>们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。在NESTED情况下父事务回滚时，<br>子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。<br>和REQUIRED的区别<br>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于<br>共用一个事务，所以无论调用方是否catch其异常，事务都会回滚而在NESTED情况下，被调用方发生异常<br>时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</p></blockquote><h1 id="Spring事务什么时候会失效？什么时候-Transactional会失效？"><a href="#Spring事务什么时候会失效？什么时候-Transactional会失效？" class="headerlink" title="Spring事务什么时候会失效？什么时候@Transactional会失效？"></a>Spring事务什么时候会失效？什么时候@Transactional会失效？</h1><p>spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是这个AOP不起作用了！常见情况有如下几种</p><ul><li><p>发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是UserService对象本身！解决方法很简单，让那个this变成UserService的代理类即可！</p></li><li><p>方法不是public的</p><blockquote><p>@Transactional只能用于public的方法上，否则事务不会失效，如果要用在非public方法上，可<br>以开启AspectJ代理模式。</p></blockquote></li><li><p>数据库不支持事务</p></li><li><p>没有被spring管理</p></li><li><p>异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</p></li></ul><p>因为Spring事务是基于代理来实现的，所以某个加了@Transactional的⽅法只有是被代理对象调⽤时，那么这个注解才会⽣效，所以如果是被代理对象来调⽤这个⽅法，那么@Transactional是不会⽣效的。</p><p>同时如果某个⽅法是private的，那么@Transactional也会失效，因为底层cglib是基于⽗⼦类来实现的，⼦类是不能重载⽗类的private⽅法的，所以⽆法很好的利⽤代理，也会导致@Transactianal失效</p><h1 id="bean的自动装配，有哪些方式"><a href="#bean的自动装配，有哪些方式" class="headerlink" title="bean的自动装配，有哪些方式"></a>bean的自动装配，有哪些方式</h1><p>开启自动装配，只需要在xml配置文件中定义“autowire”属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cutomer"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Customer"</span> <span class="attr">autowire</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>autowire属性有五种装配的方式：</p><ul><li>no – 缺省情况下，自动配置是通过“ref”属性手动设定 。</li></ul><blockquote><p>autowire属性有五种装配的方式：<br>no – 缺省情况下，自动配置是通过“ref”属性手动设定。</p></blockquote><ul><li>byName-根据bean的属性名称进行自动装配。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装</span><br><span class="line">配。</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cutomer"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>byType-根据bean的类型进行自动装配。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cutomer"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>constructor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形同，则进行自动装配，否则导致异常。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装</span><br><span class="line">配。</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cutomer"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attr">autowire</span>=<span class="string">"construtor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装配。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装</span><br><span class="line">配。</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cutomer"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Cutomer"</span> <span class="attr">autowire</span>=<span class="string">"construtor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.xxx.xxx.Person"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。</li></ul><h1 id="Spring扩展点"><a href="#Spring扩展点" class="headerlink" title="Spring扩展点"></a><strong>Spring扩展点</strong></h1><ul><li><strong>BeanFactoryPostProcessor</strong><ul><li>BeanDefinitionRegistryPostProcessor</li></ul></li><li><strong>BeanPostProcessor</strong><ul><li>InstantiationAwareBeanPostProcessor</li><li>AbstractAutoProxyCreator</li></ul></li><li><strong>@Import</strong><ul><li>ImportBeanDefinitionRegistrar</li><li>ImportSelector</li></ul></li><li><strong>Aware</strong></li><li><strong>InitializingBean</strong></li><li><strong>FactoryBean</strong></li><li><strong>SmartInitializingSingleton</strong></li><li><strong>ApplicationListener</strong></li><li><strong>Lifecycle</strong><ul><li>SmartLifecycle</li><li>LifecycleProcessor</li></ul></li><li><strong>HandlerInterceptor</strong></li><li><strong>MethodInterceptor</strong></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><h3 id="整合Nacos"><a href="#整合Nacos" class="headerlink" title="整合Nacos"></a><a href="https://www.processon.com/view/link/5ea27ca15653bb6efc68eb8c" target="_blank" rel="noopener">整合Nacos</a></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对ApplicationListener的扩展</span></span><br><span class="line">AbstractAutoServiceRegistration#onApplicationEvent</span><br><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">》NacosServiceRegistry#register</span><br></pre></td></tr></table></figure><p>NacosWatch：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对SmartLifecycle的扩展</span></span><br><span class="line">NacosWatch#start</span><br><span class="line"><span class="comment">#订阅服务接收实例更改的事件</span></span><br><span class="line">》NamingService#subscribe</span><br></pre></td></tr></table></figure><p>Eureka Server端上下文的初始化是在SmartLifecycle#start中实现的</p><p>EurekaServerInitializerConfiguration</p><h3 id="整合Feign"><a href="#整合Feign" class="headerlink" title="整合Feign"></a><a href="https://www.processon.com/view/link/5e80ae79e4b03b99653fe42f" target="_blank" rel="noopener">整合Feign</a></h3><p><strong>FeignClientsRegistrar</strong></p><p><img src="../../../../img/Spring相关的面试题/clipboard-16293616286161.png" alt="img"></p><p><strong>FeignClientFactorybean</strong></p><p><img src="../../../../img/Spring相关的面试题/clipboard.png" alt="img"></p><h3 id="整合Ribbon"><a href="#整合Ribbon" class="headerlink" title="整合Ribbon"></a><a href="https://www.processon.com/view/link/5e7466dce4b027d999bdaddb" target="_blank" rel="noopener"><strong>整合Ribbon</strong></a></h3><p><strong>LoadBalancerAutoConfiguration</strong></p><p>对SmartInitializingSingleton的扩展，为所有用@LaodBalanced修饰的restTemplate（利用了@Qualifier）绑定实现了负载均衡逻辑的拦截器LoadBalancerInterceptor</p><p><img src="../../../../img/Spring相关的面试题/clipboard-16293616691022.png" alt="img"></p><p><strong>LoadBalancerInterceptor</strong></p><p><img src="../../../../img/Spring相关的面试题/clipboard-16293616827233.png" alt="img"></p><h3 id="整合sentinel"><a href="#整合sentinel" class="headerlink" title="整合sentinel"></a><strong>整合sentinel</strong></h3><p><strong>AbstractSentinelInterceptor</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Webmvc接口资源保护入口</span></span><br><span class="line">AbstractSentinelInterceptor#preHandle</span><br></pre></td></tr></table></figure><p><img src="../../../../img/Spring相关的面试题/clipboard-16293617337284.png" alt="img"></p><p><strong>SentinelDataSourceHandler</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sentinel持久化读数据源设计，利用了SmartInitializingSingleton扩展点</span></span><br><span class="line">SentinelDataSourceHandler#afterSingletonsInstantiated</span><br><span class="line"><span class="comment"># 注册一个FactoryBean类型的数据源 </span></span><br><span class="line">》SentinelDataSourceHandler#registerBean</span><br><span class="line">》》NacosDataSourceFactoryBean#getObject</span><br><span class="line"><span class="comment"># 利用FactoryBean获取到读数据源</span></span><br><span class="line">》》new NacosDataSource(properties, groupId, dataId,converter)</span><br></pre></td></tr></table></figure><p><img src="../../../../img/Spring相关的面试题/clipboard-16293617650255.png" alt="img"></p><p><strong>NacosDataSourceFactoryBean</strong></p><p><img src="../../../../img/Spring相关的面试题/clipboard-16293617771986.png" alt="img"></p><h3 id="整合seata"><a href="#整合seata" class="headerlink" title="整合seata"></a><a href="https://www.processon.com/view/link/5f743063e0b34d0711f001d2" target="_blank" rel="noopener"><strong>整合seata</strong></a></h3><p><strong>GlobalTransactionScanner</strong></p><p><a href="/img/clipboard-16293618107487.png"><img src="../../../../img/Spring相关的面试题/clipboard-16293618107487.png" alt="img"></a></p><p><strong>GlobalTransactionalInterceptor</strong></p><p><a href="/img/clipboard-16293618173768.png"><img src="../../../../img/Spring相关的面试题/clipboard-16293618173768.png" alt="img"></a></p><h3 id="Nacos配置中心源码分析"><a href="#Nacos配置中心源码分析" class="headerlink" title="Nacos配置中心源码分析"></a><a href="https://www.processon.com/view/link/603f3d2fe401fd641adb51f1" target="_blank" rel="noopener"><strong>Nacos配置中心源码分析</strong></a></h3>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring、Spring MVC和Spring Boot的联系和区别</title>
      <link href="/sunfy-framework/2021/08/10/resource-Spring-Spring-Spring%E3%80%81Spring-MVC%E5%92%8CSpring-Boot%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/sunfy-framework/2021/08/10/resource-Spring-Spring-Spring%E3%80%81Spring-MVC%E5%92%8CSpring-Boot%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring是一个<strong>IOC容器</strong>，用来管理Bean，使用依赖注入实现控制反转。可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同功能处理成切面、自动注入给方法执行，比如日志处理、异常处理等。</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC<sunfy-line></h2><p>Spring MVC是<strong>Spring对web框架的一个解决方案</strong>，提供了一个总的前端控制器Servlet,用来接收请求，然后定义了一套路由策略（URL到handle的映射）及适配执行handle，将handle结果使用视图解析技术生成视图展现给前端。</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot是<strong>Spring提供的一个快速开发工具包</strong>，让程序员能更方便、更快速的开发Spring+Spring MVC应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、Redis、mongodb、es等，可以开箱即用</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot配置文件加载顺序</title>
      <link href="/sunfy-framework/2021/08/09/resource-Spring-SpringBoot-SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/sunfy-framework/2021/08/09/resource-Spring-SpringBoot-SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件的加载顺序"><a href="#配置文件的加载顺序" class="headerlink" title="配置文件的加载顺序"></a>配置文件的加载顺序</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="外部约定配置文件加载顺序"><a href="#外部约定配置文件加载顺序" class="headerlink" title="外部约定配置文件加载顺序"></a>外部约定配置文件加载顺序</h2><p>优先级由底到高，高优先级的配置会覆盖低优先级的配置；互补配置；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">optional</span>:<span class="string">classpath:/</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">classpath:/config/</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">file:./</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">file:./config/*/</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">file:./config/</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">classpath:custom-config/      --spring.config.location</span></span><br><span class="line"><span class="attr">optional</span>:<span class="string">file:./custom-config/         --spring.config.location</span></span><br></pre></td></tr></table></figure><ul><li>classpath根目录下的</li><li>classpath根config/</li><li>项目根目录(如果当前项目是继承/耦合 关系maven项目的话，项目根目录=父maven项目的根目录)</li><li>项目根目录/config</li><li>直接子目录/config </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar --spring.config.location=D:\config/</span><br></pre></td></tr></table></figure><p><strong>所有配置文件按以下顺序考虑</strong>： 优先级从低到高<sunfy-line></p><ol><li>打包在jar中配置文件  </li><li>打包在jar中profile </li><li>打包的jar之外的配置文件</li><li>打包的jar之外的profile</li></ol><h2 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">optional:classpath:/</span><br><span class="line">optional:classpath:/config/</span><br><span class="line">optional:file:./</span><br><span class="line">optional:file:./config/*/</span><br><span class="line">optional:file:./config/</span><br><span class="line">optional:classpath:custom-config/      --spring.config.location</span><br><span class="line">optional:file:./custom-config/         --spring.config.location</span><br><span class="line"></span><br><span class="line">所有配置文件按以下顺序考虑： 优先级从低到高</span><br><span class="line">打包在jar中配置文件  </span><br><span class="line">打包在jar中profile </span><br><span class="line">打包的jar之外的配置文件</span><br><span class="line">打包的jar之外的profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖底层原理</title>
      <link href="/sunfy-framework/2021/07/23/resource-Spring-Spring-Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/sunfy-framework/2021/07/23/resource-Spring-Spring-Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h1><p>循环依赖简单来说，就是两个对象之间彼此依赖，在A对象中依赖B对象，在B对象中又依赖了A对象。单纯程序代码角度来说，这并不是什么问题，对象之间的相互依赖再正常不过了。但是如果这样的问题放在Spring中，那问题就来了。</p><p>因为在Spring中，一个对象有一个完整的生命周期，并不是简单的new出来就完事了，正因为有了bean的生命周期，才会出现循环依赖的问题。</p><p>那我们有必要先了解一下Spring中Bean的生命周期，参考<a href="/2021/09/09/resource-Spring-Spring-springBeanScan/">SpringBean的生命周期详解</a>、<a href="/2021/09/04/resource-Spring-Spring-springBean/">Spring底层核心原理</a></p><p>通过分析SpringBean的生命周期，我们可以发现，在Spring中，要构造一个Bean，包括了New这个步骤（构造方法反射），得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那我们重点了解下这个注入过程又是怎么样呢？</p><p>比如有一个A类，A类中存在一个B类的b属性，所以在A类生成一个原始对象之后，就会去给b属性去赋值，此时就会选择b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean，</p><ul><li>如果此时BeanFactory中存在B对应的bean，那么直接拿来赋值给b属性；</li><li>如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的bean，然后赋值给b属性。</li></ul><p>如果是第二种情况，那么就需要去生成，就会经过B的bean的生命周期。</p><p>在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么创建B的bean的过程中就需要A类对应的bean，但是触发B类的Bean的创建条件是A类Bean在创建过程中的依赖注入，所以二者相互依赖就出现了循环依赖：</p><p>A(Bean创建) -&gt; 依赖b属性 -&gt; 触发创建B Bean -&gt; B依赖了a属性 -&gt; 需要A Bean （但是此时A的bean还在创建过程中）</p><p>上述过程中就导致了A Bean创建不出来，B Bean也创建不出来。</p><p>在spring中，通过某种机制帮我们解决了部分循环依赖的问题，那就是三级缓存。</p><h1 id="最终目的"><a href="#最终目的" class="headerlink" title="最终目的"></a>最终目的</h1><p>创建依赖对象B的对象A，最终我们想要得到两个经历过完整生命周期的Bean，在Spring中我们在解决简单的循环依赖之外，还要考虑到Spring AOP的问题，我们最终要得到的经历过完整生命周期的Bean，如果bean是需要经过AOP的，那必然得到的是AOP代理对象。带着这个目的，接着看Spring中是如何解决这个问题的。<sunfy-line></p><h1 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h1><p>三级缓存是我们通常的叫法，具体分别是指：</p><ul><li>一级缓存：singletonObjects，其中缓存的是已经经历了完整生命周期的bean对象</li><li>二级缓存：earlySingletonObjects，比singletonObjects多了一个early，表示缓存的是早期的bean对象，早期表示Bean生命周期还没有走完就把这个bean放入了earlySingletonObjects。</li><li>三级缓存：singletonFactories，缓存的是ObjectFactory，表示对象工厂，表示用来创建早期bean的对象工厂。</li></ul><h1 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h1><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>还是上面的例子</p><p>A创建时-&gt; 需要B -&gt; B去创建 -&gt; 需要A，导致产生了循环。</p><p><img src="../../../../img/Spring循环依赖底层原理/image-20210924091518429.png" alt="image-20210924091518429"></p><p>所以说想要解决循环依赖问题，那就必须打破这个循环，如果打破这个循环，Spring中处理方式是增加了中间人，也就是我们上面介绍到的三级缓存。</p><h2 id="Spring解决循环依赖"><a href="#Spring解决循环依赖" class="headerlink" title="Spring解决循环依赖"></a>Spring解决循环依赖</h2><p><img src="../../../../img/Spring循环依赖底层原理/image-20210924091752926.png" alt="image-20210924091752926"></p><p>A的bean创建过程中，进行依赖注入之前，先把A的原始Bean放入缓存（提早进行暴露，只要放到缓存中了，其他bean需要时就可以从缓存中获取到），放入缓存中后，再进行依赖注入，此时A的bean依赖了B的bean，如果B的bean不存在，则需要创建b的Bean，创建过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提在的暴露出来放入缓存中，然后在B的原始对象中进行依赖注入A，此时能从缓存中拿到A的原始对象（只是A的原始对象，并不是最终的bean），B的原始对象依赖注入完之后，B的生命周期结束，那么A的生命周期也能结束。</p><p>在这整个过程中，都只有一个A的原始对象，所以对于B而言，在进行属性注入时，注入的是A的原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p><p>从上面看出，似乎只需要这一个缓存就能够解决循环依赖的问题了，那为什么Spring中还需要singletonFactories呢？</p><p>我们想这么一个场景：如果A的原始对象注入给B属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应并不是AOP之后的代理对象，这就产生了冲突。就会出现 <strong>B依赖的A和最终的A不是同一个对象</strong></p><p>AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectAutoProxyCreator，它的父类AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p><p>一般过程：A类 -&gt; 生成一个普通对象 -&gt; 属性注入 -&gt; 基于切面生成一个代理对象 -&gt; 把代理对象放入singletonObjects单例池中。</p><p>Spring中两个功能是IOC和AOP，而循环依赖又是属于IOC范畴的，这两大功能要想并存，Spring中就需要特殊处理，以实现循环依赖。</p><p>Spring中处理的方式就是利用了三级缓存singletonFactories。</p><p>首先，singletonFactories中村的是某个BeanName对应的ObjectFactory，在bean的生命周期中，生成完原始对象之后，就会构造一个ObjectFactory存入singletonFactories中，这个ObjectFactory是一个函数式接口，所以支持Lambda表达式：<strong>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</strong></p><p>上面的Lambda表达式就是一个ObjectFactory，执行该Lambda表达式就会去执行getEarlyBeanReference方法，而该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会去执行SmartInstantiationAwareBeanPostProcessor中的getEarlyBeanReference方法，而这个接口下的实现类中只有两个类实现了这个方法，一个是AbstractAutoProxyCreator，一个是InstantiationAwareBeanPostProcessorAdapter，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个Spring中，默认就只有AbstractAutoProxyCreator真正意义上实现了getEarlyBeanReference方法，而该类就是用来进行AOP的。上文提到的AnnotationAwareAspectJAutoProxyCreator的父类就是AbstractAutoProxyCreator。</p><p>那么getEarlyBeanReference方法到底在干什么？ 首先得到一个cachekey，cachekey就是beanName。 然后把beanName和bean（这是原始对象）存入earlyProxyReferences中 调用wrapIfNecessary进行AOP，得到一个代理对象。</p><p>那么，什么时候会调用getEarlyBeanReference方法呢？回到循环依赖的场景中</p><p><img src="../../../../img/Spring循环依赖底层原理/image-20210924095036593.png" alt="image-20210924095036593"></p><p>这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p><p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？</p><p>我们这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。</p><p>当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的earlyProxyReferences，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。</p><p>对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要把A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。</p><p><strong>整个循环依赖解决完毕。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，总结一下三级缓存：</p><ul><li><strong>singletonObjects</strong>：缓存经过了<strong>完整生命周期</strong>的bean</li><li><strong>earlySingletonObjects</strong>：缓存<strong>未经过完整生命周期的bean</strong>，如果某个bean出现了循环依赖，就会<strong>提前</strong>把这个暂时未经过完整生命周期的bean放入earlySingletonObjects中，这个bean如果要经过AOP，那么就会把代理对象放入earlySingletonObjects中，否则就是把原始对象放入earlySingletonObjects，但是不管怎么样，就是是代理对象，代理对象所代理的原始对象也是没有经过完整生命周期的，所以放入earlySingletonObjects我们就可以统一认为是<strong>未经过完整生命周期的bean。</strong></li><li><strong>singletonFactories</strong>：缓存的是一个ObjectFactory，也就是一个Lambda表达式。在每个Bean的生成过程中，经过<strong>实例化</strong>得到一个原始对象后，都会提前基于原始对象暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式<strong>可能用到，也可能用不到</strong>，如果当前Bean没有出现循环依赖，那么这个Lambda表达式没用，当前bean按照自己的生命周期正常执行，执行完后直接把当前bean放入singletonObjects中，如果当前bean在依赖注入时发现出现了循环依赖（当前正在创建的bean被其他bean依赖了），则从三级缓存中拿到Lambda表达式，并执行Lambda表达式得到一个对象，并把得到的对象放入二级缓存(如果当前Bean需要AOP，那么执行lambda表达式，得到就是对应的代理对象，如果无需AOP，则直接得到一个原始对象)。</li><li>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP了。</li></ul><h2 id="反向分析singletonFactories"><a href="#反向分析singletonFactories" class="headerlink" title="反向分析singletonFactories"></a>反向分析singletonFactories</h2><p>为什么需要<strong>singletonFactories</strong>？假设没有<strong>singletonFactories</strong>，只有<strong>earlySingletonObjects</strong>，earlySingletonObjects是二级缓存，它内部存储的是未经过完整生命周期的bean对象，Spring原有的流程是出现了循环依赖的情况下：</p><ul><li>先从singletonFactories中拿到lambda表达式，这里肯定是能拿到的，因为每个bean<strong>实例化之后</strong>，<strong>依赖注入之前</strong>，就会生成一个lambda表示放入singletonFactories中</li><li>执行lambda表达式，得到结果，将结果放入earlySingletonObjects中</li></ul><p>那如果没有singletonFactories，该如何把原始对象或AOP之后的代理对象放入earlySingletonObjects中呢？何时放入呢？</p><p>首先，将原始对象或AOP之后的代理对象放入earlySingletonObjects中的有两种：</p><ul><li>实例化之后，依赖注入之前：如果是这样，那么对于每个bean而言，都是在依赖注入之前会去进行AOP，这是不符合bean生命周期步骤的设计的。Spring中AOP发生在初始化之后。</li><li>真正发现某个bean出现了循环依赖时：按现在Spring源码的流程来说，就是getSingleton(String beanName, boolean allowEarlyReference)中，是在这个方法中判断出来了当前获取的这个bean在创建中，就表示获取的这个bean出现了循环依赖，那在这个方法中该如何拿到原始对象呢？更加重要的是，该如何拿到AOP之后的代理对象呢？难道在这个方法中去循环调用BeanPostProcessor的初始化后的方法吗？不是做不到，不太合适，代码太丑。<strong>最关键的是在这个方法中该如何拿到原始对象呢？</strong>还是得需要一个Map，预先把这个Bean实例化后的对象存在这个Map中，那这样的话还不如直接用第一种方案，但是第一种又直接打破了Bean生命周期的设计。</li></ul><p>所以，我们可以发现，现在Spring所用的singletonFactories，为了调和不同的情况，在singletonFactories中存的是lambda表达式，这样的话，只有在出现了循环依赖的情况，才会执行lambda表达式，才会进行AOP，也就说只有在出现了循环依赖的情况下才会打破Bean生命周期的设计，如果一个Bean没有出现循环依赖，那么它还是遵守了Bean的生命周期的设计的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring推断构造方法</title>
      <link href="/sunfy-framework/2021/05/24/resource-Spring-Spring-Spring%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
      <url>/sunfy-framework/2021/05/24/resource-Spring-Spring-Spring%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring推断构造方法"><a href="#Spring推断构造方法" class="headerlink" title="Spring推断构造方法"></a>Spring推断构造方法</h1><p><img src="../../../../img/Spring推断构造方法/image-20211216102033567.png" alt="image-20211216102033567"></p><p><img src="../../../../img/Spring推断构造方法/image-20211216110714192.png" alt="image-20211216110714192"></p><p>Spring中的一个bean，需要实例化得到一个对象，而实例化就需要用到构造方法。</p><h1 id="一个构造方法"><a href="#一个构造方法" class="headerlink" title="一个构造方法"></a>一个构造方法</h1><p>一般情况下，一个类只有一个构造方法：</p><ul><li>要么是无参的构造方法</li><li>要么是有参的构造方法<sunfy-line></li></ul><p>如果只有<strong>一个无参</strong>的构造方法，那么实例化就只能使用这个构造方法了。 如果只有<strong>一个有参</strong>的构造方法，那么实例化时能使用这个构造方法吗？要分情况讨论：</p><ul><li>使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，那么Spring会根据构造方法的参数信息去寻找bean，然后传给构造方法</li><li>使用ClassPathXmlApplicationContext，表示使用XML的方式来使用bean，要么在XML中指定构造方法的参数值(手动指定)，要么配置<strong>autowire=constructor</strong>让Spring<strong>自动</strong>去寻找bean做为构造方法参数值。</li></ul><p>上面是只有一个构造方法的情况，那么如果有多个构造方法呢？</p><h1 id="多个构造方法"><a href="#多个构造方法" class="headerlink" title="多个构造方法"></a>多个构造方法</h1><p>又分为两种情况，多个构造方法中存不存在无参的构造方法。</p><p>分析：一个类存在多个构造方法，那么Spring进行实例化之前，该如何去确定到底用哪个构造方法呢？</p><ul><li>如果开发者指定了想要使用的构造方法，那么就用这个构造方法</li><li>如果开发者没有指定想要使用的构造方法，则看开发者有没有让Spring自动去选择构造方法</li><li>如果开发者也没有让Spring自动去选择构造方法，则Spring利用无参构造方法，如果没有无参构造方法，则报错</li></ul><p>针对第一点，开发者可以通过什么方式来指定使用哪个构造方法呢？</p><ul><li>xml中的<constructor-arg>标签，这个标签表示构造方法参数，所以可以根据这个确定想要使用的构造方法的参数个数，从而确定想要使用的构造方法</li><li>通过@Autowired注解，@Autowired注解可以写在构造方法上，所以哪个构造方法上写了@Autowired注解，表示开发者想使用哪个构造方法，当然，它和第一个方式的不同点是，通过xml的方式，我们直接指定了构造方法的参数值，而通过@Autowired注解的方式，需要Spring通过byType+byName的方式去找到符合条件的bean作为构造方法的参数值</li></ul><p>再来看第二点，如果开发者没有指定想要使用的构造方法，则看开发者有没有让Spring自动去选择构造方法，对于这一点，只能用在ClassPathXmlApplicationContext，因为通过AnnotationConfigApplicationContext没有办法去指定某个bean可以自动去选择构造方法，而通过ClassPathXmlApplicationContext可以在xml中指定某个bean的autowire为constructor，虽然这个属性表示通过构造方法自动注入，所以需要自动的去选择一个构造方法进行自动注入，因为是构造方法，所以顺便是进行实例化。</p><p>当然，还有一种情况，就是多个构造方法上写了@Autowired注解，那么此时Spring会报错。 但是，因为@Autowired还有一个属性required，默认为ture，所以一个类中，只有能一个构造方法标注了@Autowired或@Autowired（required=true），有多个会报错。但是可以有多个@Autowired（required=false）,这种情况下，需要Spring从这些构造方法中去自动选择一个构造方法。</p><h2 id="源码思路"><a href="#源码思路" class="headerlink" title="源码思路"></a>源码思路</h2><ul><li>AbstractAutowireCapableBeanFactory类中的createBeanInstance()方法会去创建一个Bean实例</li><li>根据BeanDefinition加载类得到Class对象</li><li>如果BeanDefinition绑定了一个Supplier，那就调用Supplier的get方法得到一个对象并直接返回</li><li>如果BeanDefinition中存在<strong>factoryMethodName</strong>，那么就<strong>调用该工厂方法</strong>得到一个bean对象并返回</li><li>如果BeanDefinition已经自动构造过了，那就调用autowireConstructor()自动构造一个对象</li><li>调用SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors()方法得到哪些构造方法是可以用的</li><li>如果存在可用得构造方法，或者当前BeanDefinition的autowired是AUTOWIRE_CONSTRUCTOR，或者BeanDefinition中指定了构造方法参数值，或者创建Bean的时候指定了构造方法参数值，那么就调用<strong>autowireConstructor()</strong>方法自动构造一个对象</li><li>最后，如果不是上述情况，就根据无参的构造方法实例化一个对象</li></ul><h3 id="autowireConstructor"><a href="#autowireConstructor" class="headerlink" title="autowireConstructor()"></a><strong>autowireConstructor()</strong></h3><ul><li>先检查是否指定了具体的构造方法和构造方法参数值，或者在BeanDefinition中缓存了具体的构造方法或构造方法参数值，如果存在那么则直接使用该构造方法进行实例化</li><li>如果没有确定的构造方法或构造方法参数值，那么<ul><li>如果没有确定的构造方法，那么则找出类中所有的构造方法</li><li>如果只有一个无参的构造方法，那么直接使用无参的构造方法进行实例化</li><li>如果有多个可用的构造方法或者当前Bean需要自动通过构造方法注入</li><li>根据所指定的构造方法参数值，确定所需要的最少的构造方法参数值的个数</li><li>对所有的构造方法进行排序，参数个数多的在前面</li><li>遍历每个构造方法</li><li>如果不是调用getBean方法时所指定的构造方法参数值，那么则根据构造方法参数类型找值</li><li>如果时调用getBean方法时所指定的构造方法参数值，就直接利用这些值</li><li>如果根据当前构造方法找到了对应的构造方法参数值，那么这个构造方法就是可用的，但是不一定这个构造方法就是最佳的，所以这里会涉及到是否有多个构造方法匹配了同样的值，这个时候就会用值和构造方法类型进行匹配程度的打分，找到一个最匹配的</li></ul></li></ul><h2 id="为什么分越少优先级越高？"><a href="#为什么分越少优先级越高？" class="headerlink" title="为什么分越少优先级越高？"></a>为什么分越少优先级越高？</h2><p>主要是计算找到的bean和构造方法参数类型匹配程度有多高。</p><p>假设bean的类型为A，A的父类是B，B的父类是C，同时A实现了接口D 如果构造方法的参数类型为A，那么完全匹配，得分为0 如果构造方法的参数类型为B，那么得分为2 如果构造方法的参数类型为C，那么得分为4 如果构造方法的参数类型为D，那么得分为1</p><p>可以直接使用如下代码进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object[] objects = <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;A<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">objects</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;B<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">objects</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;C<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">objects</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="keyword">new</span> Class[]&#123;D<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">objects</span>))</span>;</span><br></pre></td></tr></table></figure><p>所以，我们可以发现，越匹配分数越低。</p><h2 id="Bean的情况"><a href="#Bean的情况" class="headerlink" title="@Bean的情况"></a>@Bean的情况</h2><p>首先，Spring会把@Bean修饰的方法解析成BeanDefinition：</p><ul><li>如果方法是static的，那么解析出来的BeanDefinition中：<ul><li>factoryBeanName为AppConfig所对应的beanName，比如”appConfig”</li><li>factoryMethodName为对应的方法名，比如”aService”</li><li>factoryClass为AppConfig.class</li></ul></li><li>如果方法不是static的，那么解析出来的BeanDefinition中：<ul><li>factoryBeanName为null</li><li>factoryMethodName为对应的方法名，比如”aService”</li><li>factoryClass也为AppConfig.class</li></ul></li></ul><p>在由@Bean生成的BeanDefinition中，有一个重要的属性isFactoryMethodUnique，表示factoryMethod是不是唯一的，在普通情况下@Bean生成的BeanDefinition的isFactoryMethodUnique为true，但是如果出现了方法重载，那么就是特殊的情况，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AService <span class="title">aService</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AService <span class="title">aService</span><span class="params">(BService bService)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有两个@Bean，但是肯定只会生成一个aService的Bean，那么Spring在处理@Bean时，也只会生成一个aService的BeanDefinition，比如Spring先解析到第一个@Bean，会生成一个BeanDefinition，此时isFactoryMethodUnique为true，但是解析到第二个@Bean时，会判断出来beanDefinitionMap中已经存在一个aService的BeanDefinition了，那么会把之前的这个BeanDefinition的isFactoryMethodUnique修改为false，并且不会生成新的BeanDefinition了。</p><p>并且后续在根据BeanDefinition创建Bean时，会根据isFactoryMethodUnique来操作，如果为true，那就表示当前BeanDefinition只对应了一个方法，那也就是只能用这个方法来创建Bean了，但是如果isFactoryMethodUnique为false，那就表示当前BeanDefition对应了多个方法，需要和推断构造方法的逻辑一样，去选择用哪个方法来创建Bean。</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成Druid</title>
      <link href="/sunfy-framework/2020/10/12/resource-Spring-SpringBoot-SpringBoot%E9%9B%86%E6%88%90Druid/"/>
      <url>/sunfy-framework/2020/10/12/resource-Spring-SpringBoot-SpringBoot%E9%9B%86%E6%88%90Druid/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot 自动集成starter使用实例，SpringBoot自定义集成Druid。Apache Druid是一个高性能的实时分析数据库。</p><p><a href="https://druid.apache.org/" target="_blank" rel="noopener">druid官网</a><a id="more"></a></p><h2 id="1、druid简介"><a href="#1、druid简介" class="headerlink" title="1、druid简介"></a>1、druid简介</h2><p><img src="../../../../img/SpringBoot集成Druid/image-20210120090838570.png" alt="image-20210120090838570"></p><h2 id="2、页面展示"><a href="#2、页面展示" class="headerlink" title="2、页面展示"></a>2、页面展示</h2><p>集成后访问链接<code>127.0.0.1:8080/druid</code></p><p><img src="../../../../img/SpringBoot集成Druid/image-20210120092042057.png" alt="image-20210120092042057"></p><p><img src="../../../../img/SpringBoot集成Druid/image-20210120092107600.png" alt="image-20210120092107600"></p><h2 id="3、手动集成"><a href="#3、手动集成" class="headerlink" title="3、手动集成"></a>3、手动集成</h2><p>创建一个SpringBoot项目，按照SpringBoot常规的三个步骤进行</p><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖<sunfy-line></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JDBC，数据库链接最基础--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--手动导入druid--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当前使用数据库驱动包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2.  添加配置"></a>2.  添加配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据源</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxx</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.88.88:3306/springboot_mybatis?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment">#   数据源其他配置</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br><span class="line">    <span class="comment">#初始化时运行sql脚本</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">classpath:sql/schema.sql</span></span><br><span class="line">    <span class="attr">initialization-mode:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h3 id="3-添加注解-业务逻辑"><a href="#3-添加注解-业务逻辑" class="headerlink" title="3. 添加注解/业务逻辑"></a>3. 添加注解/业务逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(<span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span></span>&#123;</span><br><span class="line">         <span class="comment">// 根据配置动态构建一个DataSource，这个方式是DataSourceProperties独有的</span></span><br><span class="line">        <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">        servletRegistrationBean.setServlet(<span class="keyword">new</span> StatViewServlet());</span><br><span class="line">        servletRegistrationBean.addUrlMappings(<span class="string">"/druid/*"</span>);</span><br><span class="line">        <span class="comment">// 添加IP白名单</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"allow"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="comment">// 添加控制台管理用户</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginUsername"</span>, <span class="string">"admin"</span>);</span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"loginPassword"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 是否能够重置数据</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">"resetEnable"</span>, <span class="string">"false"</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">statFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        <span class="comment">// 添加过滤规则</span></span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        <span class="comment">// 忽略过滤格式</span></span><br><span class="line">        filterRegistrationBean.addInitParameter(<span class="string">"exclusions"</span>, <span class="string">"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,"</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Data-Source数据注入"><a href="#4、Data-Source数据注入" class="headerlink" title="4、Data Source数据注入"></a>4、Data Source数据注入</h2><h3 id="1-ConfigurationProperties注解"><a href="#1-ConfigurationProperties注解" class="headerlink" title="1. @ConfigurationProperties注解"></a>1. <code>@ConfigurationProperties</code>注解</h3><ul><li>该注解可以使用在类上，则该类下对应的属性会自动注入配置文件中配置信息</li><li>同样该类也可以使用在方法上，在方法中new 对象同样可以自动注入，前提是该方法必须注册为Bean对象（即添加@Bean注解）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span></span>&#123;</span><br><span class="line">    <span class="comment">//        DruidDataSource druidDataSource = new DruidDataSource();</span></span><br><span class="line">    <span class="comment">//        druidDataSource.setMinIdle(1);</span></span><br><span class="line">    <span class="comment">// new的druidDataSource中存在配置文件中配置信息的set方法，可以直接返回new 对象，就可以注入</span></span><br><span class="line">    <span class="comment">// 添加@ConfigurationProperties注解会将配置文件中的信息自动注入在DruidDataSource对象中</span></span><br><span class="line">    <span class="comment">// 这种方法可以很灵活的应用到各个场景</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-DataSourceProperties"><a href="#2-DataSourceProperties" class="headerlink" title="2.DataSourceProperties"></a>2.<code>DataSourceProperties</code></h3><p><code>DataSourceProperties</code>对象提供的方法<code>initializeDataSourceBuilder</code></p><p>配置文件中的属性都是引用的该方法，<code>initializeDataSourceBuilder</code>的作用就是帮我们去构建一个<code>DataSource</code>对象。该方法采用了建造者的设计模式，一般建造者模式都有一个build方法创建相应对象。</p><ul><li>此方法为<code>DataSourceProperties</code>独有的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 根据配置动态构建一个DataSource，这个方式是DataSourceProperties独有的</span></span><br><span class="line">    <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、配置类注解说明"><a href="#5、配置类注解说明" class="headerlink" title="5、配置类注解说明"></a>5、配置类注解说明</h2><ul><li>@Configuration：标注当前类为配置类，SpringBoot启动扫描就可以扫描到当前类</li><li><code>@ConditionalOnProperty(&quot;spring.datasource.type&quot;)</code>： 配置当前对象必须在配置spring.datasource.type后该类才会生效</li><li>两个注解在SpringBoot的各个Starter中是不可或缺的</li></ul><h2 id="6、官方Starter"><a href="#6、官方Starter" class="headerlink" title="6、官方Starter"></a>6、官方Starter</h2><p>经过上面的一番配置，我们实现了想要的功能，我们实现的功能也就是Druid Starter中所具备的功能，接下来我们在有上面自定义配置的基础上看下官方提供的Starter又是如何实现的呢？</p><h3 id="1-添加注解"><a href="#1-添加注解" class="headerlink" title="1. 添加注解"></a>1. 添加注解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以去掉手动配置时引入的druid包</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;1.2.3&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入druid starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-添加配置-1"><a href="#2-添加配置-1" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="comment">#开启druid 监控台servlet</span></span><br><span class="line">      <span class="attr">stat-view-servlet:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">loginPassword:</span> <span class="number">123456</span></span><br><span class="line">      <span class="comment">#开启druid 监控filter</span></span><br><span class="line">      <span class="attr">web-stat-filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>同我们手动配置时一样，配置</p><ul><li>开启druid监控台</li><li>启用druid监控filter</li></ul><h3 id="3-注释自定义配置"><a href="#3-注释自定义配置" class="headerlink" title="3. 注释自定义配置"></a>3. 注释自定义配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="comment">//@ConditionalOnProperty("spring.datasource.type")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>注释掉自定义配置，则我们的自定义配置则全部不会生效。</p><h3 id="4-启动项目"><a href="#4-启动项目" class="headerlink" title="4. 启动项目"></a>4. 启动项目</h3><p>此时启动项目，durid控制台依然是可以正常访问的。这样我们就可以很好的理解和体会SpringBoot的开箱即用</p><h3 id="5-Starter配置文件"><a href="#5-Starter配置文件" class="headerlink" title="5. Starter配置文件"></a>5. Starter配置文件</h3><p>使用我们学到了，具体的Starter中又是如何配置的呢，看配置</p><p><img src="../../../../img/SpringBoot集成Druid/image-20210120101026229.png" alt="image-20210120101026229"></p><p><img src="../../../../img/SpringBoot集成Druid/image-20210120101235996.png" alt="image-20210120101235996"></p><p>从这我们可以看出我们配置文件中配置的开启druid控制台，必须配置<code>spring.datasource.druid.stat-view-servlet.enabled</code>属性为true，才可以生效</p><p><img src="../../../../img/SpringBoot集成Druid/image-20210120101408857.png" alt="image-20210120101408857"></p><p>配置druid拦截器，都也是同样的原理</p><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>通过durid这个插件，自定义与SpringBoot集成以及直接引入Starter两种方式，体验Springboot将我们常用的场景抽取成starter(场景启动器)后给我们带来的便利。体验SpringBoot的开箱即用的便捷的同时，又了解starter具体的实现原理，让我们不至于成为一个简单的操作机器，知其然而知其所以然。</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义staters</title>
      <link href="/sunfy-framework/2020/10/11/resource-Spring-SpringBoot-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89staters/"/>
      <url>/sunfy-framework/2020/10/11/resource-Spring-SpringBoot-SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89staters/</url>
      
        <content type="html"><![CDATA[<p>SpringBoot 最强大的功能就是把我们常用的场景抽取成了一个个starter（场景启动器），我们通过引入springboot 为我提供的这些场景启动器，我们再进行少量的配置就能使用相应的功能。即使是这样，springboot也不能囊括我们所有的使用场景，往往我们需要自定义starter，来简化我们对springboot的使用。</p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener">官网中starter的相关介绍</a><a id="more"></a></p><h2 id="1、官网简介"><a href="#1、官网简介" class="headerlink" title="1、官网简介"></a>1、官网简介</h2><p>入门程序是一组便捷的依赖项描述符，您可以在应用程序中包括它们。您可以一站式购买所需的所有Spring和相关技术，而不必遍历示例代码和依赖描述符的复制粘贴负载。例如，如果要开始使用Spring和JPA进行数据库访问，请<code>spring-boot-starter-data-jpa</code>在项目中包括依赖项。</p><p>入门程序包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的受管传递性依赖项。</p><p><img src="../../../../img/SpringBoot自定义staters/image-20210119111957403.png" alt="image-20210119111957403"></p><h2 id="2、官网推荐命名"><a href="#2、官网推荐命名" class="headerlink" title="2、官网推荐命名"></a>2、官网推荐命名</h2><p>官方starter名称</p><p><img src="../../../../img/SpringBoot自定义staters/image-20210119112125961.png" alt="image-20210119112125961"></p><p>推荐的自建starter命名</p><p><code>thirdpartyproject-spring-boot-starter</code>.</p><p>官方命名空间</p><ul><li>前缀：spring-boot-starter-</li><li>模式：spring-boot-starter-模块名</li><li>举例：spring-boot-starter-web、spring-boot-starter-jdbc</li></ul><p>自定义命名空间</p><ul><li>后缀：-spring-boot-starter</li><li>模式：模块-spring-boot-starter</li><li>举例：mybatis-spring-boot-starter</li></ul><p>命名规范可以参看myBatis命名，SpringBoot关于MyBatis的Stater是MyBatis提供的，并非SpringBoot提供。<sunfy-line></p><p><img src="../../../../img/SpringBoot自定义staters/image-20210119112849108.png" alt="image-20210119112849108"></p><p><img src="../../../../img/SpringBoot自定义staters/image-20210119112928679.png" alt="image-20210119112928679"></p><p>mybatis-spring-boot-starter依赖mybatis-spring-boot-autoconfigure</p><h2 id="3、自定义starter"><a href="#3、自定义starter" class="headerlink" title="3、自定义starter"></a>3、自定义starter</h2><h3 id="1-启动器模块"><a href="#1-启动器模块" class="headerlink" title="1.  启动器模块"></a>1.  启动器模块</h3><ul><li>根据命名规范创建模块</li><li>空的jar文件，仅仅提供辅助性依赖管理，这些依赖可能用于自动装配或其他类库。</li><li>需要专门写一个类似spring-boot-autoconfigure的配置模块</li><li>pom依赖中添加autoconfigure项目依赖</li><li>用的时候只需要引入启动器starter，就可以使用自动配置了</li></ul><h3 id="2-自动配置模块"><a href="#2-自动配置模块" class="headerlink" title="2. 自动配置模块"></a>2. 自动配置模块</h3><p>创建 xxxxx-spring-boot-autoconfigure项目，并配置自动配置类</p><p><strong>不需要启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//指定这个类是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span>  <span class="comment">//指定条件成立的情况下自动配置类生效</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>  <span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">//向容器中添加组件</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>  <span class="comment">//结合相关xxxProperties来绑定相关的配置</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>  <span class="comment">//让xxxProperties生效加入到容器中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动配置类要能加载需要将自动配置类，配置在META-INF/spring.factories中</span></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------自动配置类-------------</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"hello.name"</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloAutoConfitguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndexController <span class="title">indexController</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IndexController(helloProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------属性注入-------------</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------具体业务处理-------------</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexController</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties=helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">-------------spring.factories配置类-------------</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span></span><br><span class="line">  <span class="string">com.starter.HelloAutoConfitguration</span></span><br></pre></td></tr></table></figure><h2 id="4、项目安装"><a href="#4、项目安装" class="headerlink" title="4、项目安装"></a>4、项目安装</h2><p>使用maven命令将两个项目安装至maven仓库，然后在其他项目中就可以引入starter，配置文件中根据自定义的starter规则配置，直接就可以实现开箱即用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成WebSocket通信</title>
      <link href="/sunfy-framework/2020/09/22/resource-Spring-SpringBoot-SpringBoot%E9%9B%86%E6%88%90WebSocket%E9%80%9A%E4%BF%A1/"/>
      <url>/sunfy-framework/2020/09/22/resource-Spring-SpringBoot-SpringBoot%E9%9B%86%E6%88%90WebSocket%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>WebSocket协议是基于TCP的一种新的网络协议。实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。http协议通信只能由客户端发起请求，做不到服务器直接推送消息给客户端。<a id="more"></a></p><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WebSocketConfig"><a href="#WebSocketConfig" class="headerlink" title="WebSocketConfig"></a>WebSocketConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开启webSocket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18 上午9:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocketServer"><a href="#WebSocketServer" class="headerlink" title="WebSocketServer"></a><sunfy-line>WebSocketServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 接受客户端连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18 上午9:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/imserver/&#123;userId&#125;"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, WebSocketServer&gt; webSocketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userId = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 建立成功后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>:</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:02</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, @PathParam(<span class="string">"userId"</span>)</span> String userId) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">if</span> (webSocketMap.containsKey(userId)) &#123;</span><br><span class="line">            webSocketMap.remove(userId);</span><br><span class="line">            webSocketMap.put(userId, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            webSocketMap.put(userId, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 在线人数</span></span><br><span class="line">            addOnlineCount();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"用户连接:"</span> + userId + <span class="string">",当前在线人数为:"</span> + getOnlineCount());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">"连接成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"用户:"</span> + userId + <span class="string">",网络异常!!!!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:04</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (webSocketMap.containsKey(userId)) &#123;</span><br><span class="line">            <span class="comment">//从set中删除</span></span><br><span class="line">            webSocketMap.remove(userId);</span><br><span class="line">            subOnlineCount();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"用户退出:"</span> + userId + <span class="string">",当前在线人数为:"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 客户端session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:04</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"用户消息:"</span> + userId + <span class="string">",报文:"</span> + message);</span><br><span class="line">        <span class="comment">//可以群发消息</span></span><br><span class="line">        <span class="comment">//消息保存到数据库、redis</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(message)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//解析发送的报文</span></span><br><span class="line">                JSONObject jsonObject = JSON.parseObject(message);</span><br><span class="line">                <span class="comment">//追加发送人(防止串改)</span></span><br><span class="line">                jsonObject.put(<span class="string">"fromUserId"</span>, <span class="keyword">this</span>.userId);</span><br><span class="line">                String toUserId = jsonObject.getString(<span class="string">"toUserId"</span>);</span><br><span class="line">                <span class="comment">//传送给对应toUserId用户的websocket</span></span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.isEmpty(toUserId) &amp;&amp; webSocketMap.containsKey(toUserId)) &#123;</span><br><span class="line">                    webSocketMap.get(toUserId).sendMessage(jsonObject.toJSONString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(<span class="string">"请求的userId:"</span> + toUserId + <span class="string">"不在该服务器上"</span>);</span><br><span class="line">                    <span class="comment">//否则不在这个服务器上，发送到mysql或者redis</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 发送消息错误时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 客户端session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error 错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:07</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"用户错误:"</span> + <span class="keyword">this</span>.userId + <span class="string">",原因:"</span> + error.getMessage());</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 服务器主动推送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:09</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 发送自定义消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String message, @PathParam(<span class="string">"userId"</span>)</span> String userId) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"发送消息到:"</span> + userId + <span class="string">"，报文:"</span> + message);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(userId) &amp;&amp; webSocketMap.containsKey(userId)) &#123;</span><br><span class="line">            webSocketMap.get(userId).sendMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"用户"</span> + userId + <span class="string">",不在线！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 获取当前在线人数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 增加在线人数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 在线人数减1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2020/11/18 上午9:11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketServer.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试Controller"><a href="#测试Controller" class="headerlink" title="测试Controller"></a>测试Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sunfy.config.WebSocketServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: sunfy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/18 上午9:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"请求成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"page"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">page</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"websocket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/push/&#123;toUserId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">pushToWeb</span><span class="params">(String message, @PathVariable String toUserId)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        WebSocketServer.sendInfo(message,toUserId);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">"MSG SEND SUCCESS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端测试代码"><a href="#前端测试代码" class="headerlink" title="前端测试代码"></a>前端测试代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>websocket通讯<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">openSocket</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> (WebSocket) == <span class="string">"undefined"</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"您的浏览器不支持WebSocket"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"您的浏览器支持WebSocket"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//实现化WebSocket对象，指定要连接的服务器地址与端口  建立连接</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//等同于socket = new WebSocket("ws://localhost:8888/xxxx/im/25");</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">//var socketUrl="$&#123;request.contextPath&#125;/im/"+$("#userId").val();</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> socketUrl = <span class="string">"http://localhost:8080/imserver/"</span> + $(<span class="string">"#userId"</span>).val();</span></span><br><span class="line"><span class="actionscript">            socketUrl = socketUrl.replace(<span class="string">"https"</span>, <span class="string">"ws"</span>).replace(<span class="string">"http"</span>, <span class="string">"ws"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(socketUrl);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span></span><br><span class="line">                socket.close();</span><br><span class="line"><span class="actionscript">                socket = <span class="literal">null</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            socket = <span class="keyword">new</span> WebSocket(socketUrl);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//打开事件</span></span></span><br><span class="line"><span class="actionscript">            socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"websocket已打开"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//socket.send("这是来自客户端的消息" + location.href + new Date());</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="comment">//获得消息事件</span></span></span><br><span class="line"><span class="actionscript">            socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(msg.data);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//发现消息进入    开始处理前端触发逻辑</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="comment">//关闭事件</span></span></span><br><span class="line"><span class="actionscript">            socket.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"websocket已关闭"</span>);</span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            <span class="comment">//发生了错误事件</span></span></span><br><span class="line"><span class="actionscript">            socket.onerror = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"websocket发生了错误"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> (WebSocket) == <span class="string">"undefined"</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"您的浏览器不支持WebSocket"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"您的浏览器支持WebSocket"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'&#123;"toUserId":"'</span> + $(<span class="string">"#toUserId"</span>).val() + <span class="string">'","contentText":"'</span> + $(<span class="string">"#contentText"</span>).val() + <span class="string">'"&#125;'</span>);</span></span><br><span class="line"><span class="javascript">            socket.send(<span class="string">'&#123;"toUserId":"'</span> + $(<span class="string">"#toUserId"</span>).val() + <span class="string">'","contentText":"'</span> + $(<span class="string">"#contentText"</span>).val() + <span class="string">'"&#125;'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>【userId】：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"userId"</span> <span class="attr">name</span>=<span class="string">"userId"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>【toUserId】：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"toUserId"</span> <span class="attr">name</span>=<span class="string">"toUserId"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>【toUserId】：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"contentText"</span> <span class="attr">name</span>=<span class="string">"contentText"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"hello websocket"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>【操作】：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"openSocket()"</span>&gt;</span>开启socket<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>【操作】：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"sendMessage()"</span>&gt;</span>发送消息<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
