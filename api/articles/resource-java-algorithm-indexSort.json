{"title":"正排索引与倒排索引","num_read":1305,"num_like":735,"num_collection":858,"num_comments":121,"slug":"resource-java-algorithm-indexSort","date":"2021-05-10T16:00:00.000Z","img":"/img/header_img/tools/sort2.gif","_id":"clhrbp2dg0083o5lgh8gd1kb2","project":"algorithm","site":{"data":{}},"updated":"2022-09-19T15:03:54.097Z","comments":true,"path":"api/articles/resource-java-algorithm-indexSort.json","webPath":"2021/05/11/resource-java-algorithm-indexSort/","permalink":"https://sunfy9.gitee.io/2021/05/11/resource-java-algorithm-indexSort/","excerpt":"正排索引与倒排索引","covers":["../../../../img/indexSort/pic1.png","../../../../img/indexSort/pic2.png","../../../../img/indexSort/正排索引2.jpeg","../../../../img/indexSort/倒排索引22.jpeg","../../../../img/indexSort/正排索引1.jpg","../../../../img/indexSort/倒排索引1.jpg","../../../../img/indexSort/倒排索引2.jpg","../../../../img/indexSort/倒排索引3.jpg","../../../../img/indexSort/倒排索引4.jpg","../../../../img/indexSort/倒排索引5.jpg","../../../../img/indexSort/倒排索引6.jpg","../../../../img/2022/end-1660211347530.gif"],"keywords":"sunfy, hexo-theme-snail","content":"<p>正排索引与倒排索引 <a id=\"more\"></a></p>\n<p>正排索引：一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>倒排索引：Inverted index，指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">倒排索引为什么叫倒排索引？ - 水無刹那的回答 - 知乎</span><br><span class=\"line\">https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;23202010&#x2F;answer&#x2F;254503794</span><br><span class=\"line\">[正排索引和倒排索引](https:&#x2F;&#x2F;blog.csdn.net&#x2F;zhangzeyuaaa&#x2F;article&#x2F;details&#x2F;48676775)</span><br><span class=\"line\">[何为倒排](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;37638693)</span><br></pre></td></tr></table></figure>\n<h1 id=\"一句话总结\"><a href=\"#一句话总结\" class=\"headerlink\" title=\"一句话总结\"></a>一句话总结</h1><p>正排索引：一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>倒排索引：Inverted index，指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。<sunfy-line></p>\n<h1 id=\"倒排索引的过程\"><a href=\"#倒排索引的过程\" class=\"headerlink\" title=\"倒排索引的过程\"></a>倒排索引的过程</h1><p>创建倒排索引，分为以下几步：</p>\n<h2 id=\"倒排索引创建索引的流程\"><a href=\"#倒排索引创建索引的流程\" class=\"headerlink\" title=\"倒排索引创建索引的流程\"></a>倒排索引创建索引的流程</h2><h3 id=\"形成文档列表\"><a href=\"#形成文档列表\" class=\"headerlink\" title=\"形成文档列表\"></a>形成文档列表</h3><p>1） lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</p>\n<p><a href=\"http://qiniu.limengting.site/pic1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/pic1.png\" alt=\"img\"></a></p>\n<h3 id=\"创建倒排索引列表\"><a href=\"#创建倒排索引列表\" class=\"headerlink\" title=\"创建倒排索引列表\"></a>创建倒排索引列表</h3><p>2）对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。保存包含这些词条的文档的编号信息。</p>\n<p><a href=\"http://qiniu.limengting.site/pic2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/pic2.png\" alt=\"img\"></a></p>\n<p>谷歌之父–&gt; 谷歌、之父</p>\n<h2 id=\"搜索的过程\"><a href=\"#搜索的过程\" class=\"headerlink\" title=\"搜索的过程\"></a>搜索的过程</h2><p>当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。</p>\n<p>然后根据这些编号去文档列表中找到文档</p>\n<h1 id=\"正排和倒排\"><a href=\"#正排和倒排\" class=\"headerlink\" title=\"正排和倒排\"></a>正排和倒排</h1><h2 id=\"正排索引（正向索引）\"><a href=\"#正排索引（正向索引）\" class=\"headerlink\" title=\"正排索引（正向索引）\"></a>正排索引（正向索引）</h2><p><strong>通过文档ID查文档中的各个词：url -&gt; term，ID为关键字，后面的拉链为文档里面每个字的位置信息</strong></p>\n<p>正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。</p>\n<p>正排表结构如图1所示，这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。</p>\n<p>尽管正排表的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。</p>\n<p><a href=\"http://qiniu.limengting.site/正排索引2.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/正排索引2.jpeg\" alt=\"img\"></a></p>\n<h2 id=\"倒排索引（反向索引）\"><a href=\"#倒排索引（反向索引）\" class=\"headerlink\" title=\"倒排索引（反向索引）\"></a>倒排索引（反向索引）</h2><p><strong>通过某个词查到出现这个词的所有文档：term -&gt; url，后面的拉链为出现这个词的所有文档</strong></p>\n<p>倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。</p>\n<p>由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率。<br>倒排表的结构图如图2：</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引22.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引22.jpeg\" alt=\"img\"></a></p>\n<p>正排索引是从文档到关键字的映射（已知文档求关键字），倒排索引是从关键字到文档的映射（已知关键字求文档）。</p>\n<h1 id=\"倒排\"><a href=\"#倒排\" class=\"headerlink\" title=\"倒排\"></a>倒排</h1><p>倒排工作原理：事先将爬虫拿到的网页数据根据<strong>关键词</strong>分组；将用户请求的<strong>关键词</strong>对应的<strong>分组</strong>返回给用户。</p>\n<h2 id=\"什么是倒排\"><a href=\"#什么是倒排\" class=\"headerlink\" title=\"什么是倒排\"></a>什么是倒排</h2><p>先看看什么是正排，<code>select * from answer where answer_id=1</code> 。我们可以拿到 answer_id = 1 的所有信息：这就是正排。我们为某个文件、某条记录编号，通过这个编号可以拿到所需的信息：这就是正排的工作流程。</p>\n<p><a href=\"http://qiniu.limengting.site/正排索引1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/正排索引1.jpg\" alt=\"img\"></a></p>\n<p>那什么是倒排呢？正排反过来就是倒排</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引1.jpg\" alt=\"img\"></a></p>\n<p>那么，在什么情况下，我们会根据 content 获取它的 id 呢？理论上没有这种场景。当然，任何一个项目，也不会去维护这么一种索引关系（最起码 content 这个 key 实在太大了）。</p>\n<p>但是，我们或许有这么一种场景：判断某个内容是不是已经被存到了库里 （比如防止一个 answer 重复提交）。试想我们可以用这种方案</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引2.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引2.jpg\" alt=\"img\"></a>md5 (content) 做 key</p>\n<p>这样，我们其实是可以根据 content 信息拿到 id 的。</p>\n<h2 id=\"倒排的-hash-冲突\"><a href=\"#倒排的-hash-冲突\" class=\"headerlink\" title=\"倒排的 hash 冲突\"></a>倒排的 hash 冲突</h2><p>那么问题来了，假设真的会有 md5(content) = md5(content1)，这个 key 就不唯一了。上面的情况就会变成</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引3.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引3.jpg\" alt=\"img\"></a></p>\n<p>这时，我们可以根据 answer_id 的正排索引，获取 content 与 content1 ，辅助倒排系统验证功能。</p>\n<p>这个过程是不是似曾相识？不错，这就是 HashMap 中解决 「hash 冲突」的经典思路。</p>\n<h2 id=\"倒排索引系统\"><a href=\"#倒排索引系统\" class=\"headerlink\" title=\"倒排索引系统\"></a>倒排索引系统</h2><p>根据业务需要，对内容选择适当的 hash 规则。将站内所有的内容，组织成的大的 HashMap 即为「倒排索引系统」。</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引4.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引4.jpg\" alt=\"img\"></a></p>\n<p>Hash 大 Map</p>\n<ul>\n<li>所谓的查询，就是 HashMap.get(XX) 获取 list</li>\n<li>所谓的竞价排名，就是这个 list 根据 money 去排序</li>\n<li>所谓的广告植入，就是这个广告本来不在 list 里面，然后被强插进去</li>\n<li>。。。</li>\n</ul>\n<h2 id=\"搜索引擎的工作流程\"><a href=\"#搜索引擎的工作流程\" class=\"headerlink\" title=\"搜索引擎的工作流程\"></a>搜索引擎的工作流程</h2><p><a href=\"http://qiniu.limengting.site/倒排索引5.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引5.jpg\" alt=\"img\"></a></p>\n<h2 id=\"倒排在-Feed-流中的使用\"><a href=\"#倒排在-Feed-流中的使用\" class=\"headerlink\" title=\"倒排在 Feed 流中的使用\"></a>倒排在 Feed 流中的使用</h2><p>如上所示，倒排的工作：将站内数据 hash 化为一个大 map，服务用户请求其实是在 map 里查找数据。与引擎不同的是，Feed 流的只是倒排的 hash 函数不同。</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引6.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引6.jpg\" alt=\"img\"></a></p>\n<p><img src=\"../../../../img/2022/end-1660211347530.gif\" alt=\"end\"></p>\n","more":"</p>\n<p>正排索引：一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>倒排索引：Inverted index，指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">倒排索引为什么叫倒排索引？ - 水無刹那的回答 - 知乎</span><br><span class=\"line\">https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;23202010&#x2F;answer&#x2F;254503794</span><br><span class=\"line\">[正排索引和倒排索引](https:&#x2F;&#x2F;blog.csdn.net&#x2F;zhangzeyuaaa&#x2F;article&#x2F;details&#x2F;48676775)</span><br><span class=\"line\">[何为倒排](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;37638693)</span><br></pre></td></tr></table></figure>\n<h1 id=\"一句话总结\"><a href=\"#一句话总结\" class=\"headerlink\" title=\"一句话总结\"></a>一句话总结</h1><p>正排索引：一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>倒排索引：Inverted index，指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。<sunfy-line></p>\n<h1 id=\"倒排索引的过程\"><a href=\"#倒排索引的过程\" class=\"headerlink\" title=\"倒排索引的过程\"></a>倒排索引的过程</h1><p>创建倒排索引，分为以下几步：</p>\n<h2 id=\"倒排索引创建索引的流程\"><a href=\"#倒排索引创建索引的流程\" class=\"headerlink\" title=\"倒排索引创建索引的流程\"></a>倒排索引创建索引的流程</h2><h3 id=\"形成文档列表\"><a href=\"#形成文档列表\" class=\"headerlink\" title=\"形成文档列表\"></a>形成文档列表</h3><p>1） lucene首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表</p>\n<p><a href=\"http://qiniu.limengting.site/pic1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/pic1.png\" alt=\"img\"></a></p>\n<h3 id=\"创建倒排索引列表\"><a href=\"#创建倒排索引列表\" class=\"headerlink\" title=\"创建倒排索引列表\"></a>创建倒排索引列表</h3><p>2）对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。保存包含这些词条的文档的编号信息。</p>\n<p><a href=\"http://qiniu.limengting.site/pic2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/pic2.png\" alt=\"img\"></a></p>\n<p>谷歌之父–&gt; 谷歌、之父</p>\n<h2 id=\"搜索的过程\"><a href=\"#搜索的过程\" class=\"headerlink\" title=\"搜索的过程\"></a>搜索的过程</h2><p>当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。</p>\n<p>然后根据这些编号去文档列表中找到文档</p>\n<h1 id=\"正排和倒排\"><a href=\"#正排和倒排\" class=\"headerlink\" title=\"正排和倒排\"></a>正排和倒排</h1><h2 id=\"正排索引（正向索引）\"><a href=\"#正排索引（正向索引）\" class=\"headerlink\" title=\"正排索引（正向索引）\"></a>正排索引（正向索引）</h2><p><strong>通过文档ID查文档中的各个词：url -&gt; term，ID为关键字，后面的拉链为文档里面每个字的位置信息</strong></p>\n<p>正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。</p>\n<p>正排表结构如图1所示，这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。</p>\n<p>尽管正排表的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。</p>\n<p><a href=\"http://qiniu.limengting.site/正排索引2.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/正排索引2.jpeg\" alt=\"img\"></a></p>\n<h2 id=\"倒排索引（反向索引）\"><a href=\"#倒排索引（反向索引）\" class=\"headerlink\" title=\"倒排索引（反向索引）\"></a>倒排索引（反向索引）</h2><p><strong>通过某个词查到出现这个词的所有文档：term -&gt; url，后面的拉链为出现这个词的所有文档</strong></p>\n<p>倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。</p>\n<p>由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率。<br>倒排表的结构图如图2：</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引22.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引22.jpeg\" alt=\"img\"></a></p>\n<p>正排索引是从文档到关键字的映射（已知文档求关键字），倒排索引是从关键字到文档的映射（已知关键字求文档）。</p>\n<h1 id=\"倒排\"><a href=\"#倒排\" class=\"headerlink\" title=\"倒排\"></a>倒排</h1><p>倒排工作原理：事先将爬虫拿到的网页数据根据<strong>关键词</strong>分组；将用户请求的<strong>关键词</strong>对应的<strong>分组</strong>返回给用户。</p>\n<h2 id=\"什么是倒排\"><a href=\"#什么是倒排\" class=\"headerlink\" title=\"什么是倒排\"></a>什么是倒排</h2><p>先看看什么是正排，<code>select * from answer where answer_id=1</code> 。我们可以拿到 answer_id = 1 的所有信息：这就是正排。我们为某个文件、某条记录编号，通过这个编号可以拿到所需的信息：这就是正排的工作流程。</p>\n<p><a href=\"http://qiniu.limengting.site/正排索引1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/正排索引1.jpg\" alt=\"img\"></a></p>\n<p>那什么是倒排呢？正排反过来就是倒排</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引1.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引1.jpg\" alt=\"img\"></a></p>\n<p>那么，在什么情况下，我们会根据 content 获取它的 id 呢？理论上没有这种场景。当然，任何一个项目，也不会去维护这么一种索引关系（最起码 content 这个 key 实在太大了）。</p>\n<p>但是，我们或许有这么一种场景：判断某个内容是不是已经被存到了库里 （比如防止一个 answer 重复提交）。试想我们可以用这种方案</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引2.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引2.jpg\" alt=\"img\"></a>md5 (content) 做 key</p>\n<p>这样，我们其实是可以根据 content 信息拿到 id 的。</p>\n<h2 id=\"倒排的-hash-冲突\"><a href=\"#倒排的-hash-冲突\" class=\"headerlink\" title=\"倒排的 hash 冲突\"></a>倒排的 hash 冲突</h2><p>那么问题来了，假设真的会有 md5(content) = md5(content1)，这个 key 就不唯一了。上面的情况就会变成</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引3.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引3.jpg\" alt=\"img\"></a></p>\n<p>这时，我们可以根据 answer_id 的正排索引，获取 content 与 content1 ，辅助倒排系统验证功能。</p>\n<p>这个过程是不是似曾相识？不错，这就是 HashMap 中解决 「hash 冲突」的经典思路。</p>\n<h2 id=\"倒排索引系统\"><a href=\"#倒排索引系统\" class=\"headerlink\" title=\"倒排索引系统\"></a>倒排索引系统</h2><p>根据业务需要，对内容选择适当的 hash 规则。将站内所有的内容，组织成的大的 HashMap 即为「倒排索引系统」。</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引4.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引4.jpg\" alt=\"img\"></a></p>\n<p>Hash 大 Map</p>\n<ul>\n<li>所谓的查询，就是 HashMap.get(XX) 获取 list</li>\n<li>所谓的竞价排名，就是这个 list 根据 money 去排序</li>\n<li>所谓的广告植入，就是这个广告本来不在 list 里面，然后被强插进去</li>\n<li>。。。</li>\n</ul>\n<h2 id=\"搜索引擎的工作流程\"><a href=\"#搜索引擎的工作流程\" class=\"headerlink\" title=\"搜索引擎的工作流程\"></a>搜索引擎的工作流程</h2><p><a href=\"http://qiniu.limengting.site/倒排索引5.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引5.jpg\" alt=\"img\"></a></p>\n<h2 id=\"倒排在-Feed-流中的使用\"><a href=\"#倒排在-Feed-流中的使用\" class=\"headerlink\" title=\"倒排在 Feed 流中的使用\"></a>倒排在 Feed 流中的使用</h2><p>如上所示，倒排的工作：将站内数据 hash 化为一个大 map，服务用户请求其实是在 map 里查找数据。与引擎不同的是，Feed 流的只是倒排的 hash 函数不同。</p>\n<p><a href=\"http://qiniu.limengting.site/倒排索引6.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/indexSort/倒排索引6.jpg\" alt=\"img\"></a></p>\n<p><img src=\"../../../../img/2022/end-1660211347530.gif\" alt=\"end\"></p>","next":{"title":"idea利用docker插件打包上传","path":"api/articles/resource-RPC-Docker-dockerBuildFormIdea.json","image":"/img/header_img/17.gif","num_read":761,"num_like":960,"num_collection":183,"num_comments":106},"prev":{"title":"Docker 修改MySQL配置","path":"api/articles/resource-RPC-Docker-dockerEditMySQL.json","image":"/img/header_img/docker/docker.jpg","num_read":588,"num_like":490,"num_collection":443,"num_comments":90},"categories":[{"name":"算法","path":"api/categories/算法.json","pathContent":"api/categories/算法","description":"为了更有效的处理数据，提高数据运算效率。","cover":"https://sunfy9.gitee.io/project/photo/project/algorithm.png"}],"tags":[]}