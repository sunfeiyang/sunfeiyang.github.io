{"title":"SQLSERVER数据库索引","num_read":1572,"num_like":545,"num_collection":226,"num_comments":194,"slug":"resource-DB-SQLServer-索引","date":"2022-06-22T16:00:00.000Z","img":"/img/header_img/DB/sqlserverIndex.png","_id":"clhrbp2aw0020o5lg1cep5sku","project":"DB","subtitle":"固定服务器|数据库角色|设置示例","hot":"read","site":{"data":{}},"updated":"2022-09-20T01:29:13.240Z","comments":true,"path":"api/articles/resource-DB-SQLServer-索引.json","webPath":"2022/06/23/resource-DB-SQLServer-索引/","permalink":"https://sunfy9.gitee.io/2022/06/23/resource-DB-SQLServer-%E7%B4%A2%E5%BC%95/","excerpt":null,"covers":["../../../../img/索引/b58f8c5494eef01fe3d38355eefe9925bd317d5f.jpg","../../../../img/索引/4b90f603738da97773341cbbbe51f8198618e303.jpg","../../../../img/索引/8718367adab44aed7c552474bd1c8701a18bfb03.jpg","../../../../img/索引/9345d688d43f8794b7efd2bedc1b0ef41bd53a09.jpg","../../../../img/索引/54fbb2fb43166d2234598f04482309f79052d270.jpg","../../../../img/索引/21a4462309f790521831ddae02f3d7ca7bcbd570.jpg","../../../../img/索引/0df3d7ca7bcb0a46740c11a96563f6246b60af70.jpg"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"SqlServer索引的原理与应用\"><a href=\"#SqlServer索引的原理与应用\" class=\"headerlink\" title=\"SqlServer索引的原理与应用\"></a><a href=\"https://www.cnblogs.com/knowledgesea/p/3672099.html\" target=\"_blank\" rel=\"noopener\">SqlServer索引的原理与应用</a></h1><h1 id=\"索引的概念\"><a href=\"#索引的概念\" class=\"headerlink\" title=\"索引的概念\"></a>索引的概念</h1><p>索引的用途：我们对数据查询及处理速度已成为衡量应用系统成败的标准，而采用索引来加快数据处理速度通常是最普遍采用的优化方法。</p>\n<p>索引是什么：数据库中的索引类似于一本书的目录，在一本书中使用目录可以快速找到你想要的信息，而不需要读完全书。在数据库中，数据库程序使用索引可以重啊到表中的数据，而不必扫描整个表。书中的目录是一个字词以及各字词所在的页码列表，数据库中的索引是表中的值以及各值存储位置的列表。</p>\n<p>索引的利弊：查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。<sunfy-line></p>\n<h1 id=\"数据表的基本结构\"><a href=\"#数据表的基本结构\" class=\"headerlink\" title=\"数据表的基本结构\"></a>数据表的基本结构</h1><p>一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）。</p>\n<p>SQLS规定行不能跨越数据页，所以，每行记录的最大数据量只能为8K。这就是char和varchar这两种字符串类型容量要限制在8K以内的 原因，存储超过8K的数据应使用text类型，实际上，text类型的字段值不能直接录入和保存，它只是存储一个指针，指向由若干8K的文本数据页所组成 的扩展区，真正的数据正是放在这些数据页中。 </p>\n<p>页面有空间页面和数据页面之分。  </p>\n<p>当一个扩展区的8个数据页中既包含了空间页面又包括了数据或索引页面时，称为混合扩展（Mixed Extent）,每张表都以混合扩展开始；反之，称为一致扩展（Uniform Extent），专门保存数据及索引信息。 </p>\n<p>表被创建之时，SQLS在混合扩展中为其分配至少一个数据页面，随着数据量的增长，SQLS可即时在混合扩展中分配出7个页面，当数据超过8个页面时，则从一致扩展中分配数据页面。  </p>\n<p>空间页面专门负责数据空间的分配和管理，包括：PFS页面（Page free space）：记录一个页面是否已分配、位于混合扩展还是一致扩展以及页面上还有多少可用空间等信息；GAM页面（Global allocation map）和SGAM页面(Secodary global allocation map)：用来记录空闲的扩展或含有空闲页面的混合扩展的位置。SQLS综合利用这三种类型的页面文件在必要时为数据表创建新空间；  </p>\n<p>数据页或索引页则专门保存数据及索引信息，SQLS使用4种类型的数据页面来管理表或索引：它们是IAM页、数据页、文本/图像页和索引页。 </p>\n<p>在WINDOWS中，我们对文件执行的每一步操作，在磁盘上的物理位置只有系统（system）才知道；SQL SERVER沿袭了这种工作方式，在插入数据的过程中，不但每个字段值在数据页面中的保存位置是随机的，而且每个数据页面在“堆”中的排列位置也只有系统 （system）才知道。  </p>\n<p>这是为什么呢？众所周知，OS之所以能管理DISK，是因为在系统启动时首先加载了文件分配表：FAT（File Allocation Table），正是由它管理文件系统并记录对文件的一切操作，系统才得以正常运行；同理，作为管理系统级的SQL SERVER,也有这样一张类似FAT的表存在，它就是索引分布映像页：IAM（Index Allocation Map）。  </p>\n<p>IAM的存在，使SQLS对数据表的物理管理有了可能。  </p>\n<p>IAM页从混合扩展中分配，记录了8个初始页面的位置和该扩展区的位置，每个IAM页面能管理512,000个数据页面，如果数据量太 大，SQLS也可以增加更多的IAM页，可以位于文件的任何位置。第一个IAM页被称为FirstIAM,其中记录了以后的IAM页的位置。  </p>\n<p>数据页和文本/图像页互反，前者保存非文本/图像类型的数据，因为它们都不超过8K的容量，后者则只保存超过8K容量的文本或图像类型数据。而索 引页顾名思义，保存的是与索引结构相关的数据信息。了解页面的问题有助我们下一步准确理解SQLS维护索引的方式，如页拆分、填充因子等。 </p>\n<h1 id=\"页分裂\"><a href=\"#页分裂\" class=\"headerlink\" title=\"页分裂\"></a>页分裂</h1><p>一半的数据将保留在老页面，而另一半将放入新页面，并且新页面可能被分配到任何可用的页。所以，频繁页分裂，后果很严重，将使物理表产生大量数据碎片，导致直接造成I/O效率的急剧下降，最后，停止SQLS的运行并重建索引将是我们的唯一选择!</p>\n<h1 id=\"填充因子\"><a href=\"#填充因子\" class=\"headerlink\" title=\"填充因子\"></a>填充因子</h1><p>索引的一个特性，定义该索引每页上的可用空间量。FILLFACTOR（填充因子）适应以后表数据的扩展并减小了页拆分的可能性。填充因子是从0到100的百分比数值，设为100时表示将数据页填满。只有当不会对数据进行更改时(例如 只读表中)才用此设置。值越小则数据页上的空闲空间越大，这样可以减少在索引增长过程中进行页分裂的需要，但这一操作需要占用更多的硬盘空间。填充因子指定不当，会降低数据库的读取性能，其降低量与填充因子设置值成反比。</p>\n<h1 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h1><p>SQL SERVER中有多种索引类型。</p>\n<p>按存储结构区分：“聚集索引（又称聚类索引，簇集索引）”，“分聚集索引（非聚类索引，非簇集索引）”</p>\n<p>按数据唯一性区分：“唯一索引”，“非唯一索引”</p>\n<p>按键列个数区分：“单列索引”，“多列索引”。</p>\n<h1 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h1><p>聚集索引是一种对磁盘上实际数据重新组织以按指定的一列或多列值排序。像我们用到的汉语字典，就是一个聚集索引，比如要查“张”，我们自然而然就翻到字典的后面百十页。然后根据字母顺序跟查找出来。这里用到微软的平衡二叉树算法，即首先把书翻到大概二分之一的位置，如果要找的页码比该页的页码小，就把书向前翻到四分之一处，否则，就把书向后翻到四分之三的地方，依此类推，把书页续分成更小的部分，直至正确的页码。</p>\n<p>由于聚集索引是给数据排序，不可能有多种排法，所以一个表只能建立一个聚集索引。科学统计建立这样的索引需要至少相当与该表120%的附加空间，用来存放该表的副本和索引中间页，但是他的性能几乎总是比其它索引要快。</p>\n<p>由于在聚集索引下，数据在物理上是按序排列在数据页上的，重复值也排在一起，因而包含范围检查（bentween,&lt;,&gt;&lt;=,&gt;=）或使用group by 或order by的查询时，一旦找到第一个键值的行，后面都将是连在一起，不必在进一步的搜索，避免啦大范围的扫描，可以大大提高查询速度。</p>\n<h1 id=\"非聚集索引\"><a href=\"#非聚集索引\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h1><p>sqlserver默认情况下建立的索引是非聚集索引，他不重新组织表中的数据，而是对每一行存储索引列值并用一个指针指向数据所在的页面。他像汉语字典中的根据‘偏旁部首’查找要找的字，即便对数据不排序，然而他拥有的目录更像是目录，对查取数据的效率也是具有的提升空间，而不需要全表扫描。</p>\n<p>一个表可以拥有多个非聚集索引，每个非聚集索引根据索引列的不同提供不同的排序顺序。</p>\n<h1 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h1><p><strong>语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE [UNIQUE] [CLUSTERED| NONCLUSTERED ]</span><br><span class=\"line\">INDEX index_name ON &#123; table | view &#125; ( column [ ASC | DESC ] [ ,...n ] )</span><br><span class=\"line\">[with[PAD_INDEX][[,]FILLFACTOR&#x3D;fillfactor]</span><br><span class=\"line\">[[,]IGNORE_DUP_KEY]</span><br><span class=\"line\">[[,]DROP_EXISTING]</span><br><span class=\"line\">[[,]STATISTICS_NORECOMPUTE]</span><br><span class=\"line\">[[,]SORT_IN_TEMPDB]</span><br><span class=\"line\">]</span><br><span class=\"line\">[ ON filegroup ]</span><br></pre></td></tr></table></figure>\n<p>CREATE INDEX命令创建索引各参数说明如下：</p>\n<p>UNIQUE：用于指定为表或视图创建唯一索引，即不允许存在索引值相同的两行。</p>\n<p>CLUSTERED：用于指定创建的索引为聚集索引。</p>\n<p>NONCLUSTERED：用于指定创建的索引为非聚集索引。</p>\n<p>index_name：用于指定所创建的索引的名称。</p>\n<p>table：用于指定创建索引的表的名称。</p>\n<p>view：用于指定创建索引的视图的名称。</p>\n<p>ASC|DESC：用于指定具体某个索引列的升序或降序排序方向。</p>\n<p>Column：用于指定被索引的列。</p>\n<p>PAD_INDEX：用于指定索引中间级中每个页（节点）上保持开放的空间。</p>\n<p>FILLFACTOR = fillfactor：用于指定在创建索引时，每个索引页的数据占索引页大小的百分比，fillfactor的值为1到100。</p>\n<p>IGNORE_DUP_KEY：用于控制当往包含于一个唯一聚集索引中的列中插入重复数据时SQL Server所作的反应。</p>\n<p>DROP_EXISTING：用于指定应删除并重新创建已命名的先前存在的聚集索引或者非聚集索引。</p>\n<p>STATISTICS_NORECOMPUTE：用于指定过期的索引统计不会自动重新计算。</p>\n<p>SORT_IN_TEMPDB：用于指定创建索引时的中间排序结果将存储在 tempdb 数据库中。</p>\n<p>ON filegroup：用于指定存放索引的文件组。</p>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--表bigdata创建一个名为idx_mobiel的非聚集索引，索引字段为mobiel</span><br><span class=\"line\">create index idx_mobiel</span><br><span class=\"line\">on bigdata(mobiel) </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">--表bigdata创建一个名为idx_id的唯一聚集索引，索引字段为id</span><br><span class=\"line\">--要求成批插入数据时忽略重复值，不重新计算统计信息，填充因子为40</span><br><span class=\"line\">create unique clustered index idx_id</span><br><span class=\"line\">on bigdata(id) </span><br><span class=\"line\">with pad_index,</span><br><span class=\"line\">fillfactor&#x3D;40,</span><br><span class=\"line\">ignore_dup_key,</span><br><span class=\"line\">statistics_norecompute</span><br></pre></td></tr></table></figure>\n<h1 id=\"管理索引\"><a href=\"#管理索引\" class=\"headerlink\" title=\"管理索引\"></a>管理索引</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exec sp_helpindex BigData   --查看索引定义</span><br><span class=\"line\"></span><br><span class=\"line\">Exec sp_rename &#39;BigData.idx_mobiel&#39;,&#39;idx_big_mobiel&#39;  --将索引名由&#39;idx_mobiel&#39; 改为&#39;idx_big_mobiel&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">drop index BigData.idx_big_mobiel  --删除bigdata表中的idx_big_mobiel索引</span><br><span class=\"line\"></span><br><span class=\"line\">dbcc showcontig(bigdata,idx_mobiel) --检查bigdata表中索引idx_mobiel的碎片信息</span><br><span class=\"line\"></span><br><span class=\"line\">dbcc indexdefrag(Test,bigdata,idx_mobiel)  --整理test数据库中bigdata表的索引idx_mobiel上的碎片</span><br><span class=\"line\"></span><br><span class=\"line\">update statistics bigdata  --更新bigdata表中的全部索引的统计信息</span><br></pre></td></tr></table></figure>\n<h1 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a>索引的设计原则</h1><p>对于一张表来说索引的有无和建立什么样的索引，要取决与where字句和Join表达式中。</p>\n<p>一般来说建立索引的原则包括以下内容：</p>\n<ul>\n<li>系统一般会给逐渐字段自动建立聚集索引。</li>\n<li>有大量重复值且经常有范围查询和排序、分组的列，或者经常频繁访问的列，考虑建立聚集索引。</li>\n<li>在一个经常做插入操作的表中建立索引，应使用fillfactor(填充因子)来减少页分裂，同时提高并发度降低死锁的发生。如果在表为只读表，填充因子可设为100.</li>\n<li>在选择索引键时，尽可能采用小数据类型的列作为键以使每个索引页能容纳尽可能多的索引键和指针，通过这种方式，可使一个查询必需遍历的索引页面降低到最小，此外，尽可能的使用整数做为键值，因为整数的访问速度最快。</li>\n</ul>\n<h1 id=\"sql-server如何给列添加索引听语音\"><a href=\"#sql-server如何给列添加索引听语音\" class=\"headerlink\" title=\"sql server如何给列添加索引听语音\"></a>sql server如何给列添加索引听语音</h1><p>sql server中用索引可以加快检索速度，那么如何给列添加索引呢？下面小编给大家分享一下。</p>\n<h2 id=\"方法-步骤\"><a href=\"#方法-步骤\" class=\"headerlink\" title=\"方法/步骤\"></a>方法/步骤</h2><ol>\n<li><p>首先右键选择数据表，点击设计，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=1\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/b58f8c5494eef01fe3d38355eefe9925bd317d5f.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着右键要设置的字段，选择索引，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=2\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/4b90f603738da97773341cbbbe51f8198618e303.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>然后点击左下角的添加按钮，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=3\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/8718367adab44aed7c552474bd1c8701a18bfb03.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接下来点击列后面的三个点，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=4\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/9345d688d43f8794b7efd2bedc1b0ef41bd53a09.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着在下拉框中选择列就可以了，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=5\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/54fbb2fb43166d2234598f04482309f79052d270.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着在右侧选择升序还是降序，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=6\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/21a4462309f790521831ddae02f3d7ca7bcbd570.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>最后如果不想用索引了就可以选中删除即可，如下图所示</p>\n</li>\n</ol>\n<p>   <a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=7\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/0df3d7ca7bcb0a46740c11a96563f6246b60af70.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n<h1 id=\"SqlServer为字段创建索引\"><a href=\"#SqlServer为字段创建索引\" class=\"headerlink\" title=\"SqlServer为字段创建索引\"></a><a href=\"https://www.cnblogs.com/likui-bookHouse/p/8622410.html\" target=\"_blank\" rel=\"noopener\">SqlServer为字段创建索引</a></h1><p>语法：<br>CREATE [索引类型] INDEX 索引名称<br>ON 表名(列名)</p>\n<p>创建索引实例：</p>\n<p>聚簇索引 create clustered index index_name on table_name (cloumn_name);</p>\n<p>非聚簇索引 create nonclustered index index_name on table_name (cloumn_name);</p>\n<p>唯一索引 create unique index index_name on table_name(cloumn_name);</p>\n<p>删除索引方法：</p>\n<p>　　可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</p>\n<p>　　DROP INDEX index_name ON talbe_name</p>\n<p>　　ALTER TABLE table_name DROP INDEX index_name</p>\n<p>　　ALTER TABLE table_name DROP PRIMARY KEY</p>\n<p>　　其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p>\n<p>　　第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p>\n<p>总结：<br>      1.什么是索引：数据库中的索引是某个表中一列或多列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。<br>  2.分类：<br>     (1) 唯一索引(UNIQUE)：不允许两行具有相同的索引值（创建了唯一约束，系统将自动创建唯一索引）</p>\n<p>　　在表上创建唯一索引。唯一索引是不允许其中任意两行具有相同索引值的索引。</p>\n<p>SQL Server 2005 Compact Edition (SQL Server Compact Edition) 在创建索引后将检查是否存在重复的值（如果数据已存在），并在每次使用 INSERT 或 UPDATE 语句添加数据时执行该检查操作。必须先消除重复值，然后才可对列创建唯一索引。如果存在重复的键值，则将取消 CREATE INDEX 语句并返回错误。只能对定义为 NOT NULL 的列创建唯一索引。</p>\n<p>如果存在唯一索引，则可能生成重复键值的 UPDATE 或 INSERT 语句将回滚，且 SQL Server Compact Edition 返回错误。即使 UPDATE 或 INSERT 语句更改许多行，但只要存在一个重复，上面这一点也将成立。</p>\n<p>​       (2)  主键索引：主键索引要求主键中的每个值是唯一的，（创建主键自动创建主键索引）<br>​       (3)  聚集索引(CLUSTERED)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，表中只能包含一个聚集索引，主键列默认为聚集索引<br>​       (4) 非聚集索引(NONCLUSTERED)：表中各行的物理顺序与键值的逻辑（索引）顺序不匹配，表中可以有249个非聚集索引<br>​    3.创建索引的标准：用语频繁搜索的列；用语对数据进行排序的列<br>注意：如果表中仅有几行，或列中只包含几个不同的值，不推荐创建索引，因为SQL Server 在小型表中用索引搜索数据所花的时间比逐行搜索更长。</p>\n<h1 id=\"SQL-SERVER中查询某个表或某个索引是否存在\"><a href=\"#SQL-SERVER中查询某个表或某个索引是否存在\" class=\"headerlink\" title=\"SQL SERVER中查询某个表或某个索引是否存在\"></a><a href=\"https://www.cnblogs.com/accumulater/p/6144697.html\" target=\"_blank\" rel=\"noopener\">SQL SERVER中查询某个表或某个索引是否存在</a></h1><p><strong>查询某个表是否存在：</strong></p>\n<p>在实际应用中可能需要删除某个表，在删除之前最好先判断一下此表是否存在，以防止返回错误信息。在SQL SERVER中可通过以下语句实现：</p>\n<p>IF OBJECT_ID(N’表名称’, N’U’) IS NOT NULL </p>\n<p>DROP TABLE 表名称;</p>\n<p>注意，普通表和临时表的使用差别：</p>\n<p>若希望删除TEST库中的dbo.TestTable表，直接将dbo.TestTable作为表名即可。</p>\n<p>若希望删除临时表dbo.#temp_table，需要以tempdb.dbo.#temp_table作为表名。</p>\n<p><strong>查询表上的某个索引是否存在：</strong></p>\n<p>通常情况下，为了提高数据的查询效率，我们会为表的特定字段创建索引，同一个表上的索引名称是不同的。那么如何判断某个表是否已经存在特定名称的索引了呢？可通过下面的语句判断：</p>\n<p>SELECT 1 FROM sys.indexes WHERE object_id=OBJECT_ID(@tname, N’U’) and NAME=@iname</p>\n<p>其中：@tname表示建索引的表名，@iname表示索引名。</p>\n<p><strong>扩展知识</strong></p>\n<p>在每一个数据库中都有sys.sysobjects用于包括在数据库中创建的每个对象（例如约束、默认值、日志、规则以及存储过程）。详细的说明信息参看MSDN上的帮助文档：sys.sysobjects</p>\n<p>OBJECT_ID的作用是返回架构范围内对象的数据库对象标识号。如果找不到数据库或对象的名称，例如相应名称不存在或拼写不正确，则会返回NULL。详细的说明信息参看MSDN上的帮助文档：object_id</p>\n<p>sys.indexes用于保存每个表格对象（例如，表、视图或表值函数）的索引或堆，详细的说明信息参看MSDN上的帮助文档：sys.indexes</p>\n","more":"<h1 id=\"SqlServer索引的原理与应用\"><a href=\"#SqlServer索引的原理与应用\" class=\"headerlink\" title=\"SqlServer索引的原理与应用\"></a><a href=\"https://www.cnblogs.com/knowledgesea/p/3672099.html\" target=\"_blank\" rel=\"noopener\">SqlServer索引的原理与应用</a></h1><h1 id=\"索引的概念\"><a href=\"#索引的概念\" class=\"headerlink\" title=\"索引的概念\"></a>索引的概念</h1><p>索引的用途：我们对数据查询及处理速度已成为衡量应用系统成败的标准，而采用索引来加快数据处理速度通常是最普遍采用的优化方法。</p>\n<p>索引是什么：数据库中的索引类似于一本书的目录，在一本书中使用目录可以快速找到你想要的信息，而不需要读完全书。在数据库中，数据库程序使用索引可以重啊到表中的数据，而不必扫描整个表。书中的目录是一个字词以及各字词所在的页码列表，数据库中的索引是表中的值以及各值存储位置的列表。</p>\n<p>索引的利弊：查询执行的大部分开销是I/O，使用索引提高性能的一个主要目标是避免全表扫描，因为全表扫描需要从磁盘上读取表的每一个数据页，如果有索引指向数据值，则查询只需要读少数次的磁盘就行啦。所以合理的使用索引能加速数据的查询。但是索引并不总是提高系统的性能，带索引的表需要在数据库中占用更多的存储空间，同样用来增删数据的命令运行时间以及维护索引所需的处理时间会更长。所以我们要合理使用索引，及时更新去除次优索引。<sunfy-line></p>\n<h1 id=\"数据表的基本结构\"><a href=\"#数据表的基本结构\" class=\"headerlink\" title=\"数据表的基本结构\"></a>数据表的基本结构</h1><p>一个新表被创建之时，系统将在磁盘中分配一段以8K为单位的连续空间，当字段的值从内存写入磁盘时，就在这一既定空间随机保存，当一个 8K用完的时候，数据库指针会自动分配一个8K的空间。这里，每个8K空间被称为一个数据页（Page），又名页面或数据页面，并分配从0-7的页号, 每个文件的第0页记录引导信息，叫文件头（File header）；每8个数据页（64Ｋ）的组合形成扩展区（Extent），称为扩展。全部数据页的组合形成堆（Heap）。</p>\n<p>SQLS规定行不能跨越数据页，所以，每行记录的最大数据量只能为8K。这就是char和varchar这两种字符串类型容量要限制在8K以内的 原因，存储超过8K的数据应使用text类型，实际上，text类型的字段值不能直接录入和保存，它只是存储一个指针，指向由若干8K的文本数据页所组成 的扩展区，真正的数据正是放在这些数据页中。 </p>\n<p>页面有空间页面和数据页面之分。  </p>\n<p>当一个扩展区的8个数据页中既包含了空间页面又包括了数据或索引页面时，称为混合扩展（Mixed Extent）,每张表都以混合扩展开始；反之，称为一致扩展（Uniform Extent），专门保存数据及索引信息。 </p>\n<p>表被创建之时，SQLS在混合扩展中为其分配至少一个数据页面，随着数据量的增长，SQLS可即时在混合扩展中分配出7个页面，当数据超过8个页面时，则从一致扩展中分配数据页面。  </p>\n<p>空间页面专门负责数据空间的分配和管理，包括：PFS页面（Page free space）：记录一个页面是否已分配、位于混合扩展还是一致扩展以及页面上还有多少可用空间等信息；GAM页面（Global allocation map）和SGAM页面(Secodary global allocation map)：用来记录空闲的扩展或含有空闲页面的混合扩展的位置。SQLS综合利用这三种类型的页面文件在必要时为数据表创建新空间；  </p>\n<p>数据页或索引页则专门保存数据及索引信息，SQLS使用4种类型的数据页面来管理表或索引：它们是IAM页、数据页、文本/图像页和索引页。 </p>\n<p>在WINDOWS中，我们对文件执行的每一步操作，在磁盘上的物理位置只有系统（system）才知道；SQL SERVER沿袭了这种工作方式，在插入数据的过程中，不但每个字段值在数据页面中的保存位置是随机的，而且每个数据页面在“堆”中的排列位置也只有系统 （system）才知道。  </p>\n<p>这是为什么呢？众所周知，OS之所以能管理DISK，是因为在系统启动时首先加载了文件分配表：FAT（File Allocation Table），正是由它管理文件系统并记录对文件的一切操作，系统才得以正常运行；同理，作为管理系统级的SQL SERVER,也有这样一张类似FAT的表存在，它就是索引分布映像页：IAM（Index Allocation Map）。  </p>\n<p>IAM的存在，使SQLS对数据表的物理管理有了可能。  </p>\n<p>IAM页从混合扩展中分配，记录了8个初始页面的位置和该扩展区的位置，每个IAM页面能管理512,000个数据页面，如果数据量太 大，SQLS也可以增加更多的IAM页，可以位于文件的任何位置。第一个IAM页被称为FirstIAM,其中记录了以后的IAM页的位置。  </p>\n<p>数据页和文本/图像页互反，前者保存非文本/图像类型的数据，因为它们都不超过8K的容量，后者则只保存超过8K容量的文本或图像类型数据。而索 引页顾名思义，保存的是与索引结构相关的数据信息。了解页面的问题有助我们下一步准确理解SQLS维护索引的方式，如页拆分、填充因子等。 </p>\n<h1 id=\"页分裂\"><a href=\"#页分裂\" class=\"headerlink\" title=\"页分裂\"></a>页分裂</h1><p>一半的数据将保留在老页面，而另一半将放入新页面，并且新页面可能被分配到任何可用的页。所以，频繁页分裂，后果很严重，将使物理表产生大量数据碎片，导致直接造成I/O效率的急剧下降，最后，停止SQLS的运行并重建索引将是我们的唯一选择!</p>\n<h1 id=\"填充因子\"><a href=\"#填充因子\" class=\"headerlink\" title=\"填充因子\"></a>填充因子</h1><p>索引的一个特性，定义该索引每页上的可用空间量。FILLFACTOR（填充因子）适应以后表数据的扩展并减小了页拆分的可能性。填充因子是从0到100的百分比数值，设为100时表示将数据页填满。只有当不会对数据进行更改时(例如 只读表中)才用此设置。值越小则数据页上的空闲空间越大，这样可以减少在索引增长过程中进行页分裂的需要，但这一操作需要占用更多的硬盘空间。填充因子指定不当，会降低数据库的读取性能，其降低量与填充因子设置值成反比。</p>\n<h1 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h1><p>SQL SERVER中有多种索引类型。</p>\n<p>按存储结构区分：“聚集索引（又称聚类索引，簇集索引）”，“分聚集索引（非聚类索引，非簇集索引）”</p>\n<p>按数据唯一性区分：“唯一索引”，“非唯一索引”</p>\n<p>按键列个数区分：“单列索引”，“多列索引”。</p>\n<h1 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h1><p>聚集索引是一种对磁盘上实际数据重新组织以按指定的一列或多列值排序。像我们用到的汉语字典，就是一个聚集索引，比如要查“张”，我们自然而然就翻到字典的后面百十页。然后根据字母顺序跟查找出来。这里用到微软的平衡二叉树算法，即首先把书翻到大概二分之一的位置，如果要找的页码比该页的页码小，就把书向前翻到四分之一处，否则，就把书向后翻到四分之三的地方，依此类推，把书页续分成更小的部分，直至正确的页码。</p>\n<p>由于聚集索引是给数据排序，不可能有多种排法，所以一个表只能建立一个聚集索引。科学统计建立这样的索引需要至少相当与该表120%的附加空间，用来存放该表的副本和索引中间页，但是他的性能几乎总是比其它索引要快。</p>\n<p>由于在聚集索引下，数据在物理上是按序排列在数据页上的，重复值也排在一起，因而包含范围检查（bentween,&lt;,&gt;&lt;=,&gt;=）或使用group by 或order by的查询时，一旦找到第一个键值的行，后面都将是连在一起，不必在进一步的搜索，避免啦大范围的扫描，可以大大提高查询速度。</p>\n<h1 id=\"非聚集索引\"><a href=\"#非聚集索引\" class=\"headerlink\" title=\"非聚集索引\"></a>非聚集索引</h1><p>sqlserver默认情况下建立的索引是非聚集索引，他不重新组织表中的数据，而是对每一行存储索引列值并用一个指针指向数据所在的页面。他像汉语字典中的根据‘偏旁部首’查找要找的字，即便对数据不排序，然而他拥有的目录更像是目录，对查取数据的效率也是具有的提升空间，而不需要全表扫描。</p>\n<p>一个表可以拥有多个非聚集索引，每个非聚集索引根据索引列的不同提供不同的排序顺序。</p>\n<h1 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h1><p><strong>语法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE [UNIQUE] [CLUSTERED| NONCLUSTERED ]</span><br><span class=\"line\">INDEX index_name ON &#123; table | view &#125; ( column [ ASC | DESC ] [ ,...n ] )</span><br><span class=\"line\">[with[PAD_INDEX][[,]FILLFACTOR&#x3D;fillfactor]</span><br><span class=\"line\">[[,]IGNORE_DUP_KEY]</span><br><span class=\"line\">[[,]DROP_EXISTING]</span><br><span class=\"line\">[[,]STATISTICS_NORECOMPUTE]</span><br><span class=\"line\">[[,]SORT_IN_TEMPDB]</span><br><span class=\"line\">]</span><br><span class=\"line\">[ ON filegroup ]</span><br></pre></td></tr></table></figure>\n<p>CREATE INDEX命令创建索引各参数说明如下：</p>\n<p>UNIQUE：用于指定为表或视图创建唯一索引，即不允许存在索引值相同的两行。</p>\n<p>CLUSTERED：用于指定创建的索引为聚集索引。</p>\n<p>NONCLUSTERED：用于指定创建的索引为非聚集索引。</p>\n<p>index_name：用于指定所创建的索引的名称。</p>\n<p>table：用于指定创建索引的表的名称。</p>\n<p>view：用于指定创建索引的视图的名称。</p>\n<p>ASC|DESC：用于指定具体某个索引列的升序或降序排序方向。</p>\n<p>Column：用于指定被索引的列。</p>\n<p>PAD_INDEX：用于指定索引中间级中每个页（节点）上保持开放的空间。</p>\n<p>FILLFACTOR = fillfactor：用于指定在创建索引时，每个索引页的数据占索引页大小的百分比，fillfactor的值为1到100。</p>\n<p>IGNORE_DUP_KEY：用于控制当往包含于一个唯一聚集索引中的列中插入重复数据时SQL Server所作的反应。</p>\n<p>DROP_EXISTING：用于指定应删除并重新创建已命名的先前存在的聚集索引或者非聚集索引。</p>\n<p>STATISTICS_NORECOMPUTE：用于指定过期的索引统计不会自动重新计算。</p>\n<p>SORT_IN_TEMPDB：用于指定创建索引时的中间排序结果将存储在 tempdb 数据库中。</p>\n<p>ON filegroup：用于指定存放索引的文件组。</p>\n<p><strong>例子：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--表bigdata创建一个名为idx_mobiel的非聚集索引，索引字段为mobiel</span><br><span class=\"line\">create index idx_mobiel</span><br><span class=\"line\">on bigdata(mobiel) </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">--表bigdata创建一个名为idx_id的唯一聚集索引，索引字段为id</span><br><span class=\"line\">--要求成批插入数据时忽略重复值，不重新计算统计信息，填充因子为40</span><br><span class=\"line\">create unique clustered index idx_id</span><br><span class=\"line\">on bigdata(id) </span><br><span class=\"line\">with pad_index,</span><br><span class=\"line\">fillfactor&#x3D;40,</span><br><span class=\"line\">ignore_dup_key,</span><br><span class=\"line\">statistics_norecompute</span><br></pre></td></tr></table></figure>\n<h1 id=\"管理索引\"><a href=\"#管理索引\" class=\"headerlink\" title=\"管理索引\"></a>管理索引</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exec sp_helpindex BigData   --查看索引定义</span><br><span class=\"line\"></span><br><span class=\"line\">Exec sp_rename &#39;BigData.idx_mobiel&#39;,&#39;idx_big_mobiel&#39;  --将索引名由&#39;idx_mobiel&#39; 改为&#39;idx_big_mobiel&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">drop index BigData.idx_big_mobiel  --删除bigdata表中的idx_big_mobiel索引</span><br><span class=\"line\"></span><br><span class=\"line\">dbcc showcontig(bigdata,idx_mobiel) --检查bigdata表中索引idx_mobiel的碎片信息</span><br><span class=\"line\"></span><br><span class=\"line\">dbcc indexdefrag(Test,bigdata,idx_mobiel)  --整理test数据库中bigdata表的索引idx_mobiel上的碎片</span><br><span class=\"line\"></span><br><span class=\"line\">update statistics bigdata  --更新bigdata表中的全部索引的统计信息</span><br></pre></td></tr></table></figure>\n<h1 id=\"索引的设计原则\"><a href=\"#索引的设计原则\" class=\"headerlink\" title=\"索引的设计原则\"></a>索引的设计原则</h1><p>对于一张表来说索引的有无和建立什么样的索引，要取决与where字句和Join表达式中。</p>\n<p>一般来说建立索引的原则包括以下内容：</p>\n<ul>\n<li>系统一般会给逐渐字段自动建立聚集索引。</li>\n<li>有大量重复值且经常有范围查询和排序、分组的列，或者经常频繁访问的列，考虑建立聚集索引。</li>\n<li>在一个经常做插入操作的表中建立索引，应使用fillfactor(填充因子)来减少页分裂，同时提高并发度降低死锁的发生。如果在表为只读表，填充因子可设为100.</li>\n<li>在选择索引键时，尽可能采用小数据类型的列作为键以使每个索引页能容纳尽可能多的索引键和指针，通过这种方式，可使一个查询必需遍历的索引页面降低到最小，此外，尽可能的使用整数做为键值，因为整数的访问速度最快。</li>\n</ul>\n<h1 id=\"sql-server如何给列添加索引听语音\"><a href=\"#sql-server如何给列添加索引听语音\" class=\"headerlink\" title=\"sql server如何给列添加索引听语音\"></a>sql server如何给列添加索引听语音</h1><p>sql server中用索引可以加快检索速度，那么如何给列添加索引呢？下面小编给大家分享一下。</p>\n<h2 id=\"方法-步骤\"><a href=\"#方法-步骤\" class=\"headerlink\" title=\"方法/步骤\"></a>方法/步骤</h2><ol>\n<li><p>首先右键选择数据表，点击设计，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=1\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/b58f8c5494eef01fe3d38355eefe9925bd317d5f.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着右键要设置的字段，选择索引，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=2\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/4b90f603738da97773341cbbbe51f8198618e303.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>然后点击左下角的添加按钮，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=3\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/8718367adab44aed7c552474bd1c8701a18bfb03.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接下来点击列后面的三个点，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=4\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/9345d688d43f8794b7efd2bedc1b0ef41bd53a09.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着在下拉框中选择列就可以了，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=5\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/54fbb2fb43166d2234598f04482309f79052d270.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>接着在右侧选择升序还是降序，如下图所示</p>\n<p><a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=6\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/21a4462309f790521831ddae02f3d7ca7bcbd570.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n</li>\n<li><p>最后如果不想用索引了就可以选中删除即可，如下图所示</p>\n</li>\n</ol>\n<p>   <a href=\"http://jingyan.baidu.com/album/d8072ac4d8bcedec95cefddc.html?picindex=7\" target=\"_blank\" rel=\"noopener\"><img src=\"../../../../img/索引/0df3d7ca7bcb0a46740c11a96563f6246b60af70.jpg\" alt=\"sql server如何给列添加索引\"></a></p>\n<h1 id=\"SqlServer为字段创建索引\"><a href=\"#SqlServer为字段创建索引\" class=\"headerlink\" title=\"SqlServer为字段创建索引\"></a><a href=\"https://www.cnblogs.com/likui-bookHouse/p/8622410.html\" target=\"_blank\" rel=\"noopener\">SqlServer为字段创建索引</a></h1><p>语法：<br>CREATE [索引类型] INDEX 索引名称<br>ON 表名(列名)</p>\n<p>创建索引实例：</p>\n<p>聚簇索引 create clustered index index_name on table_name (cloumn_name);</p>\n<p>非聚簇索引 create nonclustered index index_name on table_name (cloumn_name);</p>\n<p>唯一索引 create unique index index_name on table_name(cloumn_name);</p>\n<p>删除索引方法：</p>\n<p>　　可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</p>\n<p>　　DROP INDEX index_name ON talbe_name</p>\n<p>　　ALTER TABLE table_name DROP INDEX index_name</p>\n<p>　　ALTER TABLE table_name DROP PRIMARY KEY</p>\n<p>　　其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p>\n<p>　　第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p>\n<p>总结：<br>      1.什么是索引：数据库中的索引是某个表中一列或多列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。<br>  2.分类：<br>     (1) 唯一索引(UNIQUE)：不允许两行具有相同的索引值（创建了唯一约束，系统将自动创建唯一索引）</p>\n<p>　　在表上创建唯一索引。唯一索引是不允许其中任意两行具有相同索引值的索引。</p>\n<p>SQL Server 2005 Compact Edition (SQL Server Compact Edition) 在创建索引后将检查是否存在重复的值（如果数据已存在），并在每次使用 INSERT 或 UPDATE 语句添加数据时执行该检查操作。必须先消除重复值，然后才可对列创建唯一索引。如果存在重复的键值，则将取消 CREATE INDEX 语句并返回错误。只能对定义为 NOT NULL 的列创建唯一索引。</p>\n<p>如果存在唯一索引，则可能生成重复键值的 UPDATE 或 INSERT 语句将回滚，且 SQL Server Compact Edition 返回错误。即使 UPDATE 或 INSERT 语句更改许多行，但只要存在一个重复，上面这一点也将成立。</p>\n<p>​       (2)  主键索引：主键索引要求主键中的每个值是唯一的，（创建主键自动创建主键索引）<br>​       (3)  聚集索引(CLUSTERED)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，表中只能包含一个聚集索引，主键列默认为聚集索引<br>​       (4) 非聚集索引(NONCLUSTERED)：表中各行的物理顺序与键值的逻辑（索引）顺序不匹配，表中可以有249个非聚集索引<br>​    3.创建索引的标准：用语频繁搜索的列；用语对数据进行排序的列<br>注意：如果表中仅有几行，或列中只包含几个不同的值，不推荐创建索引，因为SQL Server 在小型表中用索引搜索数据所花的时间比逐行搜索更长。</p>\n<h1 id=\"SQL-SERVER中查询某个表或某个索引是否存在\"><a href=\"#SQL-SERVER中查询某个表或某个索引是否存在\" class=\"headerlink\" title=\"SQL SERVER中查询某个表或某个索引是否存在\"></a><a href=\"https://www.cnblogs.com/accumulater/p/6144697.html\" target=\"_blank\" rel=\"noopener\">SQL SERVER中查询某个表或某个索引是否存在</a></h1><p><strong>查询某个表是否存在：</strong></p>\n<p>在实际应用中可能需要删除某个表，在删除之前最好先判断一下此表是否存在，以防止返回错误信息。在SQL SERVER中可通过以下语句实现：</p>\n<p>IF OBJECT_ID(N’表名称’, N’U’) IS NOT NULL </p>\n<p>DROP TABLE 表名称;</p>\n<p>注意，普通表和临时表的使用差别：</p>\n<p>若希望删除TEST库中的dbo.TestTable表，直接将dbo.TestTable作为表名即可。</p>\n<p>若希望删除临时表dbo.#temp_table，需要以tempdb.dbo.#temp_table作为表名。</p>\n<p><strong>查询表上的某个索引是否存在：</strong></p>\n<p>通常情况下，为了提高数据的查询效率，我们会为表的特定字段创建索引，同一个表上的索引名称是不同的。那么如何判断某个表是否已经存在特定名称的索引了呢？可通过下面的语句判断：</p>\n<p>SELECT 1 FROM sys.indexes WHERE object_id=OBJECT_ID(@tname, N’U’) and NAME=@iname</p>\n<p>其中：@tname表示建索引的表名，@iname表示索引名。</p>\n<p><strong>扩展知识</strong></p>\n<p>在每一个数据库中都有sys.sysobjects用于包括在数据库中创建的每个对象（例如约束、默认值、日志、规则以及存储过程）。详细的说明信息参看MSDN上的帮助文档：sys.sysobjects</p>\n<p>OBJECT_ID的作用是返回架构范围内对象的数据库对象标识号。如果找不到数据库或对象的名称，例如相应名称不存在或拼写不正确，则会返回NULL。详细的说明信息参看MSDN上的帮助文档：object_id</p>\n<p>sys.indexes用于保存每个表格对象（例如，表、视图或表值函数）的索引或堆，详细的说明信息参看MSDN上的帮助文档：sys.indexes</p>\n","next":{"title":"SQLSERVER数据库常用查询","path":"api/articles/resource-DB-SQLServer-常用查询.json","image":"/img/header_img/DB/Commonquery.png","num_read":216,"num_like":999,"num_collection":574,"num_comments":34},"prev":{"title":"SQLSERVER数据库表锁","path":"api/articles/resource-DB-SQLServer-数据库表锁.json","image":"/img/header_img/DB/tablelock.png","num_read":846,"num_like":245,"num_collection":103,"num_comments":86},"categories":[{"name":"数据库","path":"api/categories/数据库.json","pathContent":"api/categories/数据库","description":"结构化存储格式+事务和并发控制+内存管理+SQL访问接口","cover":"https://sunfy9.gitee.io/project/photo/project/db.jpg"}],"tags":[{"name":"sqlServer","path":"api/tags/sqlServer.json","pathContent":"api/tags/sqlServer","description":"[sqlServer]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}