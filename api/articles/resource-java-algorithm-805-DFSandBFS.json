{"title":"算法常用的解题思路---深度优先(DFS)和广度优先(BFS)","num_read":939,"num_like":882,"num_collection":703,"num_comments":218,"slug":"resource-java-algorithm-805-DFSandBFS","date":"2021-08-01T16:00:00.000Z","img":"/img/header_img/interview/DFSandBFS.gif","_id":"clhrbp2df007po5lghl0a5nnr","project":"algorithm","site":{"data":{}},"updated":"2022-10-28T08:30:21.934Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-algorithm-805-DFSandBFS.json","webPath":"2021/08/02/resource-java-algorithm-805-DFSandBFS/","permalink":"https://sunfy9.gitee.io/2021/08/02/resource-java-algorithm-805-DFSandBFS/","excerpt":null,"covers":["../../../../img/805-DFSandBFS/e1e6a44251b69cd3b930f3071a71ffd8.gif","../../../../img/805-DFSandBFS/29dc30c1546cc73846153359b0fad8fb.gif","../../../../img/805-DFSandBFS/a2c7c61edcadffeed85c10f53f1c988c.gif","../../../../img/805-DFSandBFS/image-20210802113838013.png","../../../../img/805-DFSandBFS/image-20210803170521884.png","../../../../img/805-DFSandBFS/image-20210803170948867.png","../../../../img/805-DFSandBFS/image-20210803171005454.png","../../../../img/805-DFSandBFS/image-20210803171349312.png","../../../../img/805-DFSandBFS/image-20210803171509072.png","../../../../img/805-DFSandBFS/image-20210803171521571.png","../../../../img/805-DFSandBFS/image-20210803171559123.png","../../../../img/805-DFSandBFS/image-20210803172012460.png","../../../../img/805-DFSandBFS/image-20210803172049764.png","../../../../img/805-DFSandBFS/image-20210803172302735.png","../../../../img/805-DFSandBFS/image-20210803172318899.png","../../../../img/805-DFSandBFS/image-20210803172339057.png","../../../../img/805-DFSandBFS/image-20210803172402962.png","../../../../img/805-DFSandBFS/image-20210803172422525.png","../../../../img/805-DFSandBFS/image-20210803172446051.png","../../../../img/805-DFSandBFS/image-20210803172525093.png","../../../../img/805-DFSandBFS/image-20210803172552521.png","../../../../img/805-DFSandBFS/image-20210803172607369.png","../../../../img/805-DFSandBFS/image-20210803172635206.png","../../../../img/805-DFSandBFS/image-20210803172651242.png","../../../../img/805-DFSandBFS/image-20210803172724760.png","../../../../img/805-DFSandBFS/image-20210803172929827.png","../../../../img/805-DFSandBFS/image-20210803173207123.png","../../../../img/805-DFSandBFS/image-20210803173125322.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"什么是深度优先搜索-DFS-和广度优先搜索-BFS\"><a href=\"#什么是深度优先搜索-DFS-和广度优先搜索-BFS\" class=\"headerlink\" title=\"什么是深度优先搜索(DFS)和广度优先搜索(BFS)\"></a>什么是深度优先搜索(DFS)和广度优先搜索(BFS)</h1><p>图的搜索有两种方式，一种是深度优先搜索（Depth-First-Search），另一种是广度优先搜索（Breadth-First-Search）。</p>\n<blockquote>\n<p>深度优先搜索（DFS）<br>  深度优先搜索是先序遍历的推广，深度优先搜索的非递归实现使用了一个栈。 </p>\n<p>广度优先搜索（BFS）<br>  广度优先搜索是按层来处理顶点，距离开始点最近的那些顶点首先被访问，而最远的那些顶点则最后被访问，这个和树的层序变量很像，BFS的代码使用了一个队列。</p>\n</blockquote>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a><strong>深度优先搜索</strong></h2><p>主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。</p>\n<p><strong>树是图的一种特例(连通无环的图就是树)</strong>，这就是树的前序遍历,实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p>\n<blockquote>\n<p>遍历二叉树的过程中，一般先遍历左子树，再遍历右子树。在先左后右的原则下，二叉树的遍历分三种</p>\n<p>前序遍历：根节点+左子树+右子树。<strong><em>在遍历左子树和右子树时，仍然先访问根节点，然后遍历左子树，最后遍历右子树。</em></strong></p>\n<p>中序遍历：左子树+根节点+右子树。<strong>在遍历左右子树时，仍然先遍历左子树，再遍历根节点，后遍历右子树。</strong></p>\n<p>后序遍历：左子树+右子树+根节点。<strong>在遍历左右子树时，仍然先遍历左子树，在遍历右子树，后访问根节点。</strong></p>\n</blockquote>\n<h3 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a><strong>递归实现</strong></h3><p>递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点(递归终止条件)，代码如下：<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 节点值 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 左节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node left; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 右节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node right; </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value, Node left, Node right)</span> </span>&#123; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.left = left; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.right = right; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(Node treeNode)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 遍历节点 </span></span><br><span class=\"line\">        process(treeNode) </span><br><span class=\"line\">        <span class=\"comment\">// 遍历左节点 </span></span><br><span class=\"line\">        dfs(treeNode.left); </span><br><span class=\"line\">        <span class=\"comment\">// 遍历右节点 </span></span><br><span class=\"line\">        dfs(treeNode.right); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。所以我们重点看下非递归实现。</p>\n<h3 id=\"非递归实现\"><a href=\"#非递归实现\" class=\"headerlink\" title=\"非递归实现\"></a><strong>非递归实现</strong></h3><p>仔细观察深度优先遍历的特点，对二叉树来说，由于是先序遍历(先遍历当前节点，再遍历左节点，再遍历右节点)，所以我们有如下思路：</p>\n<p>对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点(这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求)。</p>\n<p>弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。</p>\n<p>我们以以下二叉树为例来看下如何用栈来实现 DFS。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/e1e6a44251b69cd3b930f3071a71ffd8.gif\" alt=\"e1e6a44251b69cd3b930f3071a71ffd8\"></p>\n<p>整体思路还是比较清晰的，使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断回溯(出栈)，有了思路，不难写出如下用栈实现的二叉树的深度优先遍历代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈来实现 dfs </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfsWithStack</span><span class=\"params\">(Node root)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    Stack&lt;Node&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;(); </span><br><span class=\"line\">    <span class=\"comment\">// 先把根节点压栈 </span></span><br><span class=\"line\">    stack.push(root); </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123; </span><br><span class=\"line\">        Node treeNode = stack.pop(); </span><br><span class=\"line\">        <span class=\"comment\">// 遍历节点 </span></span><br><span class=\"line\">        process(treeNode) </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 先压右节点 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode.right != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.push(treeNode.right); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 再压左节点 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode.left != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.push(treeNode.left); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到用栈实现深度优先遍历其实代码也不复杂，而且也不用担心递归那样层级过深导致的栈溢出问题。</p>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a><strong>广度优先搜索</strong></h2><p>广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p>\n<p>上文所述树的广度优先遍历动图如下，每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历，先遍历第一层(节点 1)，再遍历第二层(节点 2，3，4)，第三层(5，6，7，8)，第四层(9，10)。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/29dc30c1546cc73846153359b0fad8fb.gif\" alt=\"29dc30c1546cc73846153359b0fad8fb\"></p>\n<p>深度优先遍历用的是栈，而广度优先遍历要用队列来实现，我们以下图二叉树为例来看看如何用队列来实现广度优先遍历。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/a2c7c61edcadffeed85c10f53f1c988c.gif\" alt=\"a2c7c61edcadffeed85c10f53f1c988c\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用队列实现 bfs </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(Node root)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    Queue&lt;Node&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;(); </span><br><span class=\"line\">    stack.add(root); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123; </span><br><span class=\"line\">        Node node = stack.poll(); </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"value = \"</span> + node.value); </span><br><span class=\"line\">        Node left = node.left; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.add(left); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        Node right = node.right; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.add(right); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>DFS，BFS 在搜索引擎中的应用我们几乎每天都在 <code>Google</code>, <code>Baidu</code> 这些搜索引擎，那大家知道这些搜索引擎是怎么工作的吗，简单来说有三步：</p>\n<h3 id=\"网页抓取\"><a href=\"#网页抓取\" class=\"headerlink\" title=\"网页抓取\"></a><strong>网页抓取</strong></h3><p>搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中</p>\n<h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a><strong>预处理</strong></h3><p>索引程序对抓取来的页面数据进行文字提取，中文分词，(倒排)索引等处理，以备排名程序使用</p>\n<h3 id=\"排名\"><a href=\"#排名\" class=\"headerlink\" title=\"排名\"></a><strong>排名</strong></h3><p>用户输入关键词后，排名程序调用索引数据库数据，计算相关性，然后按一定格式生成搜索结果页面。</p>\n<p>我们重点看下第一步，网页抓取。</p>\n<p>这一步的大致操作如下：给爬虫分配一组起始的网页，我们知道网页里其实也包含了很多超链接，爬虫爬取一个网页后，解析提取出这个网页里的所有超链接，再依次爬取出这些超链接，再提取网页超链接。。。，如此不断重复就能不断根据超链接提取网页。如下图示：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210802113838013.png\" alt=\"image-20210802113838013\"></p>\n<p>如上所示，最终构成了一张图，于是问题就转化为了如何遍历这张图，显然可以用深度优先或广度优先的方式来遍历。</p>\n<p>如果是广度优先遍历，先依次爬取第一层的起始网页，再依次爬取每个网页里的超链接，如果是深度优先遍历，先爬取起始网页 1，再爬取此网页里的链接…，爬取完之后，再爬取起始网页 2…</p>\n<p>实际上爬虫是深度优先与广度优先两种策略一起用的，比如在起始网页里，有些网页比较重要(权重较高)，那就先对这个网页做深度优先遍历，遍历完之后再对其他(权重一样的)起始网页做广度优先遍历。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>DFS 和 BFS 是非常重要的两种算法，大家一定要掌握，本文为了方便讲解，只对树做了 DFS，BFS，大家可以试试如果用图的话该怎么写代码，原理其实也是一样，只不过图和树两者的表示形式不同而已，DFS 一般是解决连通性问题，而 BFS 一般是解决最短路径问题!</p>\n<hr>\n<h1 id=\"733-图像渲染\"><a href=\"#733-图像渲染\" class=\"headerlink\" title=\"733. 图像渲染\"></a><a href=\"https://leetcode-cn.com/problems/flood-fill/\" target=\"_blank\" rel=\"noopener\">733. 图像渲染</a></h1><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>\n<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>\n<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>\n<p>最后返回经过上色渲染后的图像。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入: </span><br><span class=\"line\"><span class=\"attr\">image</span> = [[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"attr\">sr</span> = <span class=\"number\">1</span>, sc = <span class=\"number\">1</span>, newColor = <span class=\"number\">2</span></span><br><span class=\"line\">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class=\"line\">解析: </span><br><span class=\"line\">在图像的正中间，(坐标(sr,sc)=(1,1)),</span><br><span class=\"line\">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class=\"line\">注意，右下角的像素没有更改为2，</span><br><span class=\"line\">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= nums.length &lt;= 104</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 已按 非递减顺序 排序</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li>\n<li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li>\n<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本题要求将给定的二维数组中指定的「色块」染成另一种颜色。「色块」的定义是：直接或间接相邻的同色方格构成的整体。</p>\n<p>可以发现，「色块」就是被不同颜色的方格包围的一个同色岛屿。我们从色块中任意一个地方开始，利用广度优先搜索或深度优先搜索即可遍历整个岛屿。</p>\n<p>注意：当目标颜色和初始颜色相同时，我们无需对原数组进行修改。</p>\n<h2 id=\"方法一：广度优先搜索\"><a href=\"#方法一：广度优先搜索\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路及算法</p>\n<p>我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。</p>\n<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] floodFill(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> sr, <span class=\"keyword\">int</span> sc, <span class=\"keyword\">int</span> newColor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currColor = image[sr][sc];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currColor == newColor) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = image.length, m = image[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">        queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;sr, sc&#125;);</span><br><span class=\"line\">        image[sr][sc] = newColor;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &gt;= <span class=\"number\">0</span> &amp;&amp; mx &lt; n &amp;&amp; my &gt;= <span class=\"number\">0</span> &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;mx, my&#125;);</span><br><span class=\"line\">                    image[mx][my] = newColor;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。</li>\n<li>空间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。主要为队列的开销。</li>\n</ul>\n<h2 id=\"方法二：深度优先搜索\"><a href=\"#方法二：深度优先搜索\" class=\"headerlink\" title=\"方法二：深度优先搜索\"></a>方法二：深度优先搜索</h2><p>思路与算法</p>\n<p>我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p>\n<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] floodFill(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> sr, <span class=\"keyword\">int</span> sc, <span class=\"keyword\">int</span> newColor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currColor = image[sr][sc];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currColor != newColor) &#123;</span><br><span class=\"line\">            dfs(image, sr, sc, currColor, newColor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> color, <span class=\"keyword\">int</span> newColor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image[x][y] == color) &#123;</span><br><span class=\"line\">            image[x][y] = newColor;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &gt;= <span class=\"number\">0</span> &amp;&amp; mx &lt; image.length &amp;&amp; my &gt;= <span class=\"number\">0</span> &amp;&amp; my &lt; image[<span class=\"number\">0</span>].length) &#123;</span><br><span class=\"line\">                    dfs(image, mx, my, color, newColor);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。</li>\n<li>空间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。主要为栈空间的开销。</li>\n</ul>\n<h1 id=\"695-岛屿的最大面积\"><a href=\"#695-岛屿的最大面积\" class=\"headerlink\" title=\"695. 岛屿的最大面积\"></a><a href=\"https://leetcode-cn.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">695. 岛屿的最大面积</a></h1><p>给定一个包含了一些 0 和 1 的非空二维数组 <code>grid</code>。</p>\n<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>\n<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class=\"line\"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class=\"line\"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class=\"line\"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class=\"line\"> <span class=\"section\">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"><span class=\"section\">[[0,0,0,0,0,0,0,0]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">对于上面这个给定的矩阵, 返回 0。</span><br><span class=\"line\"></span><br><span class=\"line\">注意: 给定的矩阵grid 的长度和宽度都不超过 50。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：深度优先搜索\"><a href=\"#方法一：深度优先搜索\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p>算法</p>\n<p>我们想知道网格中每个连通形状的面积，然后取最大值。</p>\n<p>如果我们在一个土地上，以 44 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</p>\n<p>为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 00。这样我们就不会多次访问同一土地。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                ans = Math.max(ans, dfs(grid, i, j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid, <span class=\"keyword\">int</span> cur_i, <span class=\"keyword\">int</span> cur_j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">            ans += dfs(grid, next_i, next_j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 <code>R</code> 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，递归的深度最大可能是整个网格的大小，因此最大可能使用 <code>O(R×C)</code> 的栈空间。</li>\n</ul>\n<h2 id=\"方法二：深度优先搜索-栈\"><a href=\"#方法二：深度优先搜索-栈\" class=\"headerlink\" title=\"方法二：深度优先搜索 + 栈\"></a>方法二：深度优先搜索 + 栈</h2><p>算法</p>\n<p>我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：</p>\n<p>方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。</p>\n<p>访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中；</p>\n<p>另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">                Deque&lt;Integer&gt; stacki = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                Deque&lt;Integer&gt; stackj = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                stacki.push(i);</span><br><span class=\"line\">                stackj.push(j);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stacki.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> cur_i = stacki.pop(), cur_j = stackj.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    ++cur;</span><br><span class=\"line\">                    grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">                        stacki.push(next_i);</span><br><span class=\"line\">                        stackj.push(next_j);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = Math.max(ans, cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 RR 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，栈中最多会存放所有的土地，土地的数量最多为 <code>R×C</code> 块，因此使用的空间为 <code>O(R×C)</code>。</li>\n</ul>\n<h2 id=\"方法三：广度优先搜索\"><a href=\"#方法三：广度优先搜索\" class=\"headerlink\" title=\"方法三：广度优先搜索\"></a>方法三：广度优先搜索</h2><p><strong>算法</strong></p>\n<p>我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">                Queue&lt;Integer&gt; queuei = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                Queue&lt;Integer&gt; queuej = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                queuei.offer(i);</span><br><span class=\"line\">                queuej.offer(j);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!queuei.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> cur_i = queuei.poll(), cur_j = queuej.poll();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    ++cur;</span><br><span class=\"line\">                    grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">                        queuei.offer(next_i);</span><br><span class=\"line\">                        queuej.offer(next_j);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = Math.max(ans, cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 <code>R</code> 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，队列中最多会存放所有的土地，土地的数量最多为 <code>R×C</code> 块，因此使用的空间为 <code>O(R×C)</code>。</li>\n</ul>\n<h1 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\" target=\"_blank\" rel=\"noopener\">617. 合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>\n<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: </span><br><span class=\"line\">\tTree 1                     Tree 2                  </span><br><span class=\"line\">          1                         2                             </span><br><span class=\"line\">         / \\                       / \\                            </span><br><span class=\"line\">        3   2                     1   3                        </span><br><span class=\"line\">       /                           \\   \\                      </span><br><span class=\"line\">      5                             4   7                  </span><br><span class=\"line\">输出: </span><br><span class=\"line\">合并后的树:</span><br><span class=\"line\">\t     3</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   4   5</span><br><span class=\"line\">\t  / \\   \\ </span><br><span class=\"line\">\t 5   4   7</span><br><span class=\"line\"></span><br><span class=\"line\">注意: 合并必须从两个树的根节点开始。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：深度优先搜索-1\"><a href=\"#方法一：深度优先搜索-1\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>\n<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>\n<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>\n<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>\n<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>\n<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode merged = <span class=\"keyword\">new</span> TreeNode(t1.val + t2.val);</span><br><span class=\"line\">        merged.left = mergeTrees(t1.left, t2.left);</span><br><span class=\"line\">        merged.right = mergeTrees(t1.right, t2.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>\n<li>空间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>\n</ul>\n<h2 id=\"方法二：广度优先搜索\"><a href=\"#方法二：广度优先搜索\" class=\"headerlink\" title=\"方法二：广度优先搜索\"></a>方法二：广度优先搜索</h2><p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p>\n<p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p>\n<p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p>\n<p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p>\n<p>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</p>\n<p>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</p>\n<p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode merged = <span class=\"keyword\">new</span> TreeNode(t1.val + t2.val);</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue1 = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue2 = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(merged);</span><br><span class=\"line\">        queue1.offer(t1);</span><br><span class=\"line\">        queue2.offer(t2);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class=\"line\">            TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span> || left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span> &amp;&amp; left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    TreeNode left = <span class=\"keyword\">new</span> TreeNode(left1.val + left2.val);</span><br><span class=\"line\">                    node.left = left;</span><br><span class=\"line\">                    queue.offer(left);</span><br><span class=\"line\">                    queue1.offer(left1);</span><br><span class=\"line\">                    queue2.offer(left2);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.left = left1;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.left = left2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span> || right2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span> &amp;&amp; right2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    TreeNode right = <span class=\"keyword\">new</span> TreeNode(right1.val + right2.val);</span><br><span class=\"line\">                    node.right = right;</span><br><span class=\"line\">                    queue.offer(right);</span><br><span class=\"line\">                    queue1.offer(right1);</span><br><span class=\"line\">                    queue2.offer(right2);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.right = right1;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    node.right = right2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>\n<li>空间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。</li>\n</ul>\n<h1 id=\"116-填充每个节点的下一个右侧节点指针\"><a href=\"#116-填充每个节点的下一个右侧节点指针\" class=\"headerlink\" title=\"116. 填充每个节点的下一个右侧节点指针\"></a><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">116. 填充每个节点的下一个右侧节点指针</a></h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p>进阶：</p>\n<ul>\n<li>你只能使用常量级额外空间。</li>\n<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>\n</ul>\n<p>实例：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803170521884.png\" alt=\"image-20210803170521884\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3,4,5,6,7]</span><br><span class=\"line\">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class=\"line\">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数量少于 <code>4096</code></li>\n<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"方法一：层次遍历\"><a href=\"#方法一：层次遍历\" class=\"headerlink\" title=\"方法一：层次遍历\"></a>方法一：层次遍历</h2><p>思路与算法</p>\n<p>题目本身希望我们将二叉树的每一层节点都连接起来形成一个链表。因此直观的做法我们可以对二叉树进行层次遍历，在层次遍历的过程中将我们将二叉树每一层的节点拿出来遍历并连接。</p>\n<p>层次遍历基于广度优先搜索，它与广度优先搜索的不同之处在于，广度优先搜索每次只会取出一个节点来拓展，而层次遍历会每次将队列中的所有元素都拿出来拓展，这样能保证每次从队列中拿出来遍历的元素都是属于同一层的，因此我们可以在遍历的过程中修改每个节点的 \\text{next}next 指针，同时拓展下一层的新队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始化队列同时将第一层节点加入队列中，即根节点</span></span><br><span class=\"line\">        Queue&lt;Node&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;Node&gt;(); </span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 外层的 while 循环迭代的是层数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 记录当前队列大小</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 遍历这一层的所有节点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 从队首取出元素</span></span><br><span class=\"line\">                Node node = queue.poll();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; size - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    node.next = queue.peek();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 拓展下一层节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 <code>next</code> 指针。</li>\n<li>空间复杂度：<code>O(N)</code>。这是一棵完美二叉树，它的最后一个层级包含 <code>N/2</code> 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 <code>O(N)</code>。</li>\n</ul>\n<h2 id=\"方法二：使用已建立的-next-指针\"><a href=\"#方法二：使用已建立的-next-指针\" class=\"headerlink\" title=\"方法二：使用已建立的 next 指针\"></a>方法二：使用已建立的 <code>next</code> 指针</h2><p>思路</p>\n<p>一棵树中，存在两种类型的 <code>next</code> 指针。</p>\n<p>第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.left.next</span> = node.right</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803170948867.png\" alt=\"image-20210803170948867\"></p>\n<p>第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171005454.png\" alt=\"image-20210803171005454\"></p>\n<p>如果每个节点有指向父节点的指针，可以通过该指针找到 \\text{next}next 节点。如果不存在该指针，则按照下面思路建立连接：</p>\n<blockquote>\n<p>第 <code>N</code> 层节点之间建立 <code>next</code> 指针后，再建立第 <code>N+1</code> 层节点的 <code>next</code> 指针。可以通过 <code>next</code> 指针访问同一层的所有节点，因此可以使用第 <code>N</code> 层的 <code>next</code> 指针，为第 <code>N+1</code> 层节点建立 <code>next</code> 指针。</p>\n</blockquote>\n<p>算法</p>\n<ul>\n<li>从根节点开始，由于第 <code>0</code> 层只有一个节点，所以不需要连接，直接为第 <code>1</code> 层节点建立<code>next</code> 指针即可。该算法中需要注意的一点是，当我们为第 <code>N</code> 层节点建立 <code>next</code> 指针时，处于第 <code>N-1</code> 层。当第 <code>N</code> 层节点的 <code>next</code> 指针全部建立完成后，移至第 <code>N</code> 层，建立第 <code>N+1</code> 层节点的 <code>next</code> 指针。</li>\n<li>遍历某一层的节点时，这层节点的 <code>next</code> 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。</li>\n</ul>\n<p>上面思路的伪代码如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">leftmost</span> = root</span><br><span class=\"line\">while (leftmost.left != null) &#123;</span><br><span class=\"line\">    head = leftmost</span><br><span class=\"line\">    while (head.next != null) &#123;</span><br><span class=\"line\">        1) Establish Connection 1</span><br><span class=\"line\">        2) Establish Connection 2 using next pointers</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    leftmost = leftmost.left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171349312.png\" alt=\"image-20210803171349312\"></p>\n<p>两种类型的 <code>next</code> 指针。</p>\n<p>第一种情况两个子节点属于同一个父节点，因此直接通过父节点建立两个子节点的 <code>next</code> 指针即可。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.left.next</span> = node.right</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171509072.png\" alt=\"image-20210803171509072\"></p>\n<p>第二种情况是连接不同父节点之间子节点的情况。更具体地说，连接的是第一个父节点的右孩子和第二父节点的左孩子。由于已经在父节点这一层建立了 <code>next</code> 指针，因此可以直接通过第一个父节点的 <code>next</code> 指针找到第二个父节点，然后在它们的孩子之间建立连接。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.right.next</span> = node.next.left</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171521571.png\" alt=\"image-20210803171521571\"></p>\n<p>完成当前层的连接后，进入下一层重复操作，直到所有的节点全部连接。进入下一层后需要更新最左节点，然后从新的最左节点开始遍历该层所有节点。因为是完美二叉树，因此最左节点一定是当前层最左节点的左孩子。如果当前最左节点的左孩子不存在，说明已经到达该树的最后一层，完成了所有节点的连接。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171559123.png\" alt=\"image-20210803171559123\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">        Node leftmost = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (leftmost.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span></span><br><span class=\"line\">            Node head = leftmost;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// CONNECTION 1</span></span><br><span class=\"line\">                head.left.next = head.right;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// CONNECTION 2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (head.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    head.right.next = head.next.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 指针向后移动</span></span><br><span class=\"line\">                head = head.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 去下一层的最左的节点</span></span><br><span class=\"line\">            leftmost = leftmost.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，每个节点只访问一次。</li>\n<li>空间复杂度：<code>O(1)</code>，不需要存储额外的节点。</li>\n</ul>\n<h1 id=\"542-01-矩阵\"><a href=\"#542-01-矩阵\" class=\"headerlink\" title=\"542. 01 矩阵\"></a><a href=\"https://leetcode-cn.com/problems/01-matrix/\" target=\"_blank\" rel=\"noopener\">542. 01 矩阵</a></h1><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p>\n<p>两个相邻元素间的距离为 1 。</p>\n<p>示例 1：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172012460.png\" alt=\"image-20210803172012460\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class=\"line\">输出：[[0,0,0],[0,1,0],[0,0,0]]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172049764.png\" alt=\"image-20210803172049764\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0],[0,1,0],[1,1,1]]</span><br><span class=\"line\">输出：[[0,0,0],[0,1,0],[1,2,1]]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>m == mat.length</li>\n<li>n == mat[i].length</li>\n<li>1 &lt;= m, n &lt;= 104</li>\n<li>1 &lt;= m * n &lt;= 104</li>\n<li>mat[i][j] is either 0 or 1.</li>\n<li>mat 中至少有一个 0 </li>\n</ul>\n<h2 id=\"方法一：广度优先搜索-1\"><a href=\"#方法一：广度优先搜索-1\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172302735.png\" alt=\"image-20210803172302735\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172318899.png\" alt=\"image-20210803172318899\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172339057.png\" alt=\"image-20210803172339057\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172402962.png\" alt=\"image-20210803172402962\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172422525.png\" alt=\"image-20210803172422525\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172446051.png\" alt=\"image-20210803172446051\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] seen = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n];</span><br><span class=\"line\">        Queue&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 将所有的 0 添加进初始队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;);</span><br><span class=\"line\">                    seen[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 广度优先搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cell[<span class=\"number\">0</span>], j = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; ++d) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ni = i + dirs[d][<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nj = j + dirs[d][<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ni &gt;= <span class=\"number\">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class=\"number\">0</span> &amp;&amp; nj &lt; n &amp;&amp; !seen[ni][nj]) &#123;</span><br><span class=\"line\">                    dist[ni][nj] = dist[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;ni, nj&#125;);</span><br><span class=\"line\">                    seen[ni][nj] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172525093.png\" alt=\"image-20210803172525093\"></p>\n<h2 id=\"方法二：动态规划\"><a href=\"#方法二：动态规划\" class=\"headerlink\" title=\"方法二：动态规划\"></a>方法二：动态规划</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172552521.png\" alt=\"image-20210803172552521\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172607369.png\" alt=\"image-20210803172607369\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172635206.png\" alt=\"image-20210803172635206\"></p>\n<h2 id=\"方法三：动态规划的常数优化\"><a href=\"#方法三：动态规划的常数优化\" class=\"headerlink\" title=\"方法三：动态规划的常数优化\"></a>方法三：动态规划的常数优化</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172651242.png\" alt=\"image-20210803172651242\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172724760.png\" alt=\"image-20210803172724760\"></p>\n<h1 id=\"994-腐烂的橘子\"><a href=\"#994-腐烂的橘子\" class=\"headerlink\" title=\"994. 腐烂的橘子\"></a><a href=\"https://leetcode-cn.com/problems/rotting-oranges/\" target=\"_blank\" rel=\"noopener\">994. 腐烂的橘子</a></h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>\n<ul>\n<li><p>值 0 代表空单元格；</p>\n</li>\n<li><p>值 1 代表新鲜橘子；</p>\n</li>\n<li><p>值 2 代表腐烂的橘子。</p>\n</li>\n</ul>\n<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>\n<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>\n<p>实例1：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172929827.png\" alt=\"image-20210803172929827\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：[[0,2]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= grid.length &lt;= 10</span><br><span class=\"line\">1 &lt;= grid[0].length &lt;= 10</span><br><span class=\"line\">grid[i][j] 仅为 0、1 或 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由题目我们可以知道每分钟每个腐烂的橘子都会使上下左右相邻的新鲜橘子腐烂，这其实是一个模拟广度优先搜索的过程。所谓广度优先搜索，就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，最后广度优先搜索找到的路径就是从起点开始的最短合法路径。</p>\n<p>回到题目中，假设图中只有一个腐烂的橘子，它每分钟向外拓展，腐烂上下左右相邻的新鲜橘子，那么下一分钟，就是这些被腐烂的橘子再向外拓展腐烂相邻的新鲜橘子，这与广度优先搜索的过程均一一对应，上下左右相邻的新鲜橘子就是该腐烂橘子尝试访问的同一层的节点，路径长度就是新鲜橘子被腐烂的时间。我们记录下每个新鲜橘子被腐烂的时间，最后如果单元格中没有新鲜橘子，腐烂所有新鲜橘子所必须经过的最小分钟数就是新鲜橘子被腐烂的时间的最大值。</p>\n<p>以上是基于图中只有一个腐烂的橘子的情况，可实际题目中腐烂的橘子数不止一个，看似与广度优先搜索有所区别，不能直接套用，但其实有两个方向的思路。</p>\n<p>一个是耗时比较大且不推荐的做法：我们对每个腐烂橘子为起点都进行一次广度优先搜索，用 <img src=\"../../../../img/805-DFSandBFS/image-20210803173207123.png\" alt=\"image-20210803173207123\">表示只考虑第 ii 个腐烂橘子为起点的广度优先搜索，坐标位于 (x, y)(x,y) 的新鲜橘子被腐烂的时间，设没有被腐烂的新鲜橘子的 <img src=\"../../../../img/805-DFSandBFS/image-20210803173230434.png\" alt=\"image-20210803173230434\"> ，即无限大，表示没有被腐烂，那么每个新鲜橘子被腐烂的最短时间即为</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803173125322.png\" alt=\"image-20210803173125322\"></p>\n<p>最后的答案就是所有新鲜橘子被腐烂的最短时间的最大值，如果是无限大，说明有新鲜橘子没有被腐烂，输出 <code>-1</code> 即可。</p>\n<p>无疑上面的方法需要枚举每个腐烂橘子，所以时间复杂度需要在原先广度优先搜索遍历的时间复杂度上再乘以腐烂橘子数，这在整个网格范围变大的时候十分耗时，所以需要另寻他路。</p>\n<h2 id=\"方法一：多源广度优先搜索\"><a href=\"#方法一：多源广度优先搜索\" class=\"headerlink\" title=\"方法一：多源广度优先搜索\"></a>方法一：多源广度优先搜索</h2><p>思路</p>\n<p>观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。</p>\n<p>假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(我们令其为超级源点)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 <code>−1</code> ，那么按照广度优先搜索的算法，下一分钟也就是第 <code>0</code> 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 <code>dis[x][y]</code> 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</p>\n<p>为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 <code>cnt</code> 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 <code>cnt-=1</code> ，最后搜索结束时如果<code>cnt</code> 大于 <code>0</code> ，说明有新鲜橘子没被腐烂，返回 <code>-1</code> ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 <code>1</code> 改为 <code>2</code>，最后看网格中是否由值为 <code>1</code> 即新鲜的橘子即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dc = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">orangesRotting</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> R = grid.length, C = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; depth = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>; r &lt; R; ++r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; C; ++c) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[r][c] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> code = r * C + c;</span><br><span class=\"line\">                    queue.add(code);</span><br><span class=\"line\">                    depth.put(code, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> code = queue.remove();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = code / C, c = code % C;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nr = r + dr[k];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nc = c + dc[k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class=\"number\">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    grid[nr][nc] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ncode = nr * C + nc;</span><br><span class=\"line\">                    queue.add(ncode);</span><br><span class=\"line\">                    depth.put(ncode, depth.get(code) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    ans = depth.get(ncode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] row: grid) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v: row) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(nm)</code><br>即进行一次广度优先搜索的时间，其中 <code>n=grid.length</code>, <code>m=grid[0].length</code> 。</li>\n<li>空间复杂度：<code>O(nm)</code><br>需要额外的 <code>dis</code> 数组记录每个新鲜橘子被腐烂的最短时间，大小为 <code>O(nm)</code>，且广度优先搜索中队列里存放的状态最多不会超过 <code>nm</code> 个，最多需要<code>O(nm)</code> 的空间，所以最后的空间复杂度为 <code>O(nm)</code>。</li>\n</ul>\n","more":"<h1 id=\"什么是深度优先搜索-DFS-和广度优先搜索-BFS\"><a href=\"#什么是深度优先搜索-DFS-和广度优先搜索-BFS\" class=\"headerlink\" title=\"什么是深度优先搜索(DFS)和广度优先搜索(BFS)\"></a>什么是深度优先搜索(DFS)和广度优先搜索(BFS)</h1><p>图的搜索有两种方式，一种是深度优先搜索（Depth-First-Search），另一种是广度优先搜索（Breadth-First-Search）。</p>\n<blockquote>\n<p>深度优先搜索（DFS）<br>  深度优先搜索是先序遍历的推广，深度优先搜索的非递归实现使用了一个栈。 </p>\n<p>广度优先搜索（BFS）<br>  广度优先搜索是按层来处理顶点，距离开始点最近的那些顶点首先被访问，而最远的那些顶点则最后被访问，这个和树的层序变量很像，BFS的代码使用了一个队列。</p>\n</blockquote>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a><strong>深度优先搜索</strong></h2><p>主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。</p>\n<p><strong>树是图的一种特例(连通无环的图就是树)</strong>，这就是树的前序遍历,实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p>\n<blockquote>\n<p>遍历二叉树的过程中，一般先遍历左子树，再遍历右子树。在先左后右的原则下，二叉树的遍历分三种</p>\n<p>前序遍历：根节点+左子树+右子树。<strong><em>在遍历左子树和右子树时，仍然先访问根节点，然后遍历左子树，最后遍历右子树。</em></strong></p>\n<p>中序遍历：左子树+根节点+右子树。<strong>在遍历左右子树时，仍然先遍历左子树，再遍历根节点，后遍历右子树。</strong></p>\n<p>后序遍历：左子树+右子树+根节点。<strong>在遍历左右子树时，仍然先遍历左子树，在遍历右子树，后访问根节点。</strong></p>\n</blockquote>\n<h3 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a><strong>递归实现</strong></h3><p>递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点(递归终止条件)，代码如下：<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 节点值 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 左节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node left; </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * 右节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span> </span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node right; </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> value, Node left, Node right)</span> </span>&#123; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.left = left; </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.right = right; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(Node treeNode)</span> </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 遍历节点 </span></span><br><span class=\"line\">        process(treeNode) </span><br><span class=\"line\">        <span class=\"comment\">// 遍历左节点 </span></span><br><span class=\"line\">        dfs(treeNode.left); </span><br><span class=\"line\">        <span class=\"comment\">// 遍历右节点 </span></span><br><span class=\"line\">        dfs(treeNode.right); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。所以我们重点看下非递归实现。</p>\n<h3 id=\"非递归实现\"><a href=\"#非递归实现\" class=\"headerlink\" title=\"非递归实现\"></a><strong>非递归实现</strong></h3><p>仔细观察深度优先遍历的特点，对二叉树来说，由于是先序遍历(先遍历当前节点，再遍历左节点，再遍历右节点)，所以我们有如下思路：</p>\n<p>对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点(这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求)。</p>\n<p>弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。</p>\n<p>我们以以下二叉树为例来看下如何用栈来实现 DFS。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/e1e6a44251b69cd3b930f3071a71ffd8.gif\" alt=\"e1e6a44251b69cd3b930f3071a71ffd8\"></p>\n<p>整体思路还是比较清晰的，使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断回溯(出栈)，有了思路，不难写出如下用栈实现的二叉树的深度优先遍历代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用栈来实现 dfs </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfsWithStack</span><span class=\"params\">(Node root)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">    Stack&lt;Node&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;(); </span><br><span class=\"line\">    <span class=\"comment\">// 先把根节点压栈 </span></span><br><span class=\"line\">    stack.push(root); </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123; </span><br><span class=\"line\">        Node treeNode = stack.pop(); </span><br><span class=\"line\">        <span class=\"comment\">// 遍历节点 </span></span><br><span class=\"line\">        process(treeNode) </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 先压右节点 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode.right != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.push(treeNode.right); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">// 再压左节点 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (treeNode.left != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.push(treeNode.left); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到用栈实现深度优先遍历其实代码也不复杂，而且也不用担心递归那样层级过深导致的栈溢出问题。</p>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a><strong>广度优先搜索</strong></h2><p>广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p>\n<p>上文所述树的广度优先遍历动图如下，每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历，先遍历第一层(节点 1)，再遍历第二层(节点 2，3，4)，第三层(5，6，7，8)，第四层(9，10)。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/29dc30c1546cc73846153359b0fad8fb.gif\" alt=\"29dc30c1546cc73846153359b0fad8fb\"></p>\n<p>深度优先遍历用的是栈，而广度优先遍历要用队列来实现，我们以下图二叉树为例来看看如何用队列来实现广度优先遍历。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/a2c7c61edcadffeed85c10f53f1c988c.gif\" alt=\"a2c7c61edcadffeed85c10f53f1c988c\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用队列实现 bfs </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root </span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(Node root)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    Queue&lt;Node&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;(); </span><br><span class=\"line\">    stack.add(root); </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123; </span><br><span class=\"line\">        Node node = stack.poll(); </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"value = \"</span> + node.value); </span><br><span class=\"line\">        Node left = node.left; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.add(left); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        Node right = node.right; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">            stack.add(right); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>DFS，BFS 在搜索引擎中的应用我们几乎每天都在 <code>Google</code>, <code>Baidu</code> 这些搜索引擎，那大家知道这些搜索引擎是怎么工作的吗，简单来说有三步：</p>\n<h3 id=\"网页抓取\"><a href=\"#网页抓取\" class=\"headerlink\" title=\"网页抓取\"></a><strong>网页抓取</strong></h3><p>搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中</p>\n<h3 id=\"预处理\"><a href=\"#预处理\" class=\"headerlink\" title=\"预处理\"></a><strong>预处理</strong></h3><p>索引程序对抓取来的页面数据进行文字提取，中文分词，(倒排)索引等处理，以备排名程序使用</p>\n<h3 id=\"排名\"><a href=\"#排名\" class=\"headerlink\" title=\"排名\"></a><strong>排名</strong></h3><p>用户输入关键词后，排名程序调用索引数据库数据，计算相关性，然后按一定格式生成搜索结果页面。</p>\n<p>我们重点看下第一步，网页抓取。</p>\n<p>这一步的大致操作如下：给爬虫分配一组起始的网页，我们知道网页里其实也包含了很多超链接，爬虫爬取一个网页后，解析提取出这个网页里的所有超链接，再依次爬取出这些超链接，再提取网页超链接。。。，如此不断重复就能不断根据超链接提取网页。如下图示：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210802113838013.png\" alt=\"image-20210802113838013\"></p>\n<p>如上所示，最终构成了一张图，于是问题就转化为了如何遍历这张图，显然可以用深度优先或广度优先的方式来遍历。</p>\n<p>如果是广度优先遍历，先依次爬取第一层的起始网页，再依次爬取每个网页里的超链接，如果是深度优先遍历，先爬取起始网页 1，再爬取此网页里的链接…，爬取完之后，再爬取起始网页 2…</p>\n<p>实际上爬虫是深度优先与广度优先两种策略一起用的，比如在起始网页里，有些网页比较重要(权重较高)，那就先对这个网页做深度优先遍历，遍历完之后再对其他(权重一样的)起始网页做广度优先遍历。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>DFS 和 BFS 是非常重要的两种算法，大家一定要掌握，本文为了方便讲解，只对树做了 DFS，BFS，大家可以试试如果用图的话该怎么写代码，原理其实也是一样，只不过图和树两者的表示形式不同而已，DFS 一般是解决连通性问题，而 BFS 一般是解决最短路径问题!</p>\n<hr>\n<h1 id=\"733-图像渲染\"><a href=\"#733-图像渲染\" class=\"headerlink\" title=\"733. 图像渲染\"></a><a href=\"https://leetcode-cn.com/problems/flood-fill/\" target=\"_blank\" rel=\"noopener\">733. 图像渲染</a></h1><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>\n<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>\n<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>\n<p>最后返回经过上色渲染后的图像。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入: </span><br><span class=\"line\"><span class=\"attr\">image</span> = [[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"attr\">sr</span> = <span class=\"number\">1</span>, sc = <span class=\"number\">1</span>, newColor = <span class=\"number\">2</span></span><br><span class=\"line\">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class=\"line\">解析: </span><br><span class=\"line\">在图像的正中间，(坐标(sr,sc)=(1,1)),</span><br><span class=\"line\">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class=\"line\">注意，右下角的像素没有更改为2，</span><br><span class=\"line\">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= nums.length &lt;= 104</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 已按 非递减顺序 排序</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li>\n<li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li>\n<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本题要求将给定的二维数组中指定的「色块」染成另一种颜色。「色块」的定义是：直接或间接相邻的同色方格构成的整体。</p>\n<p>可以发现，「色块」就是被不同颜色的方格包围的一个同色岛屿。我们从色块中任意一个地方开始，利用广度优先搜索或深度优先搜索即可遍历整个岛屿。</p>\n<p>注意：当目标颜色和初始颜色相同时，我们无需对原数组进行修改。</p>\n<h2 id=\"方法一：广度优先搜索\"><a href=\"#方法一：广度优先搜索\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路及算法</p>\n<p>我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。</p>\n<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] floodFill(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> sr, <span class=\"keyword\">int</span> sc, <span class=\"keyword\">int</span> newColor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currColor = image[sr][sc];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currColor == newColor) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = image.length, m = image[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">        queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;sr, sc&#125;);</span><br><span class=\"line\">        image[sr][sc] = newColor;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &gt;= <span class=\"number\">0</span> &amp;&amp; mx &lt; n &amp;&amp; my &gt;= <span class=\"number\">0</span> &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;mx, my&#125;);</span><br><span class=\"line\">                    image[mx][my] = newColor;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。</li>\n<li>空间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。主要为队列的开销。</li>\n</ul>\n<h2 id=\"方法二：深度优先搜索\"><a href=\"#方法二：深度优先搜索\" class=\"headerlink\" title=\"方法二：深度优先搜索\"></a>方法二：深度优先搜索</h2><p>思路与算法</p>\n<p>我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。</p>\n<p>注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dx = &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] floodFill(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> sr, <span class=\"keyword\">int</span> sc, <span class=\"keyword\">int</span> newColor) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currColor = image[sr][sc];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currColor != newColor) &#123;</span><br><span class=\"line\">            dfs(image, sr, sc, currColor, newColor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] image, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> color, <span class=\"keyword\">int</span> newColor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image[x][y] == color) &#123;</span><br><span class=\"line\">            image[x][y] = newColor;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> mx = x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &gt;= <span class=\"number\">0</span> &amp;&amp; mx &lt; image.length &amp;&amp; my &gt;= <span class=\"number\">0</span> &amp;&amp; my &lt; image[<span class=\"number\">0</span>].length) &#123;</span><br><span class=\"line\">                    dfs(image, mx, my, color, newColor);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。最坏情况下需要遍历所有的方格一次。</li>\n<li>空间复杂度：<code>O(n×m)</code>，其中 <code>n</code> 和 <code>m</code> 分别是二维数组的行数和列数。主要为栈空间的开销。</li>\n</ul>\n<h1 id=\"695-岛屿的最大面积\"><a href=\"#695-岛屿的最大面积\" class=\"headerlink\" title=\"695. 岛屿的最大面积\"></a><a href=\"https://leetcode-cn.com/problems/rotate-array/\" target=\"_blank\" rel=\"noopener\">695. 岛屿的最大面积</a></h1><p>给定一个包含了一些 0 和 1 的非空二维数组 <code>grid</code>。</p>\n<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>\n<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class=\"line\"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class=\"line\"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class=\"line\"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class=\"line\"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class=\"line\"> <span class=\"section\">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"><span class=\"section\">[[0,0,0,0,0,0,0,0]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">对于上面这个给定的矩阵, 返回 0。</span><br><span class=\"line\"></span><br><span class=\"line\">注意: 给定的矩阵grid 的长度和宽度都不超过 50。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：深度优先搜索\"><a href=\"#方法一：深度优先搜索\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p>算法</p>\n<p>我们想知道网格中每个连通形状的面积，然后取最大值。</p>\n<p>如果我们在一个土地上，以 44 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</p>\n<p>为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 00。这样我们就不会多次访问同一土地。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                ans = Math.max(ans, dfs(grid, i, j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid, <span class=\"keyword\">int</span> cur_i, <span class=\"keyword\">int</span> cur_j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">            ans += dfs(grid, next_i, next_j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 <code>R</code> 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，递归的深度最大可能是整个网格的大小，因此最大可能使用 <code>O(R×C)</code> 的栈空间。</li>\n</ul>\n<h2 id=\"方法二：深度优先搜索-栈\"><a href=\"#方法二：深度优先搜索-栈\" class=\"headerlink\" title=\"方法二：深度优先搜索 + 栈\"></a>方法二：深度优先搜索 + 栈</h2><p>算法</p>\n<p>我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：</p>\n<p>方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。</p>\n<p>访问每一片土地时，我们将对围绕它四个方向进行探索，找到还未访问的土地，加入到栈 stack 中；</p>\n<p>另外，只要栈 stack 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">                Deque&lt;Integer&gt; stacki = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                Deque&lt;Integer&gt; stackj = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                stacki.push(i);</span><br><span class=\"line\">                stackj.push(j);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stacki.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> cur_i = stacki.pop(), cur_j = stackj.pop();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    ++cur;</span><br><span class=\"line\">                    grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">                        stacki.push(next_i);</span><br><span class=\"line\">                        stackj.push(next_j);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = Math.max(ans, cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 RR 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，栈中最多会存放所有的土地，土地的数量最多为 <code>R×C</code> 块，因此使用的空间为 <code>O(R×C)</code>。</li>\n</ul>\n<h2 id=\"方法三：广度优先搜索\"><a href=\"#方法三：广度优先搜索\" class=\"headerlink\" title=\"方法三：广度优先搜索\"></a>方法三：广度优先搜索</h2><p><strong>算法</strong></p>\n<p>我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != grid.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j != grid[<span class=\"number\">0</span>].length; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">                Queue&lt;Integer&gt; queuei = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                Queue&lt;Integer&gt; queuej = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">                queuei.offer(i);</span><br><span class=\"line\">                queuej.offer(j);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!queuei.isEmpty()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> cur_i = queuei.poll(), cur_j = queuej.poll();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    ++cur;</span><br><span class=\"line\">                    grid[cur_i][cur_j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] di = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span>[] dj = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index != <span class=\"number\">4</span>; ++index) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> next_i = cur_i + di[index], next_j = cur_j + dj[index];</span><br><span class=\"line\">                        queuei.offer(next_i);</span><br><span class=\"line\">                        queuej.offer(next_j);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = Math.max(ans, cur);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(R×C)</code>。其中 <code>R</code> 是给定网格中的行数，<code>C</code> 是列数。我们访问每个网格最多一次。</li>\n<li>空间复杂度：<code>O(R×C)</code>，队列中最多会存放所有的土地，土地的数量最多为 <code>R×C</code> 块，因此使用的空间为 <code>O(R×C)</code>。</li>\n</ul>\n<h1 id=\"617-合并二叉树\"><a href=\"#617-合并二叉树\" class=\"headerlink\" title=\"617. 合并二叉树\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\" target=\"_blank\" rel=\"noopener\">617. 合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>\n<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: </span><br><span class=\"line\">\tTree 1                     Tree 2                  </span><br><span class=\"line\">          1                         2                             </span><br><span class=\"line\">         / \\                       / \\                            </span><br><span class=\"line\">        3   2                     1   3                        </span><br><span class=\"line\">       /                           \\   \\                      </span><br><span class=\"line\">      5                             4   7                  </span><br><span class=\"line\">输出: </span><br><span class=\"line\">合并后的树:</span><br><span class=\"line\">\t     3</span><br><span class=\"line\">\t    / \\</span><br><span class=\"line\">\t   4   5</span><br><span class=\"line\">\t  / \\   \\ </span><br><span class=\"line\">\t 5   4   7</span><br><span class=\"line\"></span><br><span class=\"line\">注意: 合并必须从两个树的根节点开始。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：深度优先搜索-1\"><a href=\"#方法一：深度优先搜索-1\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>\n<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>\n<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>\n<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>\n<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>\n<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode merged = <span class=\"keyword\">new</span> TreeNode(t1.val + t2.val);</span><br><span class=\"line\">        merged.left = mergeTrees(t1.left, t2.left);</span><br><span class=\"line\">        merged.right = mergeTrees(t1.right, t2.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>\n<li>空间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>\n</ul>\n<h2 id=\"方法二：广度优先搜索\"><a href=\"#方法二：广度优先搜索\" class=\"headerlink\" title=\"方法二：广度优先搜索\"></a>方法二：广度优先搜索</h2><p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p>\n<p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p>\n<p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p>\n<p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p>\n<p>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</p>\n<p>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</p>\n<p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode merged = <span class=\"keyword\">new</span> TreeNode(t1.val + t2.val);</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue1 = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue2 = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(merged);</span><br><span class=\"line\">        queue1.offer(t1);</span><br><span class=\"line\">        queue2.offer(t2);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();</span><br><span class=\"line\">            TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span> || left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span> &amp;&amp; left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    TreeNode left = <span class=\"keyword\">new</span> TreeNode(left1.val + left2.val);</span><br><span class=\"line\">                    node.left = left;</span><br><span class=\"line\">                    queue.offer(left);</span><br><span class=\"line\">                    queue1.offer(left1);</span><br><span class=\"line\">                    queue2.offer(left2);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.left = left1;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.left = left2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span> || right2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span> &amp;&amp; right2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    TreeNode right = <span class=\"keyword\">new</span> TreeNode(right1.val + right2.val);</span><br><span class=\"line\">                    node.right = right;</span><br><span class=\"line\">                    queue.offer(right);</span><br><span class=\"line\">                    queue1.offer(right1);</span><br><span class=\"line\">                    queue2.offer(right2);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    node.right = right1;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    node.right = right2;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>\n<li>空间复杂度：<code>O(min(m,n))</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。</li>\n</ul>\n<h1 id=\"116-填充每个节点的下一个右侧节点指针\"><a href=\"#116-填充每个节点的下一个右侧节点指针\" class=\"headerlink\" title=\"116. 填充每个节点的下一个右侧节点指针\"></a><a href=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\" target=\"_blank\" rel=\"noopener\">116. 填充每个节点的下一个右侧节点指针</a></h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Node &#123;</span><br><span class=\"line\">  int val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p>进阶：</p>\n<ul>\n<li>你只能使用常量级额外空间。</li>\n<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>\n</ul>\n<p>实例：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803170521884.png\" alt=\"image-20210803170521884\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3,4,5,6,7]</span><br><span class=\"line\">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class=\"line\">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数量少于 <code>4096</code></li>\n<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n<h2 id=\"方法一：层次遍历\"><a href=\"#方法一：层次遍历\" class=\"headerlink\" title=\"方法一：层次遍历\"></a>方法一：层次遍历</h2><p>思路与算法</p>\n<p>题目本身希望我们将二叉树的每一层节点都连接起来形成一个链表。因此直观的做法我们可以对二叉树进行层次遍历，在层次遍历的过程中将我们将二叉树每一层的节点拿出来遍历并连接。</p>\n<p>层次遍历基于广度优先搜索，它与广度优先搜索的不同之处在于，广度优先搜索每次只会取出一个节点来拓展，而层次遍历会每次将队列中的所有元素都拿出来拓展，这样能保证每次从队列中拿出来遍历的元素都是属于同一层的，因此我们可以在遍历的过程中修改每个节点的 \\text{next}next 指针，同时拓展下一层的新队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始化队列同时将第一层节点加入队列中，即根节点</span></span><br><span class=\"line\">        Queue&lt;Node&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;Node&gt;(); </span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 外层的 while 循环迭代的是层数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 记录当前队列大小</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 遍历这一层的所有节点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 从队首取出元素</span></span><br><span class=\"line\">                Node node = queue.poll();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; size - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    node.next = queue.peek();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 拓展下一层节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.add(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.add(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 <code>next</code> 指针。</li>\n<li>空间复杂度：<code>O(N)</code>。这是一棵完美二叉树，它的最后一个层级包含 <code>N/2</code> 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 <code>O(N)</code>。</li>\n</ul>\n<h2 id=\"方法二：使用已建立的-next-指针\"><a href=\"#方法二：使用已建立的-next-指针\" class=\"headerlink\" title=\"方法二：使用已建立的 next 指针\"></a>方法二：使用已建立的 <code>next</code> 指针</h2><p>思路</p>\n<p>一棵树中，存在两种类型的 <code>next</code> 指针。</p>\n<p>第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.left.next</span> = node.right</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803170948867.png\" alt=\"image-20210803170948867\"></p>\n<p>第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171005454.png\" alt=\"image-20210803171005454\"></p>\n<p>如果每个节点有指向父节点的指针，可以通过该指针找到 \\text{next}next 节点。如果不存在该指针，则按照下面思路建立连接：</p>\n<blockquote>\n<p>第 <code>N</code> 层节点之间建立 <code>next</code> 指针后，再建立第 <code>N+1</code> 层节点的 <code>next</code> 指针。可以通过 <code>next</code> 指针访问同一层的所有节点，因此可以使用第 <code>N</code> 层的 <code>next</code> 指针，为第 <code>N+1</code> 层节点建立 <code>next</code> 指针。</p>\n</blockquote>\n<p>算法</p>\n<ul>\n<li>从根节点开始，由于第 <code>0</code> 层只有一个节点，所以不需要连接，直接为第 <code>1</code> 层节点建立<code>next</code> 指针即可。该算法中需要注意的一点是，当我们为第 <code>N</code> 层节点建立 <code>next</code> 指针时，处于第 <code>N-1</code> 层。当第 <code>N</code> 层节点的 <code>next</code> 指针全部建立完成后，移至第 <code>N</code> 层，建立第 <code>N+1</code> 层节点的 <code>next</code> 指针。</li>\n<li>遍历某一层的节点时，这层节点的 <code>next</code> 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。</li>\n</ul>\n<p>上面思路的伪代码如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">leftmost</span> = root</span><br><span class=\"line\">while (leftmost.left != null) &#123;</span><br><span class=\"line\">    head = leftmost</span><br><span class=\"line\">    while (head.next != null) &#123;</span><br><span class=\"line\">        1) Establish Connection 1</span><br><span class=\"line\">        2) Establish Connection 2 using next pointers</span><br><span class=\"line\">        head = head.next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    leftmost = leftmost.left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171349312.png\" alt=\"image-20210803171349312\"></p>\n<p>两种类型的 <code>next</code> 指针。</p>\n<p>第一种情况两个子节点属于同一个父节点，因此直接通过父节点建立两个子节点的 <code>next</code> 指针即可。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.left.next</span> = node.right</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171509072.png\" alt=\"image-20210803171509072\"></p>\n<p>第二种情况是连接不同父节点之间子节点的情况。更具体地说，连接的是第一个父节点的右孩子和第二父节点的左孩子。由于已经在父节点这一层建立了 <code>next</code> 指针，因此可以直接通过第一个父节点的 <code>next</code> 指针找到第二个父节点，然后在它们的孩子之间建立连接。</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">node.right.next</span> = node.next.left</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171521571.png\" alt=\"image-20210803171521571\"></p>\n<p>完成当前层的连接后，进入下一层重复操作，直到所有的节点全部连接。进入下一层后需要更新最左节点，然后从新的最左节点开始遍历该层所有节点。因为是完美二叉树，因此最左节点一定是当前层最左节点的左孩子。如果当前最左节点的左孩子不存在，说明已经到达该树的最后一层，完成了所有节点的连接。</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803171559123.png\" alt=\"image-20210803171559123\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">connect</span><span class=\"params\">(Node root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">        Node leftmost = root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (leftmost.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span></span><br><span class=\"line\">            Node head = leftmost;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// CONNECTION 1</span></span><br><span class=\"line\">                head.left.next = head.right;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// CONNECTION 2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (head.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    head.right.next = head.next.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 指针向后移动</span></span><br><span class=\"line\">                head = head.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 去下一层的最左的节点</span></span><br><span class=\"line\">            leftmost = leftmost.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，每个节点只访问一次。</li>\n<li>空间复杂度：<code>O(1)</code>，不需要存储额外的节点。</li>\n</ul>\n<h1 id=\"542-01-矩阵\"><a href=\"#542-01-矩阵\" class=\"headerlink\" title=\"542. 01 矩阵\"></a><a href=\"https://leetcode-cn.com/problems/01-matrix/\" target=\"_blank\" rel=\"noopener\">542. 01 矩阵</a></h1><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p>\n<p>两个相邻元素间的距离为 1 。</p>\n<p>示例 1：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172012460.png\" alt=\"image-20210803172012460\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class=\"line\">输出：[[0,0,0],[0,1,0],[0,0,0]]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172049764.png\" alt=\"image-20210803172049764\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0],[0,1,0],[1,1,1]]</span><br><span class=\"line\">输出：[[0,0,0],[0,1,0],[1,2,1]]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>m == mat.length</li>\n<li>n == mat[i].length</li>\n<li>1 &lt;= m, n &lt;= 104</li>\n<li>1 &lt;= m * n &lt;= 104</li>\n<li>mat[i][j] is either 0 or 1.</li>\n<li>mat 中至少有一个 0 </li>\n</ul>\n<h2 id=\"方法一：广度优先搜索-1\"><a href=\"#方法一：广度优先搜索-1\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172302735.png\" alt=\"image-20210803172302735\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172318899.png\" alt=\"image-20210803172318899\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172339057.png\" alt=\"image-20210803172339057\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172402962.png\" alt=\"image-20210803172402962\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172422525.png\" alt=\"image-20210803172422525\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172446051.png\" alt=\"image-20210803172446051\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[][] seen = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[m][n];</span><br><span class=\"line\">        Queue&lt;<span class=\"keyword\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 将所有的 0 添加进初始队列中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i, j&#125;);</span><br><span class=\"line\">                    seen[i][j] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 广度优先搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cell[<span class=\"number\">0</span>], j = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> d = <span class=\"number\">0</span>; d &lt; <span class=\"number\">4</span>; ++d) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> ni = i + dirs[d][<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nj = j + dirs[d][<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ni &gt;= <span class=\"number\">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class=\"number\">0</span> &amp;&amp; nj &lt; n &amp;&amp; !seen[ni][nj]) &#123;</span><br><span class=\"line\">                    dist[ni][nj] = dist[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    queue.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;ni, nj&#125;);</span><br><span class=\"line\">                    seen[ni][nj] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172525093.png\" alt=\"image-20210803172525093\"></p>\n<h2 id=\"方法二：动态规划\"><a href=\"#方法二：动态规划\" class=\"headerlink\" title=\"方法二：动态规划\"></a>方法二：动态规划</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172552521.png\" alt=\"image-20210803172552521\"></p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172607369.png\" alt=\"image-20210803172607369\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172635206.png\" alt=\"image-20210803172635206\"></p>\n<h2 id=\"方法三：动态规划的常数优化\"><a href=\"#方法三：动态规划的常数优化\" class=\"headerlink\" title=\"方法三：动态规划的常数优化\"></a>方法三：动态规划的常数优化</h2><p><img src=\"../../../../img/805-DFSandBFS/image-20210803172651242.png\" alt=\"image-20210803172651242\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] dirs = &#123;&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] updateMatrix(<span class=\"keyword\">int</span>[][] matrix) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 (i, j) 的元素为 0，那么距离为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;</span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172724760.png\" alt=\"image-20210803172724760\"></p>\n<h1 id=\"994-腐烂的橘子\"><a href=\"#994-腐烂的橘子\" class=\"headerlink\" title=\"994. 腐烂的橘子\"></a><a href=\"https://leetcode-cn.com/problems/rotting-oranges/\" target=\"_blank\" rel=\"noopener\">994. 腐烂的橘子</a></h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>\n<ul>\n<li><p>值 0 代表空单元格；</p>\n</li>\n<li><p>值 1 代表新鲜橘子；</p>\n</li>\n<li><p>值 2 代表腐烂的橘子。</p>\n</li>\n</ul>\n<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>\n<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>\n<p>实例1：</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803172929827.png\" alt=\"image-20210803172929827\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：[[0,2]]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= grid.length &lt;= 10</span><br><span class=\"line\">1 &lt;= grid[0].length &lt;= 10</span><br><span class=\"line\">grid[i][j] 仅为 0、1 或 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由题目我们可以知道每分钟每个腐烂的橘子都会使上下左右相邻的新鲜橘子腐烂，这其实是一个模拟广度优先搜索的过程。所谓广度优先搜索，就是从起点出发，每次都尝试访问同一层的节点，如果同一层都访问完了，再访问下一层，最后广度优先搜索找到的路径就是从起点开始的最短合法路径。</p>\n<p>回到题目中，假设图中只有一个腐烂的橘子，它每分钟向外拓展，腐烂上下左右相邻的新鲜橘子，那么下一分钟，就是这些被腐烂的橘子再向外拓展腐烂相邻的新鲜橘子，这与广度优先搜索的过程均一一对应，上下左右相邻的新鲜橘子就是该腐烂橘子尝试访问的同一层的节点，路径长度就是新鲜橘子被腐烂的时间。我们记录下每个新鲜橘子被腐烂的时间，最后如果单元格中没有新鲜橘子，腐烂所有新鲜橘子所必须经过的最小分钟数就是新鲜橘子被腐烂的时间的最大值。</p>\n<p>以上是基于图中只有一个腐烂的橘子的情况，可实际题目中腐烂的橘子数不止一个，看似与广度优先搜索有所区别，不能直接套用，但其实有两个方向的思路。</p>\n<p>一个是耗时比较大且不推荐的做法：我们对每个腐烂橘子为起点都进行一次广度优先搜索，用 <img src=\"../../../../img/805-DFSandBFS/image-20210803173207123.png\" alt=\"image-20210803173207123\">表示只考虑第 ii 个腐烂橘子为起点的广度优先搜索，坐标位于 (x, y)(x,y) 的新鲜橘子被腐烂的时间，设没有被腐烂的新鲜橘子的 <img src=\"../../../../img/805-DFSandBFS/image-20210803173230434.png\" alt=\"image-20210803173230434\"> ，即无限大，表示没有被腐烂，那么每个新鲜橘子被腐烂的最短时间即为</p>\n<p><img src=\"../../../../img/805-DFSandBFS/image-20210803173125322.png\" alt=\"image-20210803173125322\"></p>\n<p>最后的答案就是所有新鲜橘子被腐烂的最短时间的最大值，如果是无限大，说明有新鲜橘子没有被腐烂，输出 <code>-1</code> 即可。</p>\n<p>无疑上面的方法需要枚举每个腐烂橘子，所以时间复杂度需要在原先广度优先搜索遍历的时间复杂度上再乘以腐烂橘子数，这在整个网格范围变大的时候十分耗时，所以需要另寻他路。</p>\n<h2 id=\"方法一：多源广度优先搜索\"><a href=\"#方法一：多源广度优先搜索\" class=\"headerlink\" title=\"方法一：多源广度优先搜索\"></a>方法一：多源广度优先搜索</h2><p>思路</p>\n<p>观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。</p>\n<p>假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(我们令其为超级源点)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 <code>−1</code> ，那么按照广度优先搜索的算法，下一分钟也就是第 <code>0</code> 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 <code>dis[x][y]</code> 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</p>\n<p>为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 <code>cnt</code> 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 <code>cnt-=1</code> ，最后搜索结束时如果<code>cnt</code> 大于 <code>0</code> ，说明有新鲜橘子没被腐烂，返回 <code>-1</code> ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 <code>1</code> 改为 <code>2</code>，最后看网格中是否由值为 <code>1</code> 即新鲜的橘子即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] dc = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">orangesRotting</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> R = grid.length, C = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; depth = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>; r &lt; R; ++r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; C; ++c) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[r][c] == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> code = r * C + c;</span><br><span class=\"line\">                    queue.add(code);</span><br><span class=\"line\">                    depth.put(code, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> code = queue.remove();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> r = code / C, c = code % C;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; ++k) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nr = r + dr[k];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> nc = c + dc[k];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt;= nr &amp;&amp; nr &lt; R &amp;&amp; <span class=\"number\">0</span> &lt;= nc &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    grid[nr][nc] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> ncode = nr * C + nc;</span><br><span class=\"line\">                    queue.add(ncode);</span><br><span class=\"line\">                    depth.put(ncode, depth.get(code) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    ans = depth.get(ncode);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] row: grid) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v: row) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(nm)</code><br>即进行一次广度优先搜索的时间，其中 <code>n=grid.length</code>, <code>m=grid[0].length</code> 。</li>\n<li>空间复杂度：<code>O(nm)</code><br>需要额外的 <code>dis</code> 数组记录每个新鲜橘子被腐烂的最短时间，大小为 <code>O(nm)</code>，且广度优先搜索中队列里存放的状态最多不会超过 <code>nm</code> 个，最多需要<code>O(nm)</code> 的空间，所以最后的空间复杂度为 <code>O(nm)</code>。</li>\n</ul>\n","next":{"title":"深入理解 Java SPI机制","path":"api/articles/resource-java-Base-javaSPI.json","image":"/img/header_img/java/spi.png","num_read":1860,"num_like":427,"num_collection":778,"num_comments":85},"prev":{"title":"SQLSERVER数据库各种角色说明","path":"api/articles/resource-DB-SQLServer-DBRole.json","image":"/img/header_img/DB/SQLServerRole.png","num_read":317,"num_like":592,"num_collection":443,"num_comments":137},"categories":[{"name":"算法","path":"api/categories/算法.json","pathContent":"api/categories/算法","description":"为了更有效的处理数据，提高数据运算效率。","cover":"https://sunfy9.gitee.io/project/photo/project/algorithm.png"}],"tags":[]}