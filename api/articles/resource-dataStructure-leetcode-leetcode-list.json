{"title":"数据结构测试题---链表","num_read":1676,"num_like":1028,"num_collection":673,"num_comments":283,"slug":"resource-dataStructure-leetcode-leetcode-list","date":"2021-08-29T16:00:00.000Z","img":"/img/header_img/dataStructure/list.jpg","_id":"clhrbp2am0004o5lg8t8h9w1m","project":"dataStructure","site":{"data":{}},"updated":"2022-10-29T09:05:05.007Z","comments":true,"path":"api/articles/resource-dataStructure-leetcode-leetcode-list.json","webPath":"2021/08/30/resource-dataStructure-leetcode-leetcode-list/","permalink":"https://sunfy9.gitee.io/2021/08/30/resource-dataStructure-leetcode-leetcode-list/","excerpt":null,"covers":["../../../../img/leetcode-list/circularlinkedlist-7033150.png","../../../../img/leetcode-list/circularlinkedlist_test2-7033150.png","../../../../img/leetcode-list/circularlinkedlist_test3-7033150.png","../../../../img/leetcode-list/list1-7033150.gif","../../../../img/leetcode-list/removelinked-list-7033150.jpg","../../../../img/leetcode-list/image-20210830133909515-7033150.png","../../../../img/leetcode-list/image-20210830134023763-7033150.png","../../../../img/leetcode-list/list1-7033150.jpg","../../../../img/leetcode-list/list2-7033150.jpg"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p>进阶：</p>\n<p>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>\n<p>示例 1：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist_test2-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2], pos = 0</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist_test3-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1], pos = -1</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">提示：</span><br><span class=\"line\">链表中节点的数目范围是 [0, 104]</span><br><span class=\"line\">-105 &lt;= Node.val &lt;= 105</span><br><span class=\"line\">pos 为 -1 或者链表中的一个 有效索引 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：哈希表\"><a href=\"#方法一：哈希表\" class=\"headerlink\" title=\"方法一：哈希表\"></a><sunfy-line>方法一：哈希表</h2><p>思路及算法</p>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> HashSet&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</li>\n<li>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</li>\n</ul>\n<h2 id=\"方法二：快慢指针\"><a href=\"#方法二：快慢指针\" class=\"headerlink\" title=\"方法二：快慢指针\"></a>方法二：快慢指针</h2><p>思路及算法</p>\n<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"../../../../img/leetcode-list/list1-7033150.gif\" alt=\"list1\"></p>\n<p>细节</p>\n<p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p>\n<p>观察下面的代码，我们使用的是 <code>while</code> 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 <code>head</code>，那么 while 循环就不会执行。因此，我们可以假想一个在 <code>head</code> 之前的虚拟节点，慢指针从虚拟节点移动一步到达 <code>head</code>，快指针从虚拟节点移动两步到达 <code>head.next</code>，这样我们就可以使用 <code>while</code> 循环了。</p>\n<p>当然，我们也可以使用 <code>do-while</code> 循环。此时，我们就可以把快慢指针的初始值都置为 <code>head</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。</p>\n<ul>\n<li>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</li>\n<li>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 <code>N</code> 轮。</li>\n</ul>\n</li>\n<li><p>空间复杂度：<code>O(1)</code>。我们只使用了两个指针的额外空间。</p>\n</li>\n</ul>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. 合并两个有序链表</a></h1><p><a href=\"https://sunfy.top/2021/08/25/resource-file-algorithm-806-recursive/#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<h1 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">203. 移除链表元素</a></h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/removelinked-list-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：head = [], val = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：head = [7,7,7,7], val = 7</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>\n<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n<h2 id=\"方法一：递归\"><a href=\"#方法一：递归\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-list/image-20210830133909515-7033150.png\" alt=\"image-20210830133909515\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head.next = removeElements(head.next, val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.val == val ? head.next : head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。递归过程中需要遍历链表一次。</li>\n<li>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 <code>n</code> 层。</li>\n</ul>\n<h2 id=\"方法二：迭代\"><a href=\"#方法二：迭代\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p><img src=\"../../../../img/leetcode-list/image-20210830134023763-7033150.png\" alt=\"image-20210830134023763\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode dummyHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHead.next = head;</span><br><span class=\"line\">        ListNode temp = dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.next.val == val) &#123;</span><br><span class=\"line\">                temp.next = temp.next.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                temp = temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。需要遍历链表一次。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">206. 反转链表</a></h1><p><a href=\"https://sunfy.top/2021/08/25/resource-file-algorithm-806-recursive/#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<h1 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83. 删除排序链表中的重复元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. 删除排序链表中的重复元素</a></h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>\n<p>返回同样按升序排列的结果链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/list1-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/list2-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2,3,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n<h2 id=\"方法一：一次遍历\"><a href=\"#方法一：一次遍历\" class=\"headerlink\" title=\"方法一：一次遍历\"></a>方法一：一次遍历</h2><p>思路与算法</p>\n<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>\n<p>具体地，我们从指针 cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与cur.next 对应的元素相同，那么我们就将cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向cur.next。</p>\n<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>\n<p>细节</p>\n<p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>\n<p>代码</p>\n<p>注意下面 C++ 代码中并没有释放被删除的链表节点的空间。如果在面试中遇到本题，读者需要针对这一细节与面试官进行沟通。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.val == cur.next.val) &#123;</span><br><span class=\"line\">                cur.next = cur.next.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code>是链表的长度。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","more":"<h1 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p>进阶：</p>\n<p>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>\n<p>示例 1：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist_test2-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2], pos = 0</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<p><img src=\"../../../../img/leetcode-list/circularlinkedlist_test3-7033150.png\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1], pos = -1</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">提示：</span><br><span class=\"line\">链表中节点的数目范围是 [0, 104]</span><br><span class=\"line\">-105 &lt;= Node.val &lt;= 105</span><br><span class=\"line\">pos 为 -1 或者链表中的一个 有效索引 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：哈希表\"><a href=\"#方法一：哈希表\" class=\"headerlink\" title=\"方法一：哈希表\"></a><sunfy-line>方法一：哈希表</h2><p>思路及算法</p>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> HashSet&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</li>\n<li>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</li>\n</ul>\n<h2 id=\"方法二：快慢指针\"><a href=\"#方法二：快慢指针\" class=\"headerlink\" title=\"方法二：快慢指针\"></a>方法二：快慢指针</h2><p>思路及算法</p>\n<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"../../../../img/leetcode-list/list1-7033150.gif\" alt=\"list1\"></p>\n<p>细节</p>\n<p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p>\n<p>观察下面的代码，我们使用的是 <code>while</code> 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 <code>head</code>，那么 while 循环就不会执行。因此，我们可以假想一个在 <code>head</code> 之前的虚拟节点，慢指针从虚拟节点移动一步到达 <code>head</code>，快指针从虚拟节点移动两步到达 <code>head.next</code>，这样我们就可以使用 <code>while</code> 循环了。</p>\n<p>当然，我们也可以使用 <code>do-while</code> 循环。此时，我们就可以把快慢指针的初始值都置为 <code>head</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        ListNode fast = head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"keyword\">null</span> || fast.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是链表中的节点数。</p>\n<ul>\n<li>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</li>\n<li>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 <code>N</code> 轮。</li>\n</ul>\n</li>\n<li><p>空间复杂度：<code>O(1)</code>。我们只使用了两个指针的额外空间。</p>\n</li>\n</ul>\n<h1 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener\">21. 合并两个有序链表</a></h1><p><a href=\"https://sunfy.top/2021/08/25/resource-file-algorithm-806-recursive/#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<h1 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203. 移除链表元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\" target=\"_blank\" rel=\"noopener\">203. 移除链表元素</a></h1><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/removelinked-list-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：head = [], val = 1</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：head = [7,7,7,7], val = 7</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>\n<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n<h2 id=\"方法一：递归\"><a href=\"#方法一：递归\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-list/image-20210830133909515-7033150.png\" alt=\"image-20210830133909515\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head.next = removeElements(head.next, val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.val == val ? head.next : head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。递归过程中需要遍历链表一次。</li>\n<li>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 <code>n</code> 层。</li>\n</ul>\n<h2 id=\"方法二：迭代\"><a href=\"#方法二：迭代\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p><img src=\"../../../../img/leetcode-list/image-20210830134023763-7033150.png\" alt=\"image-20210830134023763\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode dummyHead = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHead.next = head;</span><br><span class=\"line\">        ListNode temp = dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp.next.val == val) &#123;</span><br><span class=\"line\">                temp.next = temp.next.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                temp = temp.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是链表的长度。需要遍历链表一次。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\">206. 反转链表</a></h1><p><a href=\"https://sunfy.top/2021/08/25/resource-file-algorithm-806-recursive/#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<h1 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83. 删除排序链表中的重复元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" target=\"_blank\" rel=\"noopener\">83. 删除排序链表中的重复元素</a></h1><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>\n<p>返回同样按升序排列的结果链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/list1-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-list/list2-7033150.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2,3,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n<h2 id=\"方法一：一次遍历\"><a href=\"#方法一：一次遍历\" class=\"headerlink\" title=\"方法一：一次遍历\"></a>方法一：一次遍历</h2><p>思路与算法</p>\n<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>\n<p>具体地，我们从指针 cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与cur.next 对应的元素相同，那么我们就将cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向cur.next。</p>\n<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>\n<p>细节</p>\n<p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>\n<p>代码</p>\n<p>注意下面 C++ 代码中并没有释放被删除的链表节点的空间。如果在面试中遇到本题，读者需要针对这一细节与面试官进行沟通。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.val == cur.next.val) &#123;</span><br><span class=\"line\">                cur.next = cur.next.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code>是链表的长度。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","next":{"title":"数据结构测试题---字符串","path":"api/articles/resource-dataStructure-leetcode-leetcode-str.json","image":"/img/header_img/10.jpg","num_read":199,"num_like":178,"num_collection":871,"num_comments":154},"prev":{"title":"计算机术语简写全称对照表","path":"api/articles/resource-tools-other-acronyms.json","image":"/img/header_img/11.jpg","num_read":1755,"num_like":865,"num_collection":861,"num_comments":182},"categories":[{"name":"数据结构","path":"api/categories/数据结构.json","pathContent":"api/categories/数据结构","description":"一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。","cover":"https://sunfy9.gitee.io/project/photo/project/dataStructure.png"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json","pathContent":"api/tags/leetcode","description":"[leetcode]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}