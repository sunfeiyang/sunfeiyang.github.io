{"title":"如何选择适合的阻塞队列","num_read":1538,"num_like":853,"num_collection":599,"num_comments":119,"slug":"resource-java-concurrent-BlockingQueueSelect","date":"2021-12-16T16:00:00.000Z","img":"/img/header_img/concurrent/SelectBlockingQueue.png","minNumber":500,"format":"max","_id":"clhrbp2dm009ao5lg38jh2we6","project":"concurrent","subtitle":"如何选择适合的阻塞队列","site":{"data":{}},"updated":"2022-01-12T05:38:32.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BlockingQueueSelect.json","webPath":"2021/12/17/resource-java-concurrent-BlockingQueueSelect/","permalink":"https://sunfy9.gitee.io/2021/12/17/resource-java-concurrent-BlockingQueueSelect/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"如何选择适合的阻塞队列\"><a href=\"#如何选择适合的阻塞队列\" class=\"headerlink\" title=\"如何选择适合的阻塞队列\"></a><strong>如何选择适合的阻塞队列</strong></h1><p><strong>线程池对于阻塞队列的选择</strong></p>\n<p>线程池有很多种，不同种类的线程池会根据自己的特点，来选择适合自己的阻塞队列。</p>\n<ul>\n<li>FixedThreadPool（SingleThreadExecutor 同理）选取的是 LinkedBlockingQueue</li>\n<li>CachedThreadPool 选取的是 SynchronousQueue</li>\n<li>ScheduledThreadPool（SingleThreadScheduledExecutor同理）选取的是延迟队列</li>\n</ul>\n<p><strong>选择策略</strong></p>\n<p>通常我们可以从以下 5 个角度考虑，来选择合适的阻塞队列：<sunfy-line></p>\n<p><strong>(1)功能</strong></p>\n<p>第 1 个需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级排序、延迟执行等。如果有这个需要，我们就必须选择类似于 PriorityBlockingQueue 之类的有排序能力的阻塞队列。</p>\n<p><strong>(2)容量</strong></p>\n<p>第 2 个需要考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如 ArrayBlockingQueue；有的默认是容量无限的，如 LinkedBlockingQueue；而有的里面没有任何容量，如 SynchronousQueue；而对于 DelayQueue 而言，它的容量固定就是 Integer.MAX_VALUE。所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选取合适的 BlockingQueue。</p>\n<p><strong>(3)能否扩容</strong></p>\n<p>第 3 个需要考虑的是能否扩容。因为有时我们并不能在初始的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择 ArrayBlockingQueue ，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue 即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选取合适的队列。</p>\n<p><strong>(4)内存结构</strong></p>\n<p>第 4 个需要考虑的点就是内存结构。ArrayBlockingQueue，它的内部结构是“数组”的形式。和它不同的是，LinkedBlockingQueue 的内部是用链表实现的，所以这里就需要我们考虑到，ArrayBlockingQueue 没有链表所需要的“节点”，空间利用率更高。所以如果我们对性能有要求可以从内存的结构角度去考虑这个问题。</p>\n<p><strong>(5)性能</strong></p>\n<p>第 5 点就是从性能的角度去考虑。比如 LinkedBlockingQueue 由于拥有两把锁，它的操作粒度更细，在并发程度高的时候，相对于只有一把锁的 ArrayBlockingQueue 性能会更好。另外，SynchronousQueue 性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储的过程。如果我们的场景需要直接传递的话，可以优先考虑 SynchronousQueue。</p>\n","more":"<h1 id=\"如何选择适合的阻塞队列\"><a href=\"#如何选择适合的阻塞队列\" class=\"headerlink\" title=\"如何选择适合的阻塞队列\"></a><strong>如何选择适合的阻塞队列</strong></h1><p><strong>线程池对于阻塞队列的选择</strong></p>\n<p>线程池有很多种，不同种类的线程池会根据自己的特点，来选择适合自己的阻塞队列。</p>\n<ul>\n<li>FixedThreadPool（SingleThreadExecutor 同理）选取的是 LinkedBlockingQueue</li>\n<li>CachedThreadPool 选取的是 SynchronousQueue</li>\n<li>ScheduledThreadPool（SingleThreadScheduledExecutor同理）选取的是延迟队列</li>\n</ul>\n<p><strong>选择策略</strong></p>\n<p>通常我们可以从以下 5 个角度考虑，来选择合适的阻塞队列：<sunfy-line></p>\n<p><strong>(1)功能</strong></p>\n<p>第 1 个需要考虑的就是功能层面，比如是否需要阻塞队列帮我们排序，如优先级排序、延迟执行等。如果有这个需要，我们就必须选择类似于 PriorityBlockingQueue 之类的有排序能力的阻塞队列。</p>\n<p><strong>(2)容量</strong></p>\n<p>第 2 个需要考虑的是容量，或者说是否有存储的要求，还是只需要“直接传递”。在考虑这一点的时候，我们知道前面介绍的那几种阻塞队列，有的是容量固定的，如 ArrayBlockingQueue；有的默认是容量无限的，如 LinkedBlockingQueue；而有的里面没有任何容量，如 SynchronousQueue；而对于 DelayQueue 而言，它的容量固定就是 Integer.MAX_VALUE。所以不同阻塞队列的容量是千差万别的，我们需要根据任务数量来推算出合适的容量，从而去选取合适的 BlockingQueue。</p>\n<p><strong>(3)能否扩容</strong></p>\n<p>第 3 个需要考虑的是能否扩容。因为有时我们并不能在初始的时候很好的准确估计队列的大小，因为业务可能有高峰期、低谷期。如果一开始就固定一个容量，可能无法应对所有的情况，也是不合适的，有可能需要动态扩容。如果我们需要动态扩容的话，那么就不能选择 ArrayBlockingQueue ，因为它的容量在创建时就确定了，无法扩容。相反，PriorityBlockingQueue 即使在指定了初始容量之后，后续如果有需要，也可以自动扩容。所以我们可以根据是否需要扩容来选取合适的队列。</p>\n<p><strong>(4)内存结构</strong></p>\n<p>第 4 个需要考虑的点就是内存结构。ArrayBlockingQueue，它的内部结构是“数组”的形式。和它不同的是，LinkedBlockingQueue 的内部是用链表实现的，所以这里就需要我们考虑到，ArrayBlockingQueue 没有链表所需要的“节点”，空间利用率更高。所以如果我们对性能有要求可以从内存的结构角度去考虑这个问题。</p>\n<p><strong>(5)性能</strong></p>\n<p>第 5 点就是从性能的角度去考虑。比如 LinkedBlockingQueue 由于拥有两把锁，它的操作粒度更细，在并发程度高的时候，相对于只有一把锁的 ArrayBlockingQueue 性能会更好。另外，SynchronousQueue 性能往往优于其他实现，因为它只需要“直接传递”，而不需要存储的过程。如果我们的场景需要直接传递的话，可以优先考虑 SynchronousQueue。</p>\n","next":{"title":"PriorityBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-05-PriorityBlockingQueue.json","image":"/img/header_img/concurrent/PriorityBlockingQueue.png","num_read":303,"num_like":329,"num_collection":438,"num_comments":57},"prev":{"title":"sentinel简介","path":"api/articles/resource-MicroService-sentinel-sentinel.json","image":"/img/header_img/MicroService/sentinel.png","num_read":64,"num_like":126,"num_collection":54,"num_comments":53},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}