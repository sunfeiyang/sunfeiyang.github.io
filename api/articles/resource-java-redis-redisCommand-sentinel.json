{"title":"Redis持久化、主从架构和哨兵架构","num_read":418,"num_like":527,"num_collection":502,"num_comments":42,"slug":"resource-java-redis-redisCommand-sentinel","date":"2019-11-19T16:00:00.000Z","img":"/img/header_img/java/redis-sentinel.jpg","_id":"clhrbp2dc006zo5lg0h8ybd4n","site":{"data":{}},"updated":"2022-09-20T01:46:54.465Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-redis-redisCommand-sentinel.json","webPath":"2019/11/20/resource-java-redis-redisCommand-sentinel/","permalink":"https://sunfy9.gitee.io/2019/11/20/resource-java-redis-redisCommand-sentinel/","excerpt":"Redis数据持久化的三种方式，基本的架构模型，主从架构和哨兵架构。主从架构是哨兵架构以及后续的分布式集群架构的基础。","covers":["../../../../img/redisCommand-sentinel/image-20201102105859265.png","../../../../img/redisCommand-sentinel/image-20201102110501109.png","../../../../img/redisCommand-sentinel/image-20201102110615982.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p>Redis数据持久化的三种方式，基本的架构模型，主从架构和哨兵架构。主从架构是哨兵架构以及后续的分布式集群架构的基础。<a id=\"more\"></a></p>\n<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><h3 id=\"RDB（Redis-DataBase）快照（snapShot）\"><a href=\"#RDB（Redis-DataBase）快照（snapShot）\" class=\"headerlink\" title=\"RDB（Redis DataBase）快照（snapShot）\"></a>RDB（Redis DataBase）快照（snapShot）</h3><p>基本设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在redis配置文件中做如下配置即可，redis在满足配置时就会自动进行持久化到本地文件中</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 60秒内至少改动1000个键值对，就会触发</span></span><br><span class=\"line\">save 60 1000 </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 保存的为二进制内容</span></span><br></pre></td></tr></table></figure>\n<p>save和bgsave</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>save</th>\n<th>bgsave</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IO类型</td>\n<td>同步</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>是否阻塞Redis其他命令</td>\n<td>是（操作时会阻塞，所有命令无法继续写入）</td>\n<td>否（生成子进程执行调用fork函数时，会有短暂阻塞）</td>\n</tr>\n<tr>\n<td>复杂度</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>不会消耗额外内存</td>\n<td>不阻塞客户端命令</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>阻塞客户端命令</td>\n<td>需要fork子进程，消耗内存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。 </p>\n<p>2、容灾性好，方便备份。 </p>\n<p>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进 程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 </p>\n<p>4、相对于数据集大时，比 AOF 的启动效率更高。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢 失。所以这种方式更适合数据要求不严谨的时候) </p>\n<p>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导 致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>\n<h3 id=\"AOF-append-only-file\"><a href=\"#AOF-append-only-file\" class=\"headerlink\" title=\"AOF(append-only file)\"></a>AOF(append-only file)</h3><p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 具体配置项说明</span></span><br><span class=\"line\">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class=\"line\">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</span><br><span class=\"line\">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure>\n<p>aof保存的是最新的set操作命令<sunfy-line></p>\n<h3 id=\"AOF（Append-Only-File）重写\"><a href=\"#AOF（Append-Only-File）重写\" class=\"headerlink\" title=\"AOF（Append Only File）重写\"></a>AOF（Append Only File）重写</h3><p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以 打开文件看到详细的操作记录。</p>\n<p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof重写会将一些无用命令重新合并，最终数据肯定还是和原先的一致</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</span></span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb   </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure>\n<p>AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF</p>\n<p>注意，<strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p>\n<h3 id=\"RDB和AOF对比\"><a href=\"#RDB和AOF对比\" class=\"headerlink\" title=\"RDB和AOF对比\"></a>RDB和AOF对比</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>RDB</strong></th>\n<th><strong>AOF</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>容易丢数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也 是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据 将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁 盘中。</p>\n<p> 2、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题。 </p>\n<p>3、AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、AOF 文件比 RDB 文件大，且恢复速度慢。 </p>\n<p>2、数据集大的时候，比 rdb 启动效率低。 </p>\n<p>3、运行效率没有RDB高 </p>\n<p>AOF文件比RDB更新频率高，优先使用AOF还原数据。 </p>\n<p>AOF比RDB更安全也更大 </p>\n<p>RDB性能比AOF好 </p>\n<p>如果两个都配了优先加载AOF</p>\n<h3 id=\"Redis4-0后的混合持久化\"><a href=\"#Redis4-0后的混合持久化\" class=\"headerlink\" title=\"Redis4.0后的混合持久化\"></a>Redis4.0后的混合持久化</h3><p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 混合持久化是基于aof持久化的优化，使用混合持久化必须先开启aof</span></span><br><span class=\"line\">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis数据备份策略\"><a href=\"#Redis数据备份策略\" class=\"headerlink\" title=\"Redis数据备份策略\"></a>Redis数据备份策略</h3><ol>\n<li>写crontab定时脚本，每个小时复制一份Redis持久化文件</li>\n<li>每天都保留一份数据，保留最新一月或根据需求保存，方便可随时恢复至任意日期</li>\n<li>每天复制数据时，删除最早数据，以免浪费内存</li>\n<li>多机备份，定期将备份文件复制只不同数据备份机器</li>\n</ol>\n<p>Redis数据恢复</p>\n<p>将Reids备份文件，放在Redis对应的备份文件路径下重启服务即可</p>\n<h2 id=\"Redis主从架构\"><a href=\"#Redis主从架构\" class=\"headerlink\" title=\"Redis主从架构\"></a>Redis主从架构</h2><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102105859265.png\" alt=\"image-20201102105859265\"></p>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、复制一份redis.conf文件</span><br><span class=\"line\">2、将相关配置修改为如下值：</span><br><span class=\"line\">port 6380</span><br><span class=\"line\">pidfile /var/run/redis_6380.pid  # 把pid进程号写入pidfile配置的文件</span><br><span class=\"line\">logfile \"6380.log\"</span><br><span class=\"line\">dir /usr/local/redis-5.0.3/data/6380  # 指定数据存放目录</span><br><span class=\"line\">3、配置主从复制</span><br><span class=\"line\">replicaof 192.168.0.60 6379   # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class=\"line\">replica-read-only yes  # 配置从节点只读</span><br><span class=\"line\">4、启动从节点</span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\">5、连接从节点</span><br><span class=\"line\">redis-cli -p 6380</span><br><span class=\"line\">6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据</span><br><span class=\"line\">7、可以自己再配置一个6381的从节点</span><br></pre></td></tr></table></figure>\n<h3 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h3><p>从节点首次同步数据或长时间断开链接，主节点和从节点之前数据差超过了master节点缓存队列中的数据时会采用全量复制</p>\n<h3 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h3><p>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。</p>\n<h3 id=\"主从复制风暴\"><a href=\"#主从复制风暴\" class=\"headerlink\" title=\"主从复制风暴\"></a>主从复制风暴</h3><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102110501109.png\" alt=\"image-20201102110501109\"></p>\n<h2 id=\"Redis哨兵高可用架构\"><a href=\"#Redis哨兵高可用架构\" class=\"headerlink\" title=\"Redis哨兵高可用架构\"></a>Redis哨兵高可用架构</h2><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102110615982.png\" alt=\"image-20201102110615982\"></p>\n<p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、复制一份sentinel.conf文件</span><br><span class=\"line\">cp sentinel.conf sentinel-26379.conf</span><br><span class=\"line\">2、将相关配置修改为如下值：</span><br><span class=\"line\">port 26379</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\">pidfile \"/var/run/redis-sentinel-26379.pid\"</span><br><span class=\"line\">logfile \"26379.log\"</span><br><span class=\"line\">dir \"/usr/local/redis-5.0.3/data\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span></span><br><span class=\"line\">sentinel monitor mymaster 192.168.0.60 6379 2   # mymaster这个名字随便取，客户端访问时会用到</span><br><span class=\"line\">3、启动sentinel哨兵实例</span><br><span class=\"line\">src/redis-sentinel sentinel-26379.conf</span><br><span class=\"line\">4、查看sentinel的info信息</span><br><span class=\"line\">src/redis-cli -p 26379</span><br><span class=\"line\">127.0.0.1:26379&gt;info</span><br><span class=\"line\">可以看到Sentinel的info里已经识别出了redis的主从</span><br><span class=\"line\">5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改</span><br></pre></td></tr></table></figure>\n<h2 id=\"操作中遇到的问题\"><a href=\"#操作中遇到的问题\" class=\"headerlink\" title=\"操作中遇到的问题\"></a>操作中遇到的问题</h2><ol>\n<li>配置主从模式时，要注意主节点不能配置replicaof</li>\n<li>bind 0.0.0.0</li>\n</ol>\n","more":"</p>\n<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><h3 id=\"RDB（Redis-DataBase）快照（snapShot）\"><a href=\"#RDB（Redis-DataBase）快照（snapShot）\" class=\"headerlink\" title=\"RDB（Redis DataBase）快照（snapShot）\"></a>RDB（Redis DataBase）快照（snapShot）</h3><p>基本设置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在redis配置文件中做如下配置即可，redis在满足配置时就会自动进行持久化到本地文件中</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 60秒内至少改动1000个键值对，就会触发</span></span><br><span class=\"line\">save 60 1000 </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 保存的为二进制内容</span></span><br></pre></td></tr></table></figure>\n<p>save和bgsave</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>save</th>\n<th>bgsave</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IO类型</td>\n<td>同步</td>\n<td>异步</td>\n</tr>\n<tr>\n<td>是否阻塞Redis其他命令</td>\n<td>是（操作时会阻塞，所有命令无法继续写入）</td>\n<td>否（生成子进程执行调用fork函数时，会有短暂阻塞）</td>\n</tr>\n<tr>\n<td>复杂度</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>不会消耗额外内存</td>\n<td>不阻塞客户端命令</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>阻塞客户端命令</td>\n<td>需要fork子进程，消耗内存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。 </p>\n<p>2、容灾性好，方便备份。 </p>\n<p>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进 程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 </p>\n<p>4、相对于数据集大时，比 AOF 的启动效率更高。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢 失。所以这种方式更适合数据要求不严谨的时候) </p>\n<p>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导 致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>\n<h3 id=\"AOF-append-only-file\"><a href=\"#AOF-append-only-file\" class=\"headerlink\" title=\"AOF(append-only file)\"></a>AOF(append-only file)</h3><p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 具体配置项说明</span></span><br><span class=\"line\">appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</span><br><span class=\"line\">appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</span><br><span class=\"line\">appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure>\n<p>aof保存的是最新的set操作命令<sunfy-line></p>\n<h3 id=\"AOF（Append-Only-File）重写\"><a href=\"#AOF（Append-Only-File）重写\" class=\"headerlink\" title=\"AOF（Append Only File）重写\"></a>AOF（Append Only File）重写</h3><p>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以 打开文件看到详细的操作记录。</p>\n<p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof重写会将一些无用命令重新合并，最终数据肯定还是和原先的一致</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</span></span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb   </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> aof文件自上一次重写后文件大小增长了100%则再次触发重写</span></span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure>\n<p>AOF还可以手动重写，进入redis客户端执行命令<strong>bgrewriteaof</strong>重写AOF</p>\n<p>注意，<strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p>\n<h3 id=\"RDB和AOF对比\"><a href=\"#RDB和AOF对比\" class=\"headerlink\" title=\"RDB和AOF对比\"></a>RDB和AOF对比</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>RDB</strong></th>\n<th><strong>AOF</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>容易丢数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也 是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据 将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁 盘中。</p>\n<p> 2、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题。 </p>\n<p>3、AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、AOF 文件比 RDB 文件大，且恢复速度慢。 </p>\n<p>2、数据集大的时候，比 rdb 启动效率低。 </p>\n<p>3、运行效率没有RDB高 </p>\n<p>AOF文件比RDB更新频率高，优先使用AOF还原数据。 </p>\n<p>AOF比RDB更安全也更大 </p>\n<p>RDB性能比AOF好 </p>\n<p>如果两个都配了优先加载AOF</p>\n<h3 id=\"Redis4-0后的混合持久化\"><a href=\"#Redis4-0后的混合持久化\" class=\"headerlink\" title=\"Redis4.0后的混合持久化\"></a>Redis4.0后的混合持久化</h3><p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 混合持久化是基于aof持久化的优化，使用混合持久化必须先开启aof</span></span><br><span class=\"line\">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>\n<h3 id=\"Redis数据备份策略\"><a href=\"#Redis数据备份策略\" class=\"headerlink\" title=\"Redis数据备份策略\"></a>Redis数据备份策略</h3><ol>\n<li>写crontab定时脚本，每个小时复制一份Redis持久化文件</li>\n<li>每天都保留一份数据，保留最新一月或根据需求保存，方便可随时恢复至任意日期</li>\n<li>每天复制数据时，删除最早数据，以免浪费内存</li>\n<li>多机备份，定期将备份文件复制只不同数据备份机器</li>\n</ol>\n<p>Redis数据恢复</p>\n<p>将Reids备份文件，放在Redis对应的备份文件路径下重启服务即可</p>\n<h2 id=\"Redis主从架构\"><a href=\"#Redis主从架构\" class=\"headerlink\" title=\"Redis主从架构\"></a>Redis主从架构</h2><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102105859265.png\" alt=\"image-20201102105859265\"></p>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、复制一份redis.conf文件</span><br><span class=\"line\">2、将相关配置修改为如下值：</span><br><span class=\"line\">port 6380</span><br><span class=\"line\">pidfile /var/run/redis_6380.pid  # 把pid进程号写入pidfile配置的文件</span><br><span class=\"line\">logfile \"6380.log\"</span><br><span class=\"line\">dir /usr/local/redis-5.0.3/data/6380  # 指定数据存放目录</span><br><span class=\"line\">3、配置主从复制</span><br><span class=\"line\">replicaof 192.168.0.60 6379   # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class=\"line\">replica-read-only yes  # 配置从节点只读</span><br><span class=\"line\">4、启动从节点</span><br><span class=\"line\">redis-server redis.conf</span><br><span class=\"line\">5、连接从节点</span><br><span class=\"line\">redis-cli -p 6380</span><br><span class=\"line\">6、测试在6379实例上写数据，6380实例是否能及时同步新修改数据</span><br><span class=\"line\">7、可以自己再配置一个6381的从节点</span><br></pre></td></tr></table></figure>\n<h3 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h3><p>从节点首次同步数据或长时间断开链接，主节点和从节点之前数据差超过了master节点缓存队列中的数据时会采用全量复制</p>\n<h3 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h3><p>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。</p>\n<h3 id=\"主从复制风暴\"><a href=\"#主从复制风暴\" class=\"headerlink\" title=\"主从复制风暴\"></a>主从复制风暴</h3><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102110501109.png\" alt=\"image-20201102110501109\"></p>\n<h2 id=\"Redis哨兵高可用架构\"><a href=\"#Redis哨兵高可用架构\" class=\"headerlink\" title=\"Redis哨兵高可用架构\"></a>Redis哨兵高可用架构</h2><p><img src=\"../../../../img/redisCommand-sentinel/image-20201102110615982.png\" alt=\"image-20201102110615982\"></p>\n<p>基本配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、复制一份sentinel.conf文件</span><br><span class=\"line\">cp sentinel.conf sentinel-26379.conf</span><br><span class=\"line\">2、将相关配置修改为如下值：</span><br><span class=\"line\">port 26379</span><br><span class=\"line\">daemonize yes</span><br><span class=\"line\">pidfile \"/var/run/redis-sentinel-26379.pid\"</span><br><span class=\"line\">logfile \"26379.log\"</span><br><span class=\"line\">dir \"/usr/local/redis-5.0.3/data\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span></span><br><span class=\"line\">sentinel monitor mymaster 192.168.0.60 6379 2   # mymaster这个名字随便取，客户端访问时会用到</span><br><span class=\"line\">3、启动sentinel哨兵实例</span><br><span class=\"line\">src/redis-sentinel sentinel-26379.conf</span><br><span class=\"line\">4、查看sentinel的info信息</span><br><span class=\"line\">src/redis-cli -p 26379</span><br><span class=\"line\">127.0.0.1:26379&gt;info</span><br><span class=\"line\">可以看到Sentinel的info里已经识别出了redis的主从</span><br><span class=\"line\">5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改</span><br></pre></td></tr></table></figure>\n<h2 id=\"操作中遇到的问题\"><a href=\"#操作中遇到的问题\" class=\"headerlink\" title=\"操作中遇到的问题\"></a>操作中遇到的问题</h2><ol>\n<li>配置主从模式时，要注意主节点不能配置replicaof</li>\n<li>bind 0.0.0.0</li>\n</ol>","next":{"title":"MyBatis源码编译环境构建","path":"api/articles/resource-ORM-MyBatis-MyBatisResourceBuild.json","image":"/img/header_img/17.gif","num_read":245,"num_like":875,"num_collection":384,"num_comments":146},"prev":{"title":"CentOS、windows安装MySql5.7","path":"api/articles/resource-DB-MySQL-MySQl-install.json","image":"/img/header_img/DB/mysql.jpg","num_read":652,"num_like":344,"num_collection":322,"num_comments":48},"categories":[{"name":"分布式中间件","path":"api/categories/分布式中间件.json","pathContent":"api/categories/分布式中间件","description":"包含Zookeeper、Redis、等相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}],"tags":[{"name":"Redis","path":"api/tags/Redis.json","pathContent":"api/tags/Redis","description":"[Redis]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}