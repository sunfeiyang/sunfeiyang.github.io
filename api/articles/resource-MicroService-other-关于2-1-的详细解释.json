{"title":"关于2>&1 &的详细解释","num_read":208,"num_like":195,"num_collection":80,"num_comments":179,"slug":"resource-MicroService-other-关于2-1-的详细解释","date":"2022-07-08T16:00:00.000Z","img":"/img/header_img/MicroService/MicroService.PNG","format":"list","_id":"clhrbp2e000cgo5lgc0ap37m5","project":"MicroService","subtitle":"0，1，2三个数字分别代表STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO","site":{"data":{}},"updated":"2022-08-19T01:13:22.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-MicroService-other-关于2-1-的详细解释.json","webPath":"2022/07/09/resource-MicroService-other-关于2-1-的详细解释/","permalink":"https://sunfy9.gitee.io/2022/07/09/resource-MicroService-other-%E5%85%B3%E4%BA%8E2-1-%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<p>1、首先，理解一下0 1 2在bash中分别代表的含义</p>\n<ul>\n<li>0：STDIN_FILENO    标准输入（一般是键盘）</li>\n<li>1：STDOUT_FILENO   标准输出（一般是显示屏，准确的说是用户终端控制台）</li>\n<li>2：STDERR_FILENO    标准错误（出错信息输出）</li>\n</ul>\n<p>2、输入输出可以<a href=\"https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">重定向</a>，所谓重定向输入就是在命令中指定具体的输入来源，譬如 cat &lt; test.c 将test.c重定向为cat命令的输入源。输出重定向是指定具体的输出目标以替换默认的标准输出，譬如ls &gt; 1.txt将ls的结果从标准输出重定向为1.txt文本。有时候会看到如 ls &gt;&gt; 1.txt这类的写法，&gt; 和 &gt;&gt; 的区别在于：&gt; 用于新建而&gt;&gt;用于追加。即ls &gt; 1.txt会新建一个1.txt文件并且将ls的内容输出到新建的1.txt中，而ls &gt;&gt; 1.txt则用在1.txt已经存在，而我们只是想将ls的内容追加到1.txt文本中的时候。</p>\n<p>3、默认输入只有一个（0，STDIN_FILENO），而默认输出有两个（标准输出1 STDOUT_FILENO，标准错误2 STDERR_FILENO）。因此默认情况下，shell输出的错误信息会被输出到2，而普通输出信息会输出到1。但是某些情况下，我们希望在一个终端下看到所有的信息（包括标准输出信息和错误信息），要怎么办呢？</p>\n<p>输出重定向。思路有了，怎么写呢？ 非常直观的想法就是2&gt;1（将2重定向到1嘛），行不行呢？试一试就知道了。我们进行以下测试步骤：</p>\n<ul>\n<li>1）mkdir test &amp;&amp; cd test; 创建test文件夹并进入test目录</li>\n<li>2）touch a.txt b.c c; 创建a.txt b.c c 三个文件</li>\n<li>3）ls &gt; 1 ; 按我们的猜测，这句应该是将ls的结果重定向到标准输出，因此效果和直接ls应该一样。但是实际这句执行后，标准输出中并没有任何信息。</li>\n<li>4）ls; 执行3之后再次ls，则会看到test文件夹中多了一个文件1</li>\n<li>5）cat 1; 查看文件1的内容，实际结果为：1 a.txt b.c c   可见步骤3中 ls &gt; 1并不是将ls的结果重定向为标准输出，而是将结果重定向到了一个文件1中。即1在此处不被解释为STDOUT_FILENO，而是文件1。</li>\n</ul>\n<p>4、到了此时，你应该也能猜到2&gt;&amp;1的用意了。不错，2&gt;&amp;1就是用来将标准错误2重定向到标准输出1中的。此处1前面的&amp;就是为了让bash将1解释成标准输出而不是文件1。至于最后一个&amp;，则是让bash在后台执行。</p>\n","more":"<p>1、首先，理解一下0 1 2在bash中分别代表的含义</p>\n<ul>\n<li>0：STDIN_FILENO    标准输入（一般是键盘）</li>\n<li>1：STDOUT_FILENO   标准输出（一般是显示屏，准确的说是用户终端控制台）</li>\n<li>2：STDERR_FILENO    标准错误（出错信息输出）</li>\n</ul>\n<p>2、输入输出可以<a href=\"https://so.csdn.net/so/search?q=重定向&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">重定向</a>，所谓重定向输入就是在命令中指定具体的输入来源，譬如 cat &lt; test.c 将test.c重定向为cat命令的输入源。输出重定向是指定具体的输出目标以替换默认的标准输出，譬如ls &gt; 1.txt将ls的结果从标准输出重定向为1.txt文本。有时候会看到如 ls &gt;&gt; 1.txt这类的写法，&gt; 和 &gt;&gt; 的区别在于：&gt; 用于新建而&gt;&gt;用于追加。即ls &gt; 1.txt会新建一个1.txt文件并且将ls的内容输出到新建的1.txt中，而ls &gt;&gt; 1.txt则用在1.txt已经存在，而我们只是想将ls的内容追加到1.txt文本中的时候。</p>\n<p>3、默认输入只有一个（0，STDIN_FILENO），而默认输出有两个（标准输出1 STDOUT_FILENO，标准错误2 STDERR_FILENO）。因此默认情况下，shell输出的错误信息会被输出到2，而普通输出信息会输出到1。但是某些情况下，我们希望在一个终端下看到所有的信息（包括标准输出信息和错误信息），要怎么办呢？</p>\n<p>输出重定向。思路有了，怎么写呢？ 非常直观的想法就是2&gt;1（将2重定向到1嘛），行不行呢？试一试就知道了。我们进行以下测试步骤：</p>\n<ul>\n<li>1）mkdir test &amp;&amp; cd test; 创建test文件夹并进入test目录</li>\n<li>2）touch a.txt b.c c; 创建a.txt b.c c 三个文件</li>\n<li>3）ls &gt; 1 ; 按我们的猜测，这句应该是将ls的结果重定向到标准输出，因此效果和直接ls应该一样。但是实际这句执行后，标准输出中并没有任何信息。</li>\n<li>4）ls; 执行3之后再次ls，则会看到test文件夹中多了一个文件1</li>\n<li>5）cat 1; 查看文件1的内容，实际结果为：1 a.txt b.c c   可见步骤3中 ls &gt; 1并不是将ls的结果重定向为标准输出，而是将结果重定向到了一个文件1中。即1在此处不被解释为STDOUT_FILENO，而是文件1。</li>\n</ul>\n<p>4、到了此时，你应该也能猜到2&gt;&amp;1的用意了。不错，2&gt;&amp;1就是用来将标准错误2重定向到标准输出1中的。此处1前面的&amp;就是为了让bash将1解释成标准输出而不是文件1。至于最后一个&amp;，则是让bash在后台执行。</p>\n","next":{"title":"SQLSERVER数据库事务隔离级别","path":"api/articles/resource-DB-SQLServer-事务隔离级别.json","image":"/img/header_img/DB/Transactionisolationlevel.png","num_read":778,"num_like":891,"num_collection":845,"num_comments":54},"prev":{"title":"TCP 为什么要三次握手?","path":"api/articles/resource-RPC-Base-TCP三次握手.json","image":"/img/header_img/rpc/tcp三次握手.png","num_read":336,"num_like":1009,"num_collection":39,"num_comments":148},"categories":[{"name":"微服务","path":"api/categories/微服务.json","pathContent":"api/categories/微服务","description":"一种云原生框架方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成","cover":"https://sunfy9.gitee.io/project/photo/project/MicroService.PNG"}],"tags":[{"name":"algorithm","path":"api/tags/algorithm.json","pathContent":"api/tags/algorithm","description":"[algorithm]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}