{"title":"数据结构测试题---字符串","num_read":475,"num_like":466,"num_collection":248,"num_comments":236,"slug":"resource-dataStructure-leetcode-leetcode-str","date":"2021-08-28T16:00:00.000Z","img":"/img/header_img/10.jpg","_id":"clhrbp2al0001o5lgb76y7o5b","project":"dataStructure","site":{"data":{}},"updated":"2022-01-15T04:11:32.000Z","comments":true,"path":"api/articles/resource-dataStructure-leetcode-leetcode-str.json","webPath":"2021/08/29/resource-dataStructure-leetcode-leetcode-str/","permalink":"https://sunfy9.gitee.io/2021/08/29/resource-dataStructure-leetcode-leetcode-str/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"387-字符串中的第一个唯一字符\"><a href=\"#387-字符串中的第一个唯一字符\" class=\"headerlink\" title=\"387. 字符串中的第一个唯一字符\"></a><a href=\"https://leetcode-cn.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">387. 字符串中的第一个唯一字符</a></h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;leetcode&quot;</span><br><span class=\"line\">返回 0</span><br><span class=\"line\">s &#x3D; &quot;loveleetcode&quot;</span><br><span class=\"line\">返回 2</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p>\n<h2 id=\"方法一：使用哈希表存储频数\"><a href=\"#方法一：使用哈希表存储频数\" class=\"headerlink\" title=\"方法一：使用哈希表存储频数\"></a>方法一：使用哈希表存储频数</h2><p>思路与算法</p>\n<p>我们可以对字符串进行两次遍历。</p>\n<p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 <code>-1</code>。<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; frequency = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            frequency.put(ch, frequency.getOrDefault(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (frequency.get(s.charAt(i)) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们需要进行两次遍历。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此 <code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code> 的空间存储哈希映射。</li>\n</ul>\n<h2 id=\"方法二：使用哈希表存储索引\"><a href=\"#方法二：使用哈希表存储索引\" class=\"headerlink\" title=\"方法二：使用哈希表存储索引\"></a>方法二：使用哈希表存储索引</h2><p>思路与算法</p>\n<p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p>\n<p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 cc 不在哈希映射中，我们就将 cc 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 -1。</p>\n<p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引。如果哈希映射中的所有值均为 -1，我们就返回 -1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; position = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (position.containsKey(ch)) &#123;</span><br><span class=\"line\">                position.put(ch, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                position.put(ch, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = n;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Character, Integer&gt; entry : position.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pos = entry.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos != -<span class=\"number\">1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class=\"line\">                first = pos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == n) &#123;</span><br><span class=\"line\">            first = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。第一次遍历字符串的时间复杂度为 <code>O(n)</code>，第二次遍历哈希映射的时间复杂度为 <code>O(∣Σ∣)</code>，由于 <code>s</code> 包含的字符种类数一定小于 <code>s</code> 的长度，因此 <code>O(∣Σ∣)</code> 在渐进意义下小于 <code>O(n)</code>，可以忽略。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此 <code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code>的空间存储哈希映射。</li>\n</ul>\n<h2 id=\"方法三：队列\"><a href=\"#方法三：队列\" class=\"headerlink\" title=\"方法三：队列\"></a>方法三：队列</h2><p>思路与算法</p>\n<p>我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。</p>\n<p>具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 <code>c</code>，如果 <code>c</code> 不在哈希映射中，我们就将 <code>c</code> 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 <code>-1</code>）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。</p>\n<p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回 <code>-1</code>，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p>\n<p>小贴士</p>\n<p>在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; position = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        Queue&lt;Pair&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;Pair&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!position.containsKey(ch)) &#123;</span><br><span class=\"line\">                position.put(ch, i);</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> Pair(ch, i));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                position.put(ch, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!queue.isEmpty() &amp;&amp; position.get(queue.peek().ch) == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    queue.poll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.isEmpty() ? -<span class=\"number\">1</span> : queue.poll().pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        Pair(<span class=\"keyword\">char</span> ch, <span class=\"keyword\">int</span> pos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.ch = ch;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.pos = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。遍历字符串的时间复杂度为 <code>O(n)</code>，而在遍历的过程中我们还维护了一个队列，由于每一个字符最多只会被放入和弹出队列最多各一次，因此维护队列的总时间复杂度为 <code>O(∣Σ∣)</code>，由于 <code>s</code> 包含的字符种类数一定小于 <code>s</code> 的长度，因此 <code>O(∣Σ∣)</code> 在渐进意义下小于 <code>O(n)</code>，可以忽略。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此<code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code> 的空间存储哈希映射以及队列。</li>\n</ul>\n<h1 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a><a href=\"https://leetcode-cn.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">383. 赎金信</a></h1><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>\n<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：ransomNote = \"a\", magazine = \"b\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：ransomNote = \"aa\", magazine = \"ab\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：ransomNote = \"aa\", magazine = \"aab\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">你可以假设两个字符串均只含有小写字母。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>s.find(s[i]) : 返回字符串s中从左向右查找s[i]第一次出现的位置；<br>题目中已说明两个字符串均只含小写字母，因此，只需在magazine字符串中检索ransomNote字符串中的每一个字符，magazine中检索过的字符进行标记即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canConstruct</span><span class=\"params\">(<span class=\"built_in\">string</span> ransomNote, <span class=\"built_in\">string</span> magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ransomNote.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = magazine.<span class=\"built_in\">find</span>(ransomNote[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                magazine[a] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><p>救赎信必须由杂志的内容组成，并且不能重复使用字母。由此可知，每一个字母在救赎信中的出现次数必须小于等于该字母在杂志中出现的次数。<br>常规情况下使用 HashMap 统计出现次数，字母为 key（键），出现次数为 value（值）。但是本题只有小写字母出现，则可以使用一个长度为 26 的数组代替 HashMap，以达到加速程序的目的。</p>\n<p>在参考代码中，使用 0-25 为下标的数组，代替’a’-‘z’为 key 的 map。<br><code>charCountRN[cc-&#39;a&#39;]</code>中 [cc-‘a’] 是一个数组的下标，需要是一个int整数，cc-‘a’即可得到相对应的下标。<br>举例，’b’对应的0-25中的1，’b’-‘a’=1，此处字符之间的减法是计算字符ASCII值的差值。 <a href=\"https://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">ASCII表参考</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 新建小写字母频次统计数组，0-25 分别代表 a-z</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charCountRN = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charCountM = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 将 String 转化成 char[] 可以加速程序，因为 String.charAt() 每次调用都会检查下标是否越界</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArrayRN = ransomNote.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArrayM = magazine.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 统计救赎信的各个字母出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : charArrayRN) &#123;</span><br><span class=\"line\">            charCountRN[c-<span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 统计杂志的各个字母出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : charArrayM) &#123;</span><br><span class=\"line\">            charCountM[c-<span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 对每个字母的出现次数进行比较</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(charCountRN[i] &gt; charCountM[i])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242. 有效的字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">242. 有效的字母异位词</a></h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>\n<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: s = \"anagram\", t = \"nagaram\"</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: s = \"rat\", t = \"car\"</span><br><span class=\"line\">输出: false</span><br><span class=\"line\"></span><br><span class=\"line\">提示:</span><br><span class=\"line\">1 &lt;= s.length, t.length &lt;= 5 * 104</span><br><span class=\"line\">s 和 t 仅包含小写字母</span><br><span class=\"line\"> </span><br><span class=\"line\">进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：排序\"><a href=\"#方法一：排序\" class=\"headerlink\" title=\"方法一：排序\"></a>方法一：排序</h2><p><code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 <code>s</code> 和 <code>t</code> 分别排序，看排序后的字符串是否相等即可判断。此外，如果 <code>s</code> 和 <code>t</code> 的长度不同，<code>t</code> 必然不是 <code>s</code> 的异位词。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] str1 = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] str2 = t.toCharArray();</span><br><span class=\"line\">        Arrays.sort(str1);</span><br><span class=\"line\">        Arrays.sort(str2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.equals(str1, str2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(nlogn)</code>，其中 <code>n</code> 为 <code>s</code> 的长度。排序的时间复杂度为 <code>O(nlogn)</code>，比较两个字符串是否相等时间复杂度为 <code>O(n)</code>，因此总体时间复杂度为<code>O(nlogn+n)=O(nlogn)</code>。</li>\n</ul>\n<ul>\n<li>空间复杂度：<code>O(logn)</code>。排序需要 <code>O(logn)</code> 的空间复杂度。注意，在某些语言（比如 <code>Java</code> &amp; <code>JavaScript</code>）中字符串是不可变的，因此我们需要额外的 <code>O(n)</code> 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：<ul>\n<li>这依赖于语言的细节；</li>\n<li>这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h2><p>从另一个角度考虑，<code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <code>26</code> 个小写字母，因此我们可以维护一个长度为 <code>26</code> 的频次数组 <code>table</code>，先遍历记录字符串 <code>s</code> 中字符出现的频次，然后遍历字符串 <code>t</code>，减去 <code>table</code> 中对应的频次，如果出现 <code>table[i]&lt;0</code>，则说明 <code>t</code> 包含一个不在 <code>s</code> 中的额外字符，返回 <code>false</code> 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] table = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            table[s.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class=\"line\">            table[t.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[t.charAt(i) - <span class=\"string\">'a'</span>] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于进阶问题，<code>Unicode</code> 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 <code>Unicode</code> 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的<code>UTF−8</code> 和 <code>UTF−16</code> 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p>\n<p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 <code>Unicode</code> 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; table = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            table.put(ch, table.getOrDefault(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = t.charAt(i);</span><br><span class=\"line\">            table.put(ch, table.getOrDefault(ch, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table.get(ch) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为 <code>s</code> 的长度。</li>\n<li>空间复杂度：<code>O(S)</code>，其中 <code>S</code> 为字符集大小，此处 <code>S=26</code>。</li>\n</ul>\n","more":"<h1 id=\"387-字符串中的第一个唯一字符\"><a href=\"#387-字符串中的第一个唯一字符\" class=\"headerlink\" title=\"387. 字符串中的第一个唯一字符\"></a><a href=\"https://leetcode-cn.com/problems/first-unique-character-in-a-string/\" target=\"_blank\" rel=\"noopener\">387. 字符串中的第一个唯一字符</a></h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s &#x3D; &quot;leetcode&quot;</span><br><span class=\"line\">返回 0</span><br><span class=\"line\">s &#x3D; &quot;loveleetcode&quot;</span><br><span class=\"line\">返回 2</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p>\n<h2 id=\"方法一：使用哈希表存储频数\"><a href=\"#方法一：使用哈希表存储频数\" class=\"headerlink\" title=\"方法一：使用哈希表存储频数\"></a>方法一：使用哈希表存储频数</h2><p>思路与算法</p>\n<p>我们可以对字符串进行两次遍历。</p>\n<p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 <code>-1</code>。<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; frequency = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            frequency.put(ch, frequency.getOrDefault(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (frequency.get(s.charAt(i)) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。我们需要进行两次遍历。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此 <code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code> 的空间存储哈希映射。</li>\n</ul>\n<h2 id=\"方法二：使用哈希表存储索引\"><a href=\"#方法二：使用哈希表存储索引\" class=\"headerlink\" title=\"方法二：使用哈希表存储索引\"></a>方法二：使用哈希表存储索引</h2><p>思路与算法</p>\n<p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p>\n<p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 cc 不在哈希映射中，我们就将 cc 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 -1。</p>\n<p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引。如果哈希映射中的所有值均为 -1，我们就返回 -1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; position = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (position.containsKey(ch)) &#123;</span><br><span class=\"line\">                position.put(ch, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                position.put(ch, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = n;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Character, Integer&gt; entry : position.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pos = entry.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos != -<span class=\"number\">1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class=\"line\">                first = pos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == n) &#123;</span><br><span class=\"line\">            first = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。第一次遍历字符串的时间复杂度为 <code>O(n)</code>，第二次遍历哈希映射的时间复杂度为 <code>O(∣Σ∣)</code>，由于 <code>s</code> 包含的字符种类数一定小于 <code>s</code> 的长度，因此 <code>O(∣Σ∣)</code> 在渐进意义下小于 <code>O(n)</code>，可以忽略。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此 <code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code>的空间存储哈希映射。</li>\n</ul>\n<h2 id=\"方法三：队列\"><a href=\"#方法三：队列\" class=\"headerlink\" title=\"方法三：队列\"></a>方法三：队列</h2><p>思路与算法</p>\n<p>我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。</p>\n<p>具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 <code>c</code>，如果 <code>c</code> 不在哈希映射中，我们就将 <code>c</code> 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 <code>-1</code>）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。</p>\n<p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回 <code>-1</code>，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p>\n<p>小贴士</p>\n<p>在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstUniqChar</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; position = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        Queue&lt;Pair&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;Pair&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!position.containsKey(ch)) &#123;</span><br><span class=\"line\">                position.put(ch, i);</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> Pair(ch, i));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                position.put(ch, -<span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!queue.isEmpty() &amp;&amp; position.get(queue.peek().ch) == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    queue.poll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.isEmpty() ? -<span class=\"number\">1</span> : queue.poll().pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        Pair(<span class=\"keyword\">char</span> ch, <span class=\"keyword\">int</span> pos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.ch = ch;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.pos = pos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。遍历字符串的时间复杂度为 <code>O(n)</code>，而在遍历的过程中我们还维护了一个队列，由于每一个字符最多只会被放入和弹出队列最多各一次，因此维护队列的总时间复杂度为 <code>O(∣Σ∣)</code>，由于 <code>s</code> 包含的字符种类数一定小于 <code>s</code> 的长度，因此 <code>O(∣Σ∣)</code> 在渐进意义下小于 <code>O(n)</code>，可以忽略。</li>\n<li>空间复杂度：<code>O(∣Σ∣)</code>，其中 <code>Σ</code> 是字符集，在本题中 <code>s</code> 只包含小写字母，因此<code>∣Σ∣≤26</code>。我们需要 <code>O(∣Σ∣)</code> 的空间存储哈希映射以及队列。</li>\n</ul>\n<h1 id=\"383-赎金信\"><a href=\"#383-赎金信\" class=\"headerlink\" title=\"383. 赎金信\"></a><a href=\"https://leetcode-cn.com/problems/ransom-note/\" target=\"_blank\" rel=\"noopener\">383. 赎金信</a></h1><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>\n<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：ransomNote = \"a\", magazine = \"b\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：ransomNote = \"aa\", magazine = \"ab\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：ransomNote = \"aa\", magazine = \"aab\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">你可以假设两个字符串均只含有小写字母。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>s.find(s[i]) : 返回字符串s中从左向右查找s[i]第一次出现的位置；<br>题目中已说明两个字符串均只含小写字母，因此，只需在magazine字符串中检索ransomNote字符串中的每一个字符，magazine中检索过的字符进行标记即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canConstruct</span><span class=\"params\">(<span class=\"built_in\">string</span> ransomNote, <span class=\"built_in\">string</span> magazine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ransomNote.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = magazine.<span class=\"built_in\">find</span>(ransomNote[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                magazine[a] = <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><p>救赎信必须由杂志的内容组成，并且不能重复使用字母。由此可知，每一个字母在救赎信中的出现次数必须小于等于该字母在杂志中出现的次数。<br>常规情况下使用 HashMap 统计出现次数，字母为 key（键），出现次数为 value（值）。但是本题只有小写字母出现，则可以使用一个长度为 26 的数组代替 HashMap，以达到加速程序的目的。</p>\n<p>在参考代码中，使用 0-25 为下标的数组，代替’a’-‘z’为 key 的 map。<br><code>charCountRN[cc-&#39;a&#39;]</code>中 [cc-‘a’] 是一个数组的下标，需要是一个int整数，cc-‘a’即可得到相对应的下标。<br>举例，’b’对应的0-25中的1，’b’-‘a’=1，此处字符之间的减法是计算字符ASCII值的差值。 <a href=\"https://tool.oschina.net/commons?type=4\" target=\"_blank\" rel=\"noopener\">ASCII表参考</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 新建小写字母频次统计数组，0-25 分别代表 a-z</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charCountRN = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charCountM = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 将 String 转化成 char[] 可以加速程序，因为 String.charAt() 每次调用都会检查下标是否越界</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArrayRN = ransomNote.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArrayM = magazine.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 统计救赎信的各个字母出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : charArrayRN) &#123;</span><br><span class=\"line\">            charCountRN[c-<span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 统计杂志的各个字母出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : charArrayM) &#123;</span><br><span class=\"line\">            charCountM[c-<span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 对每个字母的出现次数进行比较</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(charCountRN[i] &gt; charCountM[i])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242. 有效的字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/valid-anagram/\" target=\"_blank\" rel=\"noopener\">242. 有效的字母异位词</a></h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>\n<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: s = \"anagram\", t = \"nagaram\"</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: s = \"rat\", t = \"car\"</span><br><span class=\"line\">输出: false</span><br><span class=\"line\"></span><br><span class=\"line\">提示:</span><br><span class=\"line\">1 &lt;= s.length, t.length &lt;= 5 * 104</span><br><span class=\"line\">s 和 t 仅包含小写字母</span><br><span class=\"line\"> </span><br><span class=\"line\">进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：排序\"><a href=\"#方法一：排序\" class=\"headerlink\" title=\"方法一：排序\"></a>方法一：排序</h2><p><code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 <code>s</code> 和 <code>t</code> 分别排序，看排序后的字符串是否相等即可判断。此外，如果 <code>s</code> 和 <code>t</code> 的长度不同，<code>t</code> 必然不是 <code>s</code> 的异位词。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] str1 = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] str2 = t.toCharArray();</span><br><span class=\"line\">        Arrays.sort(str1);</span><br><span class=\"line\">        Arrays.sort(str2);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.equals(str1, str2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(nlogn)</code>，其中 <code>n</code> 为 <code>s</code> 的长度。排序的时间复杂度为 <code>O(nlogn)</code>，比较两个字符串是否相等时间复杂度为 <code>O(n)</code>，因此总体时间复杂度为<code>O(nlogn+n)=O(nlogn)</code>。</li>\n</ul>\n<ul>\n<li>空间复杂度：<code>O(logn)</code>。排序需要 <code>O(logn)</code> 的空间复杂度。注意，在某些语言（比如 <code>Java</code> &amp; <code>JavaScript</code>）中字符串是不可变的，因此我们需要额外的 <code>O(n)</code> 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：<ul>\n<li>这依赖于语言的细节；</li>\n<li>这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h2><p>从另一个角度考虑，<code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <code>26</code> 个小写字母，因此我们可以维护一个长度为 <code>26</code> 的频次数组 <code>table</code>，先遍历记录字符串 <code>s</code> 中字符出现的频次，然后遍历字符串 <code>t</code>，减去 <code>table</code> 中对应的频次，如果出现 <code>table[i]&lt;0</code>，则说明 <code>t</code> 包含一个不在 <code>s</code> 中的额外字符，返回 <code>false</code> 即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] table = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            table[s.charAt(i) - <span class=\"string\">'a'</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class=\"line\">            table[t.charAt(i) - <span class=\"string\">'a'</span>]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table[t.charAt(i) - <span class=\"string\">'a'</span>] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于进阶问题，<code>Unicode</code> 是为了解决传统字符编码的局限性而产生的方案，它为每个语言中的字符规定了一个唯一的二进制编码。而 <code>Unicode</code> 中可能存在一个字符对应多个字节的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的<code>UTF−8</code> 和 <code>UTF−16</code> 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。</p>\n<p>回到本题，进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 <code>Unicode</code> 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() != t.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; table = <span class=\"keyword\">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            table.put(ch, table.getOrDefault(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = t.charAt(i);</span><br><span class=\"line\">            table.put(ch, table.getOrDefault(ch, <span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (table.get(ch) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为 <code>s</code> 的长度。</li>\n<li>空间复杂度：<code>O(S)</code>，其中 <code>S</code> 为字符集大小，此处 <code>S=26</code>。</li>\n</ul>\n","next":{"title":"分布式事务Seata使用及原理","path":"api/articles/resource-MicroService-seata-seataBase.json","image":"/img/header_img/MicroService/seata-install.png","num_read":141,"num_like":317,"num_collection":594,"num_comments":167},"prev":{"title":"数据结构测试题---链表","path":"api/articles/resource-dataStructure-leetcode-leetcode-list.json","image":"/img/header_img/dataStructure/list.jpg","num_read":941,"num_like":901,"num_collection":772,"num_comments":104},"categories":[{"name":"数据结构","path":"api/categories/数据结构.json","pathContent":"api/categories/数据结构","description":"一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。","cover":"https://sunfy9.gitee.io/project/photo/project/dataStructure.png"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json","pathContent":"api/tags/leetcode","description":"[leetcode]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}