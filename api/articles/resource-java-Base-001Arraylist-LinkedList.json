{"title":"Java面试题001-ArrayList和LinkedList区别","num_read":267,"num_like":375,"num_collection":216,"num_comments":236,"slug":"resource-java-Base-001Arraylist-LinkedList","date":"2021-07-12T16:00:00.000Z","img":"/img/header_img/1.jpg","_id":"clhrbp2du00b0o5lg5ra92tgi","subtitle":"底层数据结构--》适用场景--》相同点和不同点","site":{"data":{}},"updated":"2022-09-19T14:58:43.837Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-Base-001Arraylist-LinkedList.json","webPath":"2021/07/13/resource-java-Base-001Arraylist-LinkedList/","permalink":"https://sunfy9.gitee.io/2021/07/13/resource-java-Base-001Arraylist-LinkedList/","excerpt":null,"covers":["../../../../img/001Arraylist&amp;LinkedList/image-20210712112423871.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712112411812.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712112723040.png","../../../../img/001Arraylist&amp;LinkedList/1516809-20181023201007357-1981279990.gif","../../../../img/001Arraylist&amp;LinkedList/image-20210712113418978.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712113650183.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712115244051.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712115716970.png","../../../../img/001Arraylist&amp;LinkedList/image-20210712120040213.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p><strong>思路</strong></p>\n<p>底层数据结构—》适用场景—》相同点和不同点</p>\n<h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><p>他们的底层数据结构不同，<code>ArrayList</code>底层是基于数组实现的，连续内存存储，<code>LinkedList</code>底层是基于链表实现的，可以存储在分散的内存中。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>由于底层数据不同，他们所使用的场景也不同，<code>ArrayList</code>更适合随机查找，<code>LinkedList</code>更适合删除和添加，查询、添加删除的时间复杂度也不同。</p>\n<h2 id=\"其他相同点和不同点\"><a href=\"#其他相同点和不同点\" class=\"headerlink\" title=\"其他相同点和不同点\"></a>其他相同点和不同点</h2><p><code>ArrayList</code>和<code>LinkedList</code>都实现了List接口。</p>\n<p><code>LinkedList</code>还额外实现了<code>Deque</code>接口，所以<code>LinkedList</code>还可以当作双端队列来使用。</p>\n<h2 id=\"详细解释\"><a href=\"#详细解释\" class=\"headerlink\" title=\"详细解释\"></a>详细解释<sunfy-line></h2><p>查看-二者类的结构</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112423871.png\" alt=\"image-20210712112423871\"></p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112411812.png\" alt=\"image-20210712112411812\"></p>\n<p><code>LinkedList</code>实现了<code>Deque</code>接口，就包含了<code>addFirest</code>、<code>addLast</code>等队列的操作</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112723040.png\" alt=\"image-20210712112723040\"></p>\n<h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><p>数组模型图：</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/1516809-20181023201007357-1981279990.gif\" alt=\"img\"></p>\n<p>链表模型图：</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712113418978.png\" alt=\"image-20210712113418978\"></p>\n<h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3><p>​    <code>ArrayList.get(1)</code> 根据下标进行查询，因为数组是提前分配好的内存空间，可以直接根据下标查找，速度很快。</p>\n<p>​    <code>LinkedList.get(1)</code> 相对而言，链表根据指定下标进行查询时，需要遍历链表，逐个进行查找，直至所要查询的下标位置</p>\n<p>源码中看get操作：会发现，想要获取某个下标的值，需要从第一个开始进行遍历查找。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712113650183.png\" alt=\"image-20210712113650183\"></p>\n<p>二者这两个操作进行比较的话，<code>ArrayList</code>会相较<code>LinkedList</code>操作会快一些，但是<code>LinkedList</code>中有<code>getFirst()</code>和<code>getLast()</code>操作，这两个操作也是很快的，因为在<code>LinkedList</code>中通过last和first两个树形记录了两个元素的位置，获取时可以直接拿到，不需要遍历。</p>\n<h3 id=\"新增操作\"><a href=\"#新增操作\" class=\"headerlink\" title=\"新增操作\"></a>新增操作</h3><p>二者都有两个方法，</p>\n<p><code>ArrayList</code></p>\n<p>add(1) 直接增加一个元素，此时会将元素添加到最后一个元素。</p>\n<p>该方法正常添加数据都是很快的，但是存在一种情况是数组可能会需要扩容，如果数据要扩容的情况，添加元素的速率就会有些影响。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712115244051.png\" alt=\"image-20210712115244051\"></p>\n<p>add(1,1) 指定元素的位置进行添加。</p>\n<p>该方法通过指定元素添加，如果要插入下标的位置不存在元素，则直接进行添加，但是如果要插入元素的位置存在元素，则会存在已有元素的后移操作，相对而言速率不是很高的。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712115716970.png\" alt=\"image-20210712115716970\"></p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712120040213.png\" alt=\"image-20210712120040213\"></p>\n<p><code>LinkedList</code></p>\n<p>add(1) 直接增加一个元素，此时会将元素添加到最后一位，因为<code>LinkedList</code>底层采用的是链表结构，链表是不存在扩容操作的，所以相对来说add操作速度会比较快。</p>\n<p>add(1,1) 指定元素的位置进行添加。</p>\n<p>这个操作，效率取决于要插入元素的位置，如果要插入元素的位置比较大的时候，链表就需要逐个遍历之前的元素，此时效率也会有些影响的。</p>\n<p>对比二者的add(1,1)方法，<code>ArrayList</code>不需要查找待插入的位置，需要插入元素后移动后续的元素，<code>LinkedList</code>操作需要先遍历找到要插入的位置，而后插入元素。二者插入的性能来说是无法直接进行比较的，这个和具体数据存在关联。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果查询比较多的情况可以使用<code>ArrayList</code></p>\n<p>频繁进行插入数据的操作可以使用<code>LinkedList</code>，同时<code>LinkedList</code>可是当作一个双端队列进行使用。</p>\n","more":"<p><strong>思路</strong></p>\n<p>底层数据结构—》适用场景—》相同点和不同点</p>\n<h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><p>他们的底层数据结构不同，<code>ArrayList</code>底层是基于数组实现的，连续内存存储，<code>LinkedList</code>底层是基于链表实现的，可以存储在分散的内存中。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>由于底层数据不同，他们所使用的场景也不同，<code>ArrayList</code>更适合随机查找，<code>LinkedList</code>更适合删除和添加，查询、添加删除的时间复杂度也不同。</p>\n<h2 id=\"其他相同点和不同点\"><a href=\"#其他相同点和不同点\" class=\"headerlink\" title=\"其他相同点和不同点\"></a>其他相同点和不同点</h2><p><code>ArrayList</code>和<code>LinkedList</code>都实现了List接口。</p>\n<p><code>LinkedList</code>还额外实现了<code>Deque</code>接口，所以<code>LinkedList</code>还可以当作双端队列来使用。</p>\n<h2 id=\"详细解释\"><a href=\"#详细解释\" class=\"headerlink\" title=\"详细解释\"></a>详细解释<sunfy-line></h2><p>查看-二者类的结构</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112423871.png\" alt=\"image-20210712112423871\"></p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112411812.png\" alt=\"image-20210712112411812\"></p>\n<p><code>LinkedList</code>实现了<code>Deque</code>接口，就包含了<code>addFirest</code>、<code>addLast</code>等队列的操作</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712112723040.png\" alt=\"image-20210712112723040\"></p>\n<h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><p>数组模型图：</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/1516809-20181023201007357-1981279990.gif\" alt=\"img\"></p>\n<p>链表模型图：</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712113418978.png\" alt=\"image-20210712113418978\"></p>\n<h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3><p>​    <code>ArrayList.get(1)</code> 根据下标进行查询，因为数组是提前分配好的内存空间，可以直接根据下标查找，速度很快。</p>\n<p>​    <code>LinkedList.get(1)</code> 相对而言，链表根据指定下标进行查询时，需要遍历链表，逐个进行查找，直至所要查询的下标位置</p>\n<p>源码中看get操作：会发现，想要获取某个下标的值，需要从第一个开始进行遍历查找。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712113650183.png\" alt=\"image-20210712113650183\"></p>\n<p>二者这两个操作进行比较的话，<code>ArrayList</code>会相较<code>LinkedList</code>操作会快一些，但是<code>LinkedList</code>中有<code>getFirst()</code>和<code>getLast()</code>操作，这两个操作也是很快的，因为在<code>LinkedList</code>中通过last和first两个树形记录了两个元素的位置，获取时可以直接拿到，不需要遍历。</p>\n<h3 id=\"新增操作\"><a href=\"#新增操作\" class=\"headerlink\" title=\"新增操作\"></a>新增操作</h3><p>二者都有两个方法，</p>\n<p><code>ArrayList</code></p>\n<p>add(1) 直接增加一个元素，此时会将元素添加到最后一个元素。</p>\n<p>该方法正常添加数据都是很快的，但是存在一种情况是数组可能会需要扩容，如果数据要扩容的情况，添加元素的速率就会有些影响。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712115244051.png\" alt=\"image-20210712115244051\"></p>\n<p>add(1,1) 指定元素的位置进行添加。</p>\n<p>该方法通过指定元素添加，如果要插入下标的位置不存在元素，则直接进行添加，但是如果要插入元素的位置存在元素，则会存在已有元素的后移操作，相对而言速率不是很高的。</p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712115716970.png\" alt=\"image-20210712115716970\"></p>\n<p><img src=\"../../../../img/001Arraylist&amp;LinkedList/image-20210712120040213.png\" alt=\"image-20210712120040213\"></p>\n<p><code>LinkedList</code></p>\n<p>add(1) 直接增加一个元素，此时会将元素添加到最后一位，因为<code>LinkedList</code>底层采用的是链表结构，链表是不存在扩容操作的，所以相对来说add操作速度会比较快。</p>\n<p>add(1,1) 指定元素的位置进行添加。</p>\n<p>这个操作，效率取决于要插入元素的位置，如果要插入元素的位置比较大的时候，链表就需要逐个遍历之前的元素，此时效率也会有些影响的。</p>\n<p>对比二者的add(1,1)方法，<code>ArrayList</code>不需要查找待插入的位置，需要插入元素后移动后续的元素，<code>LinkedList</code>操作需要先遍历找到要插入的位置，而后插入元素。二者插入的性能来说是无法直接进行比较的，这个和具体数据存在关联。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果查询比较多的情况可以使用<code>ArrayList</code></p>\n<p>频繁进行插入数据的操作可以使用<code>LinkedList</code>，同时<code>LinkedList</code>可是当作一个双端队列进行使用。</p>\n","next":{"title":"算法常用的解题思路","path":"api/articles/resource-java-algorithm-800-algorithm.json","image":"/img/header_img/bg7.gif","num_read":1036,"num_like":231,"num_collection":572,"num_comments":187},"prev":{"title":"算法常用的解题思路---滑动窗口","path":"api/articles/resource-java-algorithm-801-SlidingWindow.json","image":"/img/header_img/interview/SlidingWindows.gif","num_read":748,"num_like":934,"num_collection":159,"num_comments":48},"categories":[{"name":"Java","path":"api/categories/Java.json","pathContent":"api/categories/Java","description":"知识点、常用功能","cover":"https://sunfy9.gitee.io/project/photo/project/java.png"}],"tags":[{"name":"Interview","path":"api/tags/Interview.json","pathContent":"api/tags/Interview","description":"面试题相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}