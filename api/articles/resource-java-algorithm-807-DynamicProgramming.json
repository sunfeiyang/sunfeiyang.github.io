{"title":"算法常用的解题思路---动态规划","num_read":363,"num_like":444,"num_collection":55,"num_comments":43,"slug":"resource-java-algorithm-807-DynamicProgramming","date":"2021-08-26T16:00:00.000Z","img":"/img/header_img/interview/DynamicProgramming.jpg","format":"max","_id":"clhrbp2di008bo5lg3e3d3f39","project":"algorithm","site":{"data":{}},"updated":"2022-10-28T08:30:36.588Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-algorithm-807-DynamicProgramming.json","webPath":"2021/08/27/resource-java-algorithm-807-DynamicProgramming/","permalink":"https://sunfy9.gitee.io/2021/08/27/resource-java-algorithm-807-DynamicProgramming/","excerpt":null,"covers":["../../../../img/807-DynamicProgramming/70_fig1.gif","../../../../img/807-DynamicProgramming/image-20210827083754854.png","../../../../img/807-DynamicProgramming/image-20210827083828286.png","../../../../img/807-DynamicProgramming/image-20210827083903421.png","../../../../img/807-DynamicProgramming/image-20210827084025122.png","../../../../img/807-DynamicProgramming/image-20210827084625905.png","../../../../img/807-DynamicProgramming/image-20210827084637588.png","../../../../img/807-DynamicProgramming/打家劫舍.gif","../../../../img/807-DynamicProgramming/image-20210827085638971.png","../../../../img/807-DynamicProgramming/image-20210827085653145.png","../../../../img/807-DynamicProgramming/image-20210827085706690.png","../../../../img/807-DynamicProgramming/image-20210827085734402.png","../../../../img/807-DynamicProgramming/image-20210827085752503.png","../../../../img/807-DynamicProgramming/image-20210827085929461.png","../../../../img/807-DynamicProgramming/image-20210827085949372.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a><a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin\" target=\"_blank\" rel=\"noopener\">动态规划</a></h1><blockquote>\n<p><strong>动态规划</strong>（Dynamic Programming，DP）是运筹学的一个分支，是求解<a href=\"https://baike.baidu.com/item/决策过程/6714639\" target=\"_blank\" rel=\"noopener\">决策过程</a>最优化的过程。20世纪50年代初，<a href=\"https://baike.baidu.com/item/美国/125486\" target=\"_blank\" rel=\"noopener\">美国</a>数学家<a href=\"https://baike.baidu.com/item/贝尔曼/9239579\" target=\"_blank\" rel=\"noopener\">贝尔曼</a>（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最<a href=\"https://baike.baidu.com/item/优化原理/949739\" target=\"_blank\" rel=\"noopener\">优化原理</a>，从而创立了动态规划。动态规划的应用极其广泛，包括<a href=\"https://baike.baidu.com/item/工程技术/6998399\" target=\"_blank\" rel=\"noopener\">工程技术</a>、经济、工业生产、军事以及<a href=\"https://baike.baidu.com/item/自动化控制/8483773\" target=\"_blank\" rel=\"noopener\">自动化控制</a>等领域，并在<a href=\"https://baike.baidu.com/item/背包问题/2416931\" target=\"_blank\" rel=\"noopener\">背包问题</a>、生产经营问题、资金管理问题、<a href=\"https://baike.baidu.com/item/资源分配问题/19135166\" target=\"_blank\" rel=\"noopener\">资源分配问题</a>、<a href=\"https://baike.baidu.com/item/最短路径问题/23162228\" target=\"_blank\" rel=\"noopener\">最短路径问题</a>和复杂系统可靠性问题等中取得了显著的效果 [1] 。 [2] </p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><strong>多阶段决策问题</strong></li>\n<li><strong>动态规划问题中的术语</strong><ul>\n<li><a href=\"https://baike.baidu.com/item/阶段\" target=\"_blank\" rel=\"noopener\">阶段</a></li>\n<li><a href=\"https://baike.baidu.com/item/状态\" target=\"_blank\" rel=\"noopener\">状态</a></li>\n<li><a href=\"https://baike.baidu.com/item/无后效性\" target=\"_blank\" rel=\"noopener\">无后效性</a></li>\n<li><a href=\"https://baike.baidu.com/item/决策\" target=\"_blank\" rel=\"noopener\">决策</a></li>\n<li><a href=\"https://baike.baidu.com/item/策略\" target=\"_blank\" rel=\"noopener\">策略</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><p>多阶段决策问题中，各个阶段采取的<a href=\"https://baike.baidu.com/item/决策\" target=\"_blank\" rel=\"noopener\">决策</a>，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。</p>\n<h2 id=\"适用条件\"><a href=\"#适用条件\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h2><ul>\n<li><strong><a href=\"https://baike.baidu.com/item/最优化原理\" target=\"_blank\" rel=\"noopener\">最优化原理</a></strong>（最优子结构性质）</li>\n<li><strong><a href=\"https://baike.baidu.com/item/无后效性\" target=\"_blank\" rel=\"noopener\">无后效性</a></strong></li>\n<li><strong>子问题的重叠性</strong></li>\n</ul>\n<h1 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70. 爬楼梯\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入： 2</span><br><span class=\"line\">输出： 2</span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶</span><br><span class=\"line\">2.  2 阶</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入： 3</span><br><span class=\"line\">输出： 3</span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶 + 1 阶</span><br><span class=\"line\">2.  1 阶 + 2 阶</span><br><span class=\"line\">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划\"><a href=\"#方法一：动态规划\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p>思路和算法</p>\n<p>我们用 f(x) 表示爬到第 xx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：</p>\n<p>f(x) = f(x - 1) + f(x - 2)</p>\n<p>它意味着爬到第 x 级台阶的方案数是爬到第 x - 1 级台阶的方案数和爬到第 x - 2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x - 1) 和 f(x - 2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p>\n<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 0 级开始爬的，所以从第 00 级爬到第 0 级我们可以看作只有一种方案，即 f(0) = 1；从第 0 级到第 1 级也只有一种方案，即爬一级，f(1) = 1。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到 f(2) = 2，f(3) = 3，f(4) = 5，……，我们把这些情况都枚举出来，发现计算的结果是正确的。</p>\n<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但是由于这里的 f(x) 只和 f(x - 1)与 f(x - 2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)。下面的代码中给出的就是这种实现。</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/70_fig1.gif\" alt=\"70_fig1\"><sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li>\n</ul>\n<h2 id=\"方法二：矩阵快速幂\"><a href=\"#方法二：矩阵快速幂\" class=\"headerlink\" title=\"方法二：矩阵快速幂\"></a>方法二：矩阵快速幂</h2><p>思路</p>\n<p>以上的方法适用于 n 比较小的情况，在 n 变大之后，O(n) 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。</p>\n<p>首先我们可以构建这样一个递推关系：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083754854.png\" alt=\"image-20210827083754854\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083828286.png\" alt=\"image-20210827083828286\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083903421.png\" alt=\"image-20210827083903421\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] q = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = pow(q, n);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] pow(<span class=\"keyword\">int</span>[][] a, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ret = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ret = multiply(ret, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            a = multiply(a, a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] multiply(<span class=\"keyword\">int</span>[][] a, <span class=\"keyword\">int</span>[][] b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] c = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++) &#123;</span><br><span class=\"line\">                c[i][j] = a[i][<span class=\"number\">0</span>] * b[<span class=\"number\">0</span>][j] + a[i][<span class=\"number\">1</span>] * b[<span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：同快速幂，O<em>(log</em>n*)。</li>\n<li>空间复杂度：O*(1)。</li>\n</ul>\n<h2 id=\"方法三：通项公式\"><a href=\"#方法三：通项公式\" class=\"headerlink\" title=\"方法三：通项公式\"></a>方法三：通项公式</h2><p>思路</p>\n<p>之前的方法我们已经讨论了 f(n) 是齐次线性递推，根据递推方程 f(n)=f(n−1)+f(n−2)，我们可以写出这样的特征方程：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084025122.png\" alt=\"image-20210827084025122\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = Math.sqrt(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = Math.pow((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - Math.pow((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.round(fibn / sqrt5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<p>代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里形成的数列正好是斐波那契数列，答案要求的 f(n) 即是斐波那契数列的第 n 项（下标从 0 开始）。我们来总结一下斐波那契数列第 n 项的求解方法：</p>\n<ul>\n<li>n 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2^n)，存在很多冗余计算。</li>\n<li>一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 O(n)O(n)。</li>\n<li>为了优化空间复杂度，我们可以不用保存 f(x−2) 之前的项，我们只用三个变量来维护 f(x)、f(x−1) 和 f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 O(1)。</li>\n<li>随着 n 的不断增大 O(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 O(logn)。</li>\n<li>我们也可以把 n 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。</li>\n</ul>\n<h1 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[1,2,3,1]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class=\"line\">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[2,7,9,3,1]</span><br><span class=\"line\">输出：12</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class=\"line\">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= nums.length &lt;= 100</span><br><span class=\"line\">0 &lt;= nums[i] &lt;= 400</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划-1\"><a href=\"#方法一：动态规划-1\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>\n<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k&gt;2) 间房屋，有两个选项：</p>\n<p>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p>\n<p>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</p>\n<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p>\n<p>用 dp[i] 表示前 i 间房屋能偷窃到最高总金额，那么就有如下的状态转移方程：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084625905.png\" alt=\"image-20210827084625905\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084637588.png\" alt=\"image-20210827084637588\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/打家劫舍.gif\" alt=\"打家劫舍\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = nums[<span class=\"number\">0</span>], second = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = second;</span><br><span class=\"line\">            second = Math.max(first + nums[i], second);</span><br><span class=\"line\">            first = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>\n<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>\n</ul>\n<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">120. 三角形最小路径和</a></h1><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>\n<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例1：</span><br><span class=\"line\">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class=\"line\">输出：11</span><br><span class=\"line\">解释：如下面简图所示：</span><br><span class=\"line\">   2</span><br><span class=\"line\">  3 4</span><br><span class=\"line\"> 6 5 7</span><br><span class=\"line\">4 1 8 3</span><br><span class=\"line\">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br><span class=\"line\"></span><br><span class=\"line\">示例2：</span><br><span class=\"line\">输入：triangle = [[-10]]</span><br><span class=\"line\">输出：-10</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= triangle.length &lt;= 200</span><br><span class=\"line\"><span class=\"attr\">triangle[0].length</span> == <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">triangle[i].length</span> == triangle[i - <span class=\"number\">1</span>].length + <span class=\"number\">1</span></span><br><span class=\"line\">-104 &lt;= triangle[i][j] &lt;= 104</span><br><span class=\"line\"></span><br><span class=\"line\">进阶：</span><br><span class=\"line\">你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</span><br></pre></td></tr></table></figure>\n<p>前言<br>本题是一道非常经典且历史悠久的动态规划题，其作为算法题出现，最早可以追溯到 1994 年的 <code>IOI（国际信息学奥林匹克竞赛）</code>的 The Triangle。时光飞逝，经过 20 多年的沉淀，往日的国际竞赛题如今已经变成了动态规划的入门必做题，不断督促着我们学习和巩固算法。</p>\n<p>在本题中，给定的三角形的行数为 <code>n</code>，并且第 <code>i</code> 行（从 00 开始编号）包含了 <code>i+1</code> 个数。如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[2]</span></span><br><span class=\"line\"><span class=\"section\">[3,4]</span></span><br><span class=\"line\"><span class=\"section\">[6,5,7]</span></span><br><span class=\"line\"><span class=\"section\">[4,1,8,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划-2\"><a href=\"#方法一：动态规划-2\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p><strong>思路与算法</strong></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085638971.png\" alt=\"image-20210827085638971\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085653145.png\" alt=\"image-20210827085653145\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085706690.png\" alt=\"image-20210827085706690\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            f[i][<span class=\"number\">0</span>] = f[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                f[i][j] = Math.min(f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], f[i - <span class=\"number\">1</span>][j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[i][i] = f[i - <span class=\"number\">1</span>][i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[n - <span class=\"number\">1</span>][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085734402.png\" alt=\"image-20210827085734402\"></p>\n<h2 id=\"方法二：动态规划-空间优化\"><a href=\"#方法二：动态规划-空间优化\" class=\"headerlink\" title=\"方法二：动态规划 + 空间优化\"></a>方法二：动态规划 + 空间优化</h2><p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085752503.png\" alt=\"image-20210827085752503\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>][n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curr = i % <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prev = <span class=\"number\">1</span> - curr;</span><br><span class=\"line\">            f[curr][<span class=\"number\">0</span>] = f[prev][<span class=\"number\">0</span>] + triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                f[curr][j] = Math.min(f[prev][j - <span class=\"number\">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[curr][i] = f[prev][i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[(n - <span class=\"number\">1</span>) % <span class=\"number\">2</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[(n - <span class=\"number\">1</span>) % <span class=\"number\">2</span>][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述方法的空间复杂度为 <code>O(n)</code>，使用了 <code>2n</code> 的空间存储状态。我们还可以继续进行优化吗？</p>\n<p>答案是可以的。我们从 <code>i</code> 到 <code>0</code> 递减地枚举<code>j</code>，这样我们只需要一个长度为 <code>n</code> 的一维数组 <code>f</code>，就可以完成状态转移。</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085929461.png\" alt=\"image-20210827085929461\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            f[i] = f[i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                f[j] = Math.min(f[j - <span class=\"number\">1</span>], f[j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[<span class=\"number\">0</span>] += triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085949372.png\" alt=\"image-20210827085949372\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本题还有一些其它的动态规划方法，例如：</p>\n<ul>\n<li>从三角形的底部开始转移，到顶部结束；</li>\n<li>直接在给定的三角形数组上进行状态转移，不使用额外的空间。</li>\n</ul>\n<p>读者可以自行尝试。如果在面试中遇到类似的题目，需要和面试官进行沟通，可以询问「是否有空间复杂度限制」「是否可以修改原数组」等问题，给出符合条件的算法。</p>\n","more":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a><a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin\" target=\"_blank\" rel=\"noopener\">动态规划</a></h1><blockquote>\n<p><strong>动态规划</strong>（Dynamic Programming，DP）是运筹学的一个分支，是求解<a href=\"https://baike.baidu.com/item/决策过程/6714639\" target=\"_blank\" rel=\"noopener\">决策过程</a>最优化的过程。20世纪50年代初，<a href=\"https://baike.baidu.com/item/美国/125486\" target=\"_blank\" rel=\"noopener\">美国</a>数学家<a href=\"https://baike.baidu.com/item/贝尔曼/9239579\" target=\"_blank\" rel=\"noopener\">贝尔曼</a>（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最<a href=\"https://baike.baidu.com/item/优化原理/949739\" target=\"_blank\" rel=\"noopener\">优化原理</a>，从而创立了动态规划。动态规划的应用极其广泛，包括<a href=\"https://baike.baidu.com/item/工程技术/6998399\" target=\"_blank\" rel=\"noopener\">工程技术</a>、经济、工业生产、军事以及<a href=\"https://baike.baidu.com/item/自动化控制/8483773\" target=\"_blank\" rel=\"noopener\">自动化控制</a>等领域，并在<a href=\"https://baike.baidu.com/item/背包问题/2416931\" target=\"_blank\" rel=\"noopener\">背包问题</a>、生产经营问题、资金管理问题、<a href=\"https://baike.baidu.com/item/资源分配问题/19135166\" target=\"_blank\" rel=\"noopener\">资源分配问题</a>、<a href=\"https://baike.baidu.com/item/最短路径问题/23162228\" target=\"_blank\" rel=\"noopener\">最短路径问题</a>和复杂系统可靠性问题等中取得了显著的效果 [1] 。 [2] </p>\n</blockquote>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><strong>多阶段决策问题</strong></li>\n<li><strong>动态规划问题中的术语</strong><ul>\n<li><a href=\"https://baike.baidu.com/item/阶段\" target=\"_blank\" rel=\"noopener\">阶段</a></li>\n<li><a href=\"https://baike.baidu.com/item/状态\" target=\"_blank\" rel=\"noopener\">状态</a></li>\n<li><a href=\"https://baike.baidu.com/item/无后效性\" target=\"_blank\" rel=\"noopener\">无后效性</a></li>\n<li><a href=\"https://baike.baidu.com/item/决策\" target=\"_blank\" rel=\"noopener\">决策</a></li>\n<li><a href=\"https://baike.baidu.com/item/策略\" target=\"_blank\" rel=\"noopener\">策略</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><p>多阶段决策问题中，各个阶段采取的<a href=\"https://baike.baidu.com/item/决策\" target=\"_blank\" rel=\"noopener\">决策</a>，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。</p>\n<h2 id=\"适用条件\"><a href=\"#适用条件\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h2><ul>\n<li><strong><a href=\"https://baike.baidu.com/item/最优化原理\" target=\"_blank\" rel=\"noopener\">最优化原理</a></strong>（最优子结构性质）</li>\n<li><strong><a href=\"https://baike.baidu.com/item/无后效性\" target=\"_blank\" rel=\"noopener\">无后效性</a></strong></li>\n<li><strong>子问题的重叠性</strong></li>\n</ul>\n<h1 id=\"70-爬楼梯\"><a href=\"#70-爬楼梯\" class=\"headerlink\" title=\"70. 爬楼梯\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\" target=\"_blank\" rel=\"noopener\">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入： 2</span><br><span class=\"line\">输出： 2</span><br><span class=\"line\">解释： 有两种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶</span><br><span class=\"line\">2.  2 阶</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入： 3</span><br><span class=\"line\">输出： 3</span><br><span class=\"line\">解释： 有三种方法可以爬到楼顶。</span><br><span class=\"line\">1.  1 阶 + 1 阶 + 1 阶</span><br><span class=\"line\">2.  1 阶 + 2 阶</span><br><span class=\"line\">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划\"><a href=\"#方法一：动态规划\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p>思路和算法</p>\n<p>我们用 f(x) 表示爬到第 xx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：</p>\n<p>f(x) = f(x - 1) + f(x - 2)</p>\n<p>它意味着爬到第 x 级台阶的方案数是爬到第 x - 1 级台阶的方案数和爬到第 x - 2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从 f(x - 1) 和 f(x - 2)转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p>\n<p>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 0 级开始爬的，所以从第 00 级爬到第 0 级我们可以看作只有一种方案，即 f(0) = 1；从第 0 级到第 1 级也只有一种方案，即爬一级，f(1) = 1。这两个作为边界条件就可以继续向后推导出第 n 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到 f(2) = 2，f(3) = 3，f(4) = 5，……，我们把这些情况都枚举出来，发现计算的结果是正确的。</p>\n<p>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n) 的实现，但是由于这里的 f(x) 只和 f(x - 1)与 f(x - 2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)。下面的代码中给出的就是这种实现。</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/70_fig1.gif\" alt=\"70_fig1\"><sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">0</span>, q = <span class=\"number\">0</span>, r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            p = q; </span><br><span class=\"line\">            q = r; </span><br><span class=\"line\">            r = p + q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</li>\n</ul>\n<h2 id=\"方法二：矩阵快速幂\"><a href=\"#方法二：矩阵快速幂\" class=\"headerlink\" title=\"方法二：矩阵快速幂\"></a>方法二：矩阵快速幂</h2><p>思路</p>\n<p>以上的方法适用于 n 比较小的情况，在 n 变大之后，O(n) 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。</p>\n<p>首先我们可以构建这样一个递推关系：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083754854.png\" alt=\"image-20210827083754854\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083828286.png\" alt=\"image-20210827083828286\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827083903421.png\" alt=\"image-20210827083903421\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] q = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] res = pow(q, n);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] pow(<span class=\"keyword\">int</span>[][] a, <span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ret = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ret = multiply(ret, a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            a = multiply(a, a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] multiply(<span class=\"keyword\">int</span>[][] a, <span class=\"keyword\">int</span>[][] b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] c = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span>; j++) &#123;</span><br><span class=\"line\">                c[i][j] = a[i][<span class=\"number\">0</span>] * b[<span class=\"number\">0</span>][j] + a[i][<span class=\"number\">1</span>] * b[<span class=\"number\">1</span>][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：同快速幂，O<em>(log</em>n*)。</li>\n<li>空间复杂度：O*(1)。</li>\n</ul>\n<h2 id=\"方法三：通项公式\"><a href=\"#方法三：通项公式\" class=\"headerlink\" title=\"方法三：通项公式\"></a>方法三：通项公式</h2><p>思路</p>\n<p>之前的方法我们已经讨论了 f(n) 是齐次线性递推，根据递推方程 f(n)=f(n−1)+f(n−2)，我们可以写出这样的特征方程：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084025122.png\" alt=\"image-20210827084025122\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">climbStairs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sqrt5 = Math.sqrt(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">double</span> fibn = Math.pow((<span class=\"number\">1</span> + sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>) - Math.pow((<span class=\"number\">1</span> - sqrt5) / <span class=\"number\">2</span>, n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) Math.round(fibn / sqrt5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<p>代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这里形成的数列正好是斐波那契数列，答案要求的 f(n) 即是斐波那契数列的第 n 项（下标从 0 开始）。我们来总结一下斐波那契数列第 n 项的求解方法：</p>\n<ul>\n<li>n 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2^n)，存在很多冗余计算。</li>\n<li>一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 O(n)O(n)。</li>\n<li>为了优化空间复杂度，我们可以不用保存 f(x−2) 之前的项，我们只用三个变量来维护 f(x)、f(x−1) 和 f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 O(1)。</li>\n<li>随着 n 的不断增大 O(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 O(logn)。</li>\n<li>我们也可以把 n 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。</li>\n</ul>\n<h1 id=\"198-打家劫舍\"><a href=\"#198-打家劫舍\" class=\"headerlink\" title=\"198. 打家劫舍\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener\">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[1,2,3,1]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class=\"line\">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[2,7,9,3,1]</span><br><span class=\"line\">输出：12</span><br><span class=\"line\">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class=\"line\">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= nums.length &lt;= 100</span><br><span class=\"line\">0 &lt;= nums[i] &lt;= 400</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划-1\"><a href=\"#方法一：动态规划-1\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>\n<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k&gt;2) 间房屋，有两个选项：</p>\n<p>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</p>\n<p>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</p>\n<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p>\n<p>用 dp[i] 表示前 i 间房屋能偷窃到最高总金额，那么就有如下的状态转移方程：</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084625905.png\" alt=\"image-20210827084625905\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827084637588.png\" alt=\"image-20210827084637588\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/打家劫舍.gif\" alt=\"打家劫舍\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"keyword\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> first = nums[<span class=\"number\">0</span>], second = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = second;</span><br><span class=\"line\">            second = Math.max(first + nums[i], second);</span><br><span class=\"line\">            first = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>\n<li>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</li>\n</ul>\n<h1 id=\"120-三角形最小路径和\"><a href=\"#120-三角形最小路径和\" class=\"headerlink\" title=\"120. 三角形最小路径和\"></a><a href=\"https://leetcode-cn.com/problems/triangle/\" target=\"_blank\" rel=\"noopener\">120. 三角形最小路径和</a></h1><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>\n<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例1：</span><br><span class=\"line\">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class=\"line\">输出：11</span><br><span class=\"line\">解释：如下面简图所示：</span><br><span class=\"line\">   2</span><br><span class=\"line\">  3 4</span><br><span class=\"line\"> 6 5 7</span><br><span class=\"line\">4 1 8 3</span><br><span class=\"line\">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br><span class=\"line\"></span><br><span class=\"line\">示例2：</span><br><span class=\"line\">输入：triangle = [[-10]]</span><br><span class=\"line\">输出：-10</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">1 &lt;= triangle.length &lt;= 200</span><br><span class=\"line\"><span class=\"attr\">triangle[0].length</span> == <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">triangle[i].length</span> == triangle[i - <span class=\"number\">1</span>].length + <span class=\"number\">1</span></span><br><span class=\"line\">-104 &lt;= triangle[i][j] &lt;= 104</span><br><span class=\"line\"></span><br><span class=\"line\">进阶：</span><br><span class=\"line\">你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？</span><br></pre></td></tr></table></figure>\n<p>前言<br>本题是一道非常经典且历史悠久的动态规划题，其作为算法题出现，最早可以追溯到 1994 年的 <code>IOI（国际信息学奥林匹克竞赛）</code>的 The Triangle。时光飞逝，经过 20 多年的沉淀，往日的国际竞赛题如今已经变成了动态规划的入门必做题，不断督促着我们学习和巩固算法。</p>\n<p>在本题中，给定的三角形的行数为 <code>n</code>，并且第 <code>i</code> 行（从 00 开始编号）包含了 <code>i+1</code> 个数。如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[2]</span></span><br><span class=\"line\"><span class=\"section\">[3,4]</span></span><br><span class=\"line\"><span class=\"section\">[6,5,7]</span></span><br><span class=\"line\"><span class=\"section\">[4,1,8,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：动态规划-2\"><a href=\"#方法一：动态规划-2\" class=\"headerlink\" title=\"方法一：动态规划\"></a>方法一：动态规划</h2><p><strong>思路与算法</strong></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085638971.png\" alt=\"image-20210827085638971\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085653145.png\" alt=\"image-20210827085653145\"></p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085706690.png\" alt=\"image-20210827085706690\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n][n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            f[i][<span class=\"number\">0</span>] = f[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                f[i][j] = Math.min(f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], f[i - <span class=\"number\">1</span>][j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[i][i] = f[i - <span class=\"number\">1</span>][i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[n - <span class=\"number\">1</span>][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085734402.png\" alt=\"image-20210827085734402\"></p>\n<h2 id=\"方法二：动态规划-空间优化\"><a href=\"#方法二：动态规划-空间优化\" class=\"headerlink\" title=\"方法二：动态规划 + 空间优化\"></a>方法二：动态规划 + 空间优化</h2><p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085752503.png\" alt=\"image-20210827085752503\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>][n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curr = i % <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> prev = <span class=\"number\">1</span> - curr;</span><br><span class=\"line\">            f[curr][<span class=\"number\">0</span>] = f[prev][<span class=\"number\">0</span>] + triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                f[curr][j] = Math.min(f[prev][j - <span class=\"number\">1</span>], f[prev][j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[curr][i] = f[prev][i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[(n - <span class=\"number\">1</span>) % <span class=\"number\">2</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[(n - <span class=\"number\">1</span>) % <span class=\"number\">2</span>][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述方法的空间复杂度为 <code>O(n)</code>，使用了 <code>2n</code> 的空间存储状态。我们还可以继续进行优化吗？</p>\n<p>答案是可以的。我们从 <code>i</code> 到 <code>0</code> 递减地枚举<code>j</code>，这样我们只需要一个长度为 <code>n</code> 的一维数组 <code>f</code>，就可以完成状态转移。</p>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085929461.png\" alt=\"image-20210827085929461\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minimumTotal</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = triangle.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] f = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        f[<span class=\"number\">0</span>] = triangle.get(<span class=\"number\">0</span>).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            f[i] = f[i - <span class=\"number\">1</span>] + triangle.get(i).get(i);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">                f[j] = Math.min(f[j - <span class=\"number\">1</span>], f[j]) + triangle.get(i).get(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            f[<span class=\"number\">0</span>] += triangle.get(i).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> minTotal = f[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            minTotal = Math.min(minTotal, f[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minTotal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/807-DynamicProgramming/image-20210827085949372.png\" alt=\"image-20210827085949372\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本题还有一些其它的动态规划方法，例如：</p>\n<ul>\n<li>从三角形的底部开始转移，到顶部结束；</li>\n<li>直接在给定的三角形数组上进行状态转移，不使用额外的空间。</li>\n</ul>\n<p>读者可以自行尝试。如果在面试中遇到类似的题目，需要和面试官进行沟通，可以询问「是否有空间复杂度限制」「是否可以修改原数组」等问题，给出符合条件的算法。</p>\n","next":{"title":"算法常用的解题思路---递归/回溯","path":"api/articles/resource-java-algorithm-806-recursive.json","image":"/img/header_img/interview/recursive.gif","num_read":909,"num_like":331,"num_collection":474,"num_comments":58},"prev":{"title":"算法常用的解题思路---位运算","path":"api/articles/resource-java-algorithm-808-bit.json","image":"/img/header_img/interview/bit.jpg","num_read":1358,"num_like":463,"num_collection":422,"num_comments":110},"categories":[{"name":"算法","path":"api/categories/算法.json","pathContent":"api/categories/算法","description":"为了更有效的处理数据，提高数据运算效率。","cover":"https://sunfy9.gitee.io/project/photo/project/algorithm.png"}],"tags":[]}