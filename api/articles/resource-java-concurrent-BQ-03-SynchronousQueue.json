{"title":"SynchronousQueue介绍","num_read":1525,"num_like":774,"num_collection":397,"num_comments":225,"slug":"resource-java-concurrent-BQ-03-SynchronousQueue","date":"2021-12-14T16:00:00.000Z","img":"/img/header_img/concurrent/SynchronousQueue.png","minNumber":600,"format":"standard","_id":"clhrbp2dm009do5lg6y5aepih","project":"concurrent","subtitle":"SynchronousQueue是一个没有数据缓冲的BlockingQueue","site":{"data":{}},"updated":"2022-09-19T14:49:55.631Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-03-SynchronousQueue.json","webPath":"2021/12/15/resource-java-concurrent-BQ-03-SynchronousQueue/","permalink":"https://sunfy9.gitee.io/2021/12/15/resource-java-concurrent-BQ-03-SynchronousQueue/","excerpt":null,"covers":["../../../../img/BQ-03-SynchronousQueue/image-20220919224939343.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a><strong>SynchronousQueue</strong></h1><p>SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take。</p>\n<p><img src=\"../../../../img/BQ-03-SynchronousQueue/image-20220919224939343.png\" alt=\"image-20220919224939343\" style=\"zoom:67%;\" /></p>\n<p>如图所示，SynchronousQueue 最大的不同之处在于，它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。</p>\n<p>需要注意的是，SynchronousQueue 的容量不是 1 而是 0，因为 SynchronousQueue 不需要去持有元素，它所做的就是直接传递（direct handoff）。由于每当需要传递的时候，SynchronousQueue 会把元素直接从生产者传给消费者，在此期间并不需要做存储，所以如果运用得当，它的效率是很高的。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。<sunfy-line></p>\n<p>SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue&lt;Integer&gt; synchronousQueue = <span class=\"keyword\">new</span> SynchronousQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>是一个没有数据缓冲的BlockingQueue，容量为0，它不会为队列中元素维护存储空间，它只是多个线程之间数据交换的媒介。</strong></p>\n<p>数据结构：链表（Node），在其内部类中维护了数据</p>\n<ul>\n<li>先消费（take），后生产（put）<ul>\n<li>第一个线程Thread()是消费者访问，此时队列为空，则入队（创建Node节点并赋值）</li>\n<li>第二个线程Thread1也是消费者访问，与队尾模式相同，继续入队</li>\n<li>第三个线程Thread2是生产者，携带了数据e，与队尾模式不同，不进行入队操作。直接将该线程携带的数据e返回给队首的消费者，并唤醒队首线程Thread1（默认非公平策略是栈结构），出队</li>\n</ul>\n</li>\n</ul>\n<p>锁：CAS+自旋（无锁）</p>\n<p>阻塞：自旋了一定次数后调用LockSupport.park()</p>\n<p>存取调用同一个方法：transfer()</p>\n<ul>\n<li>put、offer为生产者，携带了数据e，为Data模式，设置到SNode或QNode属性中</li>\n<li>take、poll为消费者，不携带数据，为Request模式，设置到SNode或QNode属性中</li>\n</ul>\n<p>过程</p>\n<ul>\n<li>线程访问阻塞队列，先判断队尾节点或者栈顶节点的Node与当前入队模式是否相同</li>\n<li>相同则构造节点Node入队，并阻塞当前线程，元素e和线程赋值给Node属性</li>\n<li>不同则将元素e(不为null)返回给取数据的线程，队首或栈顶线程被唤醒，出队</li>\n</ul>\n<p>公平模式：TransferQueue，队尾匹配（判断模式），队头出队，先进先出</p>\n<p>非公平模式（默认策略）：TransferStack，栈顶匹配，栈顶出栈，后进先出</p>\n<p>应用场景：</p>\n<ul>\n<li>SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务</li>\n<li>SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>\n</ul>\n","more":"<h1 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a><strong>SynchronousQueue</strong></h1><p>SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take。</p>\n<p><img src=\"../../../../img/BQ-03-SynchronousQueue/image-20220919224939343.png\" alt=\"image-20220919224939343\" style=\"zoom:67%;\" /></p>\n<p>如图所示，SynchronousQueue 最大的不同之处在于，它的容量为 0，所以没有一个地方来暂存元素，导致每次取数据都要先阻塞，直到有数据被放入；同理，每次放数据的时候也会阻塞，直到有消费者来取。</p>\n<p>需要注意的是，SynchronousQueue 的容量不是 1 而是 0，因为 SynchronousQueue 不需要去持有元素，它所做的就是直接传递（direct handoff）。由于每当需要传递的时候，SynchronousQueue 会把元素直接从生产者传给消费者，在此期间并不需要做存储，所以如果运用得当，它的效率是很高的。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h2><p>SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务。<sunfy-line></p>\n<p>SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue&lt;Integer&gt; synchronousQueue = <span class=\"keyword\">new</span> SynchronousQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>是一个没有数据缓冲的BlockingQueue，容量为0，它不会为队列中元素维护存储空间，它只是多个线程之间数据交换的媒介。</strong></p>\n<p>数据结构：链表（Node），在其内部类中维护了数据</p>\n<ul>\n<li>先消费（take），后生产（put）<ul>\n<li>第一个线程Thread()是消费者访问，此时队列为空，则入队（创建Node节点并赋值）</li>\n<li>第二个线程Thread1也是消费者访问，与队尾模式相同，继续入队</li>\n<li>第三个线程Thread2是生产者，携带了数据e，与队尾模式不同，不进行入队操作。直接将该线程携带的数据e返回给队首的消费者，并唤醒队首线程Thread1（默认非公平策略是栈结构），出队</li>\n</ul>\n</li>\n</ul>\n<p>锁：CAS+自旋（无锁）</p>\n<p>阻塞：自旋了一定次数后调用LockSupport.park()</p>\n<p>存取调用同一个方法：transfer()</p>\n<ul>\n<li>put、offer为生产者，携带了数据e，为Data模式，设置到SNode或QNode属性中</li>\n<li>take、poll为消费者，不携带数据，为Request模式，设置到SNode或QNode属性中</li>\n</ul>\n<p>过程</p>\n<ul>\n<li>线程访问阻塞队列，先判断队尾节点或者栈顶节点的Node与当前入队模式是否相同</li>\n<li>相同则构造节点Node入队，并阻塞当前线程，元素e和线程赋值给Node属性</li>\n<li>不同则将元素e(不为null)返回给取数据的线程，队首或栈顶线程被唤醒，出队</li>\n</ul>\n<p>公平模式：TransferQueue，队尾匹配（判断模式），队头出队，先进先出</p>\n<p>非公平模式（默认策略）：TransferStack，栈顶匹配，栈顶出栈，后进先出</p>\n<p>应用场景：</p>\n<ul>\n<li>SynchronousQueue非常适合传递性场景做交换工作，生产者的线程和消费者的线程同步传递某些信息、事件或者任务</li>\n<li>SynchronousQueue的一个使用场景是在线程池里。如果我们不确定来自生产者请求数量，但是这些请求需要很快的处理掉，那么配合SynchronousQueue为每个生产者请求分配一个消费线程是处理效率最高的办法。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</li>\n</ul>\n","next":{"title":"LinkedBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-02-LinkedBlockingQueue.json","image":"/img/header_img/concurrent/LinkedBlockingQueue.png","num_read":1356,"num_like":379,"num_collection":830,"num_comments":131},"prev":{"title":"DelayQueue介绍","path":"api/articles/resource-java-concurrent-BQ-04-DelayQueue.json","image":"/img/header_img/concurrent/DelayQueue.png","num_read":1552,"num_like":768,"num_collection":292,"num_comments":112},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}