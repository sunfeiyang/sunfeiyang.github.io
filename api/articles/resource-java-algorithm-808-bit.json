{"title":"算法常用的解题思路---位运算","num_read":1099,"num_like":339,"num_collection":874,"num_comments":266,"slug":"resource-java-algorithm-808-bit","date":"2021-08-26T16:00:00.000Z","img":"/img/header_img/interview/bit.jpg","_id":"clhrbp2df007so5lg1ub1g3vf","project":"algorithm","site":{"data":{}},"updated":"2022-10-28T08:30:44.956Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-algorithm-808-bit.json","webPath":"2021/08/27/resource-java-algorithm-808-bit/","permalink":"https://sunfy9.gitee.io/2021/08/27/resource-java-algorithm-808-bit/","excerpt":null,"covers":["../../../../img/808-bit/image-20210827090511912.png","../../../../img/808-bit/image-20210827090843502.png","../../../../img/808-bit/image-20210827090859357.png","../../../../img/808-bit/image-20210827090914164.png","../../../../img/808-bit/image-20210827091648500.png","../../../../img/808-bit/190_fig1.png","../../../../img/808-bit/1.PNG","../../../../img/808-bit/2.PNG","../../../../img/808-bit/3.PNG"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a><a href=\"https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97/6888804?fr=aladdin\" target=\"_blank\" rel=\"noopener\">位运算</a></h1><blockquote>\n<p>程序中的所有数在<a href=\"https://baike.baidu.com/item/计算机内存/9021807\" target=\"_blank\" rel=\"noopener\">计算机内存</a>中都是以二进制的形式<a href=\"https://baike.baidu.com/item/储存/2446499\" target=\"_blank\" rel=\"noopener\">储存</a>的。位运算就是直接对整数在内存中的二进制位进行<a href=\"https://baike.baidu.com/item/操作/33052\" target=\"_blank\" rel=\"noopener\">操作</a>。比如，and运算本来是一个逻辑<a href=\"https://baike.baidu.com/item/运算符\" target=\"_blank\" rel=\"noopener\">运算符</a>，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。</p>\n</blockquote>\n<p><img src=\"../../../../img/808-bit/image-20210827090511912.png\" alt=\"image-20210827090511912\"></p>\n<h1 id=\"231-2-的幂\"><a href=\"#231-2-的幂\" class=\"headerlink\" title=\"231. 2 的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-two/\" target=\"_blank\" rel=\"noopener\">231. 2 的幂</a></h1><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 x 使得 n == 2^x ，则认为 n 是 2 的幂次方。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：20 = 1</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：n = 16</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：24 = 16</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：n = 3</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：n = 4</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 5：</span><br><span class=\"line\">输入：n = 5</span><br><span class=\"line\">输出：false</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">-2^31 &lt;= n &lt;= 2^31 - 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：二进制表示\"><a href=\"#方法一：二进制表示\" class=\"headerlink\" title=\"方法一：二进制表示\"></a>方法一：二进制表示</h2><p><img src=\"../../../../img/808-bit/image-20210827090843502.png\" alt=\"image-20210827090843502\"></p>\n<p><img src=\"../../../../img/808-bit/image-20210827090859357.png\" alt=\"image-20210827090859357\"></p>\n<p><img src=\"../../../../img/808-bit/image-20210827090914164.png\" alt=\"image-20210827090914164\"></p>\n<p><strong>在一些语言中，位运算的优先级较低，需要注意运算顺序</strong>。<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; (n &amp; (n - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O*(1)。</li>\n</ul>\n<h2 id=\"方法二：判断是否为最大-22-的幂的约数\"><a href=\"#方法二：判断是否为最大-22-的幂的约数\" class=\"headerlink\" title=\"方法二：判断是否为最大 22 的幂的约数\"></a>方法二：判断是否为最大 22 的幂的约数</h2><p>思路与算法</p>\n<p>除了使用二进制表示判断之外，还有一种较为取巧的做法。</p>\n<p>在题目给定的 32 位有符号整数的范围内，最大的 2 的幂为 2^{30} = 1073741824 我们只需要判断 n 是否是 2^{30}  的约数即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BIG = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; BIG % n == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n<h1 id=\"191-位1的个数\"><a href=\"#191-位1的个数\" class=\"headerlink\" title=\"191. 位1的个数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">191. 位1的个数</a></h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href=\"https://baike.baidu.com/item/汉明重量\" target=\"_blank\" rel=\"noopener\">汉明重量</a>）。</p>\n<p>提示：</p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：00000000000000000000000000001011</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：00000000000000000000000010000000</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：31</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">输入必须是长度为 32 的 二进制串 。</span><br><span class=\"line\"> </span><br><span class=\"line\">进阶：</span><br><span class=\"line\">如果多次调用这个函数，你将如何优化你的算法？</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：循环检查二进制位\"><a href=\"#方法一：循环检查二进制位\" class=\"headerlink\" title=\"方法一：循环检查二进制位\"></a>方法一：循环检查二进制位</h2><p>思路及解法</p>\n<p>我们可以直接循环检查给定整数 n 的二进制位的每一位是否为 1。</p>\n<p>具体代码中，当检查第 ii 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; (<span class=\"number\">1</span> &lt;&lt; i)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ret++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(k)，其中 k 是 int 型的二进制位数，k=32。我们需要检查 n 的二进制位的每一位，一共需要检查 32 位。</li>\n<li>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h2 id=\"方法二：位运算优化\"><a href=\"#方法二：位运算优化\" class=\"headerlink\" title=\"方法二：位运算优化\"></a>方法二：位运算优化</h2><p>思路及解法</p>\n<p>观察这个运算：n~\\&amp;~(n - 1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。</p>\n<p>如：<img src=\"../../../../img/808-bit/image-20210827091648500.png\" alt=\"image-20210827091648500\">运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。</p>\n<p>这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n &amp;= n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(logn)</code>。循环次数等于 <code>n</code> 的二进制位中 <code>1</code> 的个数，最坏情况下 <code>n</code> 的二进制位全部为 <code>1</code>。我们需要循环 <code>logn</code> 次。</li>\n<li>空间复杂度：<code>O(1)</code>，我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h1 id=\"190-颠倒二进制位\"><a href=\"#190-颠倒二进制位\" class=\"headerlink\" title=\"190. 颠倒二进制位\"></a><a href=\"https://leetcode-cn.com/problems/reverse-bits/\" target=\"_blank\" rel=\"noopener\">190. 颠倒二进制位</a></h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>\n<p>提示：</p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</li>\n</ul>\n<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入: 00000010100101000001111010011100</span><br><span class=\"line\">输出: 00111001011110000010100101000000</span><br><span class=\"line\">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class=\"line\">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：10111111111111111111111111111111</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class=\"line\">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：n = 00000010100101000001111010011100</span><br><span class=\"line\">输出：964176192 (00111001011110000010100101000000)</span><br><span class=\"line\">解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class=\"line\">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：n = 11111111111111111111111111111101</span><br><span class=\"line\">输出：3221225471 (10111111111111111111111111111111)</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class=\"line\">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">输入是一个长度为 32 的二进制字符串</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：逐位颠倒\"><a href=\"#方法一：逐位颠倒\" class=\"headerlink\" title=\"方法一：逐位颠倒\"></a>方法一：逐位颠倒</h2><p>思路</p>\n<p>将 <code>n</code> 视作一个长为 <code>32</code> 的二进制串，从低位往高位枚举 <code>n</code> 的每一位，将其倒序添加到翻转结果 <code>rev</code> 中。</p>\n<p>代码实现中，每枚举一位就将<code>n</code> 右移一位，这样当前 <code>n</code> 的最低位就是我们要枚举的比特位。当 <code>n</code> 为 <code>0</code> 时即可结束循环。</p>\n<p>需要注意的是，在某些语言（如 <code>Java</code>）中，没有无符号整数类型，因此对 <code>n</code> 的右移操作应使用逻辑右移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span> &amp;&amp; n != <span class=\"number\">0</span>; ++i) &#123;</span><br><span class=\"line\">            rev |= (n &amp; <span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">31</span> - i);</span><br><span class=\"line\">            n &gt;&gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(logn)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h2 id=\"方法二：位运算分治\"><a href=\"#方法二：位运算分治\" class=\"headerlink\" title=\"方法二：位运算分治\"></a>方法二：位运算分治</h2><p>思路</p>\n<p>若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。</p>\n<p>由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。</p>\n<p><img src=\"../../../../img/808-bit/190_fig1.png\" alt=\"190_fig1\"></p>\n<p>对于递归的最底层，我们需要交换所有奇偶位：</p>\n<ul>\n<li>取出所有奇数位和偶数位；</li>\n<li>将奇数位移到偶数位上，偶数位移到奇数位上。</li>\n</ul>\n<p>类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。</p>\n<p>需要注意的是，在某些语言（如<code>Java</code>）中，没有无符号整数类型，因此对 <code>n</code> 的右移操作应使用逻辑右移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M1 = <span class=\"number\">0x55555555</span>; <span class=\"comment\">// 01010101010101010101010101010101</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M2 = <span class=\"number\">0x33333333</span>; <span class=\"comment\">// 00110011001100110011001100110011</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M4 = <span class=\"number\">0x0f0f0f0f</span>; <span class=\"comment\">// 00001111000011110000111100001111</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M8 = <span class=\"number\">0x00ff00ff</span>; <span class=\"comment\">// 00000000111111110000000011111111</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt;&gt;&gt; <span class=\"number\">16</span> | n &lt;&lt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(1)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: [2,2,1]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: [4,1,2,1,2]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：位运算\"><a href=\"#方法一：位运算\" class=\"headerlink\" title=\"方法一：位运算\"></a>方法一：位运算</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>\n<p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>\n<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>\n<p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>\n<p>上述三种解法都需要额外使用 <code>O(n)</code> 的空间，其中 <code>n</code>是数组长度。</p>\n<p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p>\n<p>答案是使用位运算。对于这道题，可使用异或运算 <code>⊕</code>。异或运算有以下三个性质。</p>\n<ol>\n<li>任何数和 <code>0</code> 做异或运算，结果仍然是原来的数，即 <code>a⊕0=a</code>。</li>\n<li>任何数和其自身做异或运算，结果是 <code>0</code>，即 <code>a⊕a=0</code>。</li>\n<li>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</li>\n</ol>\n<p><img src=\"../../../../img/808-bit/1.PNG\" alt=\"1\"></p>\n<p><img src=\"../../../../img/808-bit/2.PNG\" alt=\"2\"></p>\n<p><img src=\"../../../../img/808-bit/3.PNG\" alt=\"3\"></p>\n<p>假设数组中有 <code>2m+1</code> 个数，其中有 <code>m</code> 个数各出现两次，一个数出现一次。令 <em>a</em>1、a2、…、am为出现两次的 <code>m</code> 个数，a<br>m+1  为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：</p>\n<p><code>(a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(am⊕am)⊕am+1</code></p>\n<p>根据性质 2 和性质 1，上式可化简和计算得到如下结果：</p>\n<p><code>0⊕0⊕⋯⊕0⊕am+1=am+1</code></p>\n<p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> single = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            single ^= num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组长度。只需要对数组遍历一次。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","more":"<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a><a href=\"https://baike.baidu.com/item/%E4%BD%8D%E8%BF%90%E7%AE%97/6888804?fr=aladdin\" target=\"_blank\" rel=\"noopener\">位运算</a></h1><blockquote>\n<p>程序中的所有数在<a href=\"https://baike.baidu.com/item/计算机内存/9021807\" target=\"_blank\" rel=\"noopener\">计算机内存</a>中都是以二进制的形式<a href=\"https://baike.baidu.com/item/储存/2446499\" target=\"_blank\" rel=\"noopener\">储存</a>的。位运算就是直接对整数在内存中的二进制位进行<a href=\"https://baike.baidu.com/item/操作/33052\" target=\"_blank\" rel=\"noopener\">操作</a>。比如，and运算本来是一个逻辑<a href=\"https://baike.baidu.com/item/运算符\" target=\"_blank\" rel=\"noopener\">运算符</a>，但整数与整数之间也可以进行and运算。举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果（0表示False，1表示True，空位都当0处理）。</p>\n</blockquote>\n<p><img src=\"../../../../img/808-bit/image-20210827090511912.png\" alt=\"image-20210827090511912\"></p>\n<h1 id=\"231-2-的幂\"><a href=\"#231-2-的幂\" class=\"headerlink\" title=\"231. 2 的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-two/\" target=\"_blank\" rel=\"noopener\">231. 2 的幂</a></h1><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>\n<p>如果存在一个整数 x 使得 n == 2^x ，则认为 n 是 2 的幂次方。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：20 = 1</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：n = 16</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：24 = 16</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：n = 3</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：n = 4</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 5：</span><br><span class=\"line\">输入：n = 5</span><br><span class=\"line\">输出：false</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">-2^31 &lt;= n &lt;= 2^31 - 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：二进制表示\"><a href=\"#方法一：二进制表示\" class=\"headerlink\" title=\"方法一：二进制表示\"></a>方法一：二进制表示</h2><p><img src=\"../../../../img/808-bit/image-20210827090843502.png\" alt=\"image-20210827090843502\"></p>\n<p><img src=\"../../../../img/808-bit/image-20210827090859357.png\" alt=\"image-20210827090859357\"></p>\n<p><img src=\"../../../../img/808-bit/image-20210827090914164.png\" alt=\"image-20210827090914164\"></p>\n<p><strong>在一些语言中，位运算的优先级较低，需要注意运算顺序</strong>。<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; (n &amp; (n - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O*(1)。</li>\n</ul>\n<h2 id=\"方法二：判断是否为最大-22-的幂的约数\"><a href=\"#方法二：判断是否为最大-22-的幂的约数\" class=\"headerlink\" title=\"方法二：判断是否为最大 22 的幂的约数\"></a>方法二：判断是否为最大 22 的幂的约数</h2><p>思路与算法</p>\n<p>除了使用二进制表示判断之外，还有一种较为取巧的做法。</p>\n<p>在题目给定的 32 位有符号整数的范围内，最大的 2 的幂为 2^{30} = 1073741824 我们只需要判断 n 是否是 2^{30}  的约数即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BIG = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; BIG % n == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n<h1 id=\"191-位1的个数\"><a href=\"#191-位1的个数\" class=\"headerlink\" title=\"191. 位1的个数\"></a><a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener\">191. 位1的个数</a></h1><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href=\"https://baike.baidu.com/item/汉明重量\" target=\"_blank\" rel=\"noopener\">汉明重量</a>）。</p>\n<p>提示：</p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：00000000000000000000000000001011</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：00000000000000000000000010000000</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：31</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\">输入必须是长度为 32 的 二进制串 。</span><br><span class=\"line\"> </span><br><span class=\"line\">进阶：</span><br><span class=\"line\">如果多次调用这个函数，你将如何优化你的算法？</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：循环检查二进制位\"><a href=\"#方法一：循环检查二进制位\" class=\"headerlink\" title=\"方法一：循环检查二进制位\"></a>方法一：循环检查二进制位</h2><p>思路及解法</p>\n<p>我们可以直接循环检查给定整数 n 的二进制位的每一位是否为 1。</p>\n<p>具体代码中，当检查第 ii 位时，我们可以让 n 与 2^i 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; (<span class=\"number\">1</span> &lt;&lt; i)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ret++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(k)，其中 k 是 int 型的二进制位数，k=32。我们需要检查 n 的二进制位的每一位，一共需要检查 32 位。</li>\n<li>空间复杂度：O(1)，我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h2 id=\"方法二：位运算优化\"><a href=\"#方法二：位运算优化\" class=\"headerlink\" title=\"方法二：位运算优化\"></a>方法二：位运算优化</h2><p>思路及解法</p>\n<p>观察这个运算：n~\\&amp;~(n - 1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。</p>\n<p>如：<img src=\"../../../../img/808-bit/image-20210827091648500.png\" alt=\"image-20210827091648500\">运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。</p>\n<p>这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            n &amp;= n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            ret++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(logn)</code>。循环次数等于 <code>n</code> 的二进制位中 <code>1</code> 的个数，最坏情况下 <code>n</code> 的二进制位全部为 <code>1</code>。我们需要循环 <code>logn</code> 次。</li>\n<li>空间复杂度：<code>O(1)</code>，我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h1 id=\"190-颠倒二进制位\"><a href=\"#190-颠倒二进制位\" class=\"headerlink\" title=\"190. 颠倒二进制位\"></a><a href=\"https://leetcode-cn.com/problems/reverse-bits/\" target=\"_blank\" rel=\"noopener\">190. 颠倒二进制位</a></h1><p>颠倒给定的 32 位无符号整数的二进制位。</p>\n<p>提示：</p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</li>\n</ul>\n<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入: 00000010100101000001111010011100</span><br><span class=\"line\">输出: 00111001011110000010100101000000</span><br><span class=\"line\">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class=\"line\">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：10111111111111111111111111111111</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class=\"line\">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：n = 00000010100101000001111010011100</span><br><span class=\"line\">输出：964176192 (00111001011110000010100101000000)</span><br><span class=\"line\">解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class=\"line\">     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：n = 11111111111111111111111111111101</span><br><span class=\"line\">输出：3221225471 (10111111111111111111111111111111)</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class=\"line\">     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\">输入是一个长度为 32 的二进制字符串</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：逐位颠倒\"><a href=\"#方法一：逐位颠倒\" class=\"headerlink\" title=\"方法一：逐位颠倒\"></a>方法一：逐位颠倒</h2><p>思路</p>\n<p>将 <code>n</code> 视作一个长为 <code>32</code> 的二进制串，从低位往高位枚举 <code>n</code> 的每一位，将其倒序添加到翻转结果 <code>rev</code> 中。</p>\n<p>代码实现中，每枚举一位就将<code>n</code> 右移一位，这样当前 <code>n</code> 的最低位就是我们要枚举的比特位。当 <code>n</code> 为 <code>0</code> 时即可结束循环。</p>\n<p>需要注意的是，在某些语言（如 <code>Java</code>）中，没有无符号整数类型，因此对 <code>n</code> 的右移操作应使用逻辑右移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">32</span> &amp;&amp; n != <span class=\"number\">0</span>; ++i) &#123;</span><br><span class=\"line\">            rev |= (n &amp; <span class=\"number\">1</span>) &lt;&lt; (<span class=\"number\">31</span> - i);</span><br><span class=\"line\">            n &gt;&gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(logn)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h2 id=\"方法二：位运算分治\"><a href=\"#方法二：位运算分治\" class=\"headerlink\" title=\"方法二：位运算分治\"></a>方法二：位运算分治</h2><p>思路</p>\n<p>若要翻转一个二进制串，可以将其均分成左右两部分，对每部分递归执行翻转操作，然后将左半部分拼在右半部分的后面，即完成了翻转。</p>\n<p>由于左右两部分的计算方式是相似的，利用位掩码和位移运算，我们可以自底向上地完成这一分治流程。</p>\n<p><img src=\"../../../../img/808-bit/190_fig1.png\" alt=\"190_fig1\"></p>\n<p>对于递归的最底层，我们需要交换所有奇偶位：</p>\n<ul>\n<li>取出所有奇数位和偶数位；</li>\n<li>将奇数位移到偶数位上，偶数位移到奇数位上。</li>\n</ul>\n<p>类似地，对于倒数第二层，每两位分一组，按组号取出所有奇数组和偶数组，然后将奇数组移到偶数组上，偶数组移到奇数组上。以此类推。</p>\n<p>需要注意的是，在某些语言（如<code>Java</code>）中，没有无符号整数类型，因此对 <code>n</code> 的右移操作应使用逻辑右移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M1 = <span class=\"number\">0x55555555</span>; <span class=\"comment\">// 01010101010101010101010101010101</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M2 = <span class=\"number\">0x33333333</span>; <span class=\"comment\">// 00110011001100110011001100110011</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M4 = <span class=\"number\">0x0f0f0f0f</span>; <span class=\"comment\">// 00001111000011110000111100001111</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> M8 = <span class=\"number\">0x00ff00ff</span>; <span class=\"comment\">// 00000000111111110000000011111111</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        n = n &gt;&gt;&gt; <span class=\"number\">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &gt;&gt;&gt; <span class=\"number\">16</span> | n &lt;&lt; <span class=\"number\">16</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(1)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\" target=\"_blank\" rel=\"noopener\">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: [2,2,1]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: [4,1,2,1,2]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：位运算\"><a href=\"#方法一：位运算\" class=\"headerlink\" title=\"方法一：位运算\"></a>方法一：位运算</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>\n<p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>\n<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>\n<p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>\n<p>上述三种解法都需要额外使用 <code>O(n)</code> 的空间，其中 <code>n</code>是数组长度。</p>\n<p>如何才能做到线性时间复杂度和常数空间复杂度呢？</p>\n<p>答案是使用位运算。对于这道题，可使用异或运算 <code>⊕</code>。异或运算有以下三个性质。</p>\n<ol>\n<li>任何数和 <code>0</code> 做异或运算，结果仍然是原来的数，即 <code>a⊕0=a</code>。</li>\n<li>任何数和其自身做异或运算，结果是 <code>0</code>，即 <code>a⊕a=0</code>。</li>\n<li>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</li>\n</ol>\n<p><img src=\"../../../../img/808-bit/1.PNG\" alt=\"1\"></p>\n<p><img src=\"../../../../img/808-bit/2.PNG\" alt=\"2\"></p>\n<p><img src=\"../../../../img/808-bit/3.PNG\" alt=\"3\"></p>\n<p>假设数组中有 <code>2m+1</code> 个数，其中有 <code>m</code> 个数各出现两次，一个数出现一次。令 <em>a</em>1、a2、…、am为出现两次的 <code>m</code> 个数，a<br>m+1  为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：</p>\n<p><code>(a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(am⊕am)⊕am+1</code></p>\n<p>根据性质 2 和性质 1，上式可化简和计算得到如下结果：</p>\n<p><code>0⊕0⊕⋯⊕0⊕am+1=am+1</code></p>\n<p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> single = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            single ^= num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组长度。只需要对数组遍历一次。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","next":{"title":"算法常用的解题思路---动态规划","path":"api/articles/resource-java-algorithm-807-DynamicProgramming.json","image":"/img/header_img/interview/DynamicProgramming.jpg","num_read":1424,"num_like":850,"num_collection":499,"num_comments":99},"prev":{"title":"事务介绍","path":"api/articles/resource-MicroService-seata-tyansaction.json","image":"/img/header_img/MicroService/transaction.PNG","num_read":874,"num_like":165,"num_collection":552,"num_comments":54},"categories":[{"name":"算法","path":"api/categories/算法.json","pathContent":"api/categories/算法","description":"为了更有效的处理数据，提高数据运算效率。","cover":"https://sunfy9.gitee.io/project/photo/project/algorithm.png"}],"tags":[]}