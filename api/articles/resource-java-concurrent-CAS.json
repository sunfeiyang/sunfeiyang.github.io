{"title":"CAS操作分析","num_read":582,"num_like":161,"num_collection":732,"num_comments":152,"slug":"resource-java-concurrent-CAS","date":"2021-11-06T16:00:00.000Z","img":"/img/header_img/concurrent/cas.png","format":"gallery","_id":"clhrbp2dl0091o5lg9kfscr1n","top":true,"project":"concurrent","subtitle":"Compare And Swap，比较并交换","site":{"data":{}},"updated":"2022-09-19T14:48:29.273Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-CAS.json","webPath":"2021/11/07/resource-java-concurrent-CAS/","permalink":"https://sunfy9.gitee.io/2021/11/07/resource-java-concurrent-CAS/","excerpt":null,"covers":["../../../../img/CAS/image-20211108152724861.png","../../../../img/CAS/image-20211108165929154.png","../../../../img/CAS/image-20211108162921037.png","../../../../img/CAS/image-20211108212722738.png","../../../../img/CAS/image-20211108214752255.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a><code>CAS</code></h1><p><code>CAS</code>(Compare And Swap，比较并交换)，通常值的是一种原子操作，针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同就给它赋值另一个值。正所谓比较并交换。</p>\n<blockquote>\n<p>if(value == ‘内存中的值’) { value = new }</p>\n</blockquote>\n<font color='red' style=\"font-weight: bolder\">CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</font>\n\n<p>接下来我看下一个在理解CAS时很常见的一个例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动十个线程进行累加计算，每个线程计算1万次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 主线程休眠3秒钟</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 查看最终的计算结果</span></span><br><span class=\"line\">    System.out.println(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行上面的代码可以看到，最终得到的结果和我们预期结果并不一样，我们预期100000，但是最终运行结果始终比其小，且每次执行结果还不一样。从线程并发角度分析，上面的方法是存在并发安全问题的。</p>\n<p>分析：<sunfy-line>在java层面，sum++，是两个操作，等同于sum = sum + 1，线程先获取了共享变量中的sum值，然后去对sum值进行加1操作，然后再将计算结果赋值给sum。这是一个线程操作的完整过程，可见主要分为两个步骤，</p>\n<ul>\n<li>获取变量值进行累加</li>\n<li>将累加结果赋值给原对象</li>\n</ul>\n<p>那么，如果线程A在获取变量值进行累加同时，线程B也获取到了变量值进行累加，这时线程B先完成计算将结果赋值给原对象，随后线程A完成计算进行结果赋值，那最终原变量的值只增加了1，但实际上线程A和线程B分别进行了累加，我们期望结果是累加2，这就是很明显和我们预期不符。</p>\n<p>解决方法：</p>\n<p>个人分为两类：一类是加锁</p>\n<ul>\n<li><p>加锁<code>synchronized</code>，最简单粗暴，重量级锁，对性能影响较大</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将进行计算的操作进行加锁，可以解决此问题</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>ReentrantLock</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给累加计算操作加锁，这个在每次计算结束后，要在finally的第一行进行解锁</span></span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第二类是原子操作：</p>\n<ul>\n<li><p>使用<code>CAS</code>进行原子操作</p>\n<p>自定义一个CAS锁，需要用到Unsafe类，</p>\n<p><img src=\"../../../../img/CAS/image-20211108152724861.png\" alt=\"image-20211108152724861\"></p>\n<p>在这个类中定义了很多方法，我们要使用到的<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5)</code>，根据方法名称<code>compareAndSwapInt</code>，大概可以猜到方法的作用是先进行比较，然后进行交换一个整数值。</p>\n<p>以 <code>compareAndSwapInt</code> 为例，<code>Unsafe</code> 的 <code>compareAndSwapInt</code> 方法接收 4 个参数，分别是：对象实例、内存偏移量、字段期望值、字段新值。该方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unsafe工厂类，用户获取Unsafe对象和获取字段内存偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnsafeFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Unsafe 对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title\">getUnsafe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取字段的内存偏移量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">getFieldOffset</span><span class=\"params\">(Unsafe unsafe, Class clazz, String fieldName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义CAS锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加锁标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> OFFSET;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = UnsafeFactory.getUnsafe();</span><br><span class=\"line\">            OFFSET = UnsafeFactory.getFieldOffset(</span><br><span class=\"line\">                    UNSAFE, CASLock.class, \"state\");</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进行CAS运算，返回boolean值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cas</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, OFFSET, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用自定义的CAS锁解决上述问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> CASLock casLock = <span class=\"keyword\">new</span> CASLock();</span><br><span class=\"line\"><span class=\"comment\">// 自旋尝试获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到锁，casLock.cas()进行CAS操作，返回的是原值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (casLock.getState() == <span class=\"number\">0</span> &amp;&amp; casLock.cas()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            casLock.setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"CAS应用\"><a href=\"#CAS应用\" class=\"headerlink\" title=\"CAS应用\"></a><code>CAS</code>应用</h1><p>看一下UnSafe中常用的几个方法</p>\n<ul>\n<li><code>compareAndSwapInt(Object var1, long var2, int var4, int var5)</code></li>\n<li><code>compareAndSwapObject(Object var1, long var2, Object var4, Object var5)</code></li>\n<li><code>compareAndSwapLong(Object var1, long var2, long var4, long var6)</code></li>\n</ul>\n<p><img src=\"../../../../img/CAS/image-20211108165929154.png\" alt=\"image-20211108165929154\"></p>\n<p>这几个方法都是<code>native</code>方法，这是由java虚拟机提供具体的方法实现，这说明每个方法在不同的虚拟机中的实现可能会略有不同。</p>\n<p>他们接收的参数都是对象实例、内存偏移量、字段期望值、字段新值，这四个参数。方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>\n<h1 id=\"CAS分析\"><a href=\"#CAS分析\" class=\"headerlink\" title=\"CAS分析\"></a><code>CAS</code>分析</h1><p>虚拟机对<code>compareAndSwapInt</code>的实现采用的是C++编写的，此处不做说明，不过我们要知道</p>\n<p>不管是 Hotspot 中的 <code>Atomic::cmpxchg</code> 方法（实现CAS操作的关键方法），还是 Java 中的 <code>compareAndSwapInt</code> 方法，它 们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然 的原子性，这也正是 CAS 的价值所在。</p>\n<h1 id=\"CAS缺陷\"><a href=\"#CAS缺陷\" class=\"headerlink\" title=\"CAS缺陷\"></a><code>CAS</code>缺陷</h1><p>CAS高效解决了原子操作的问题，但是也存在一些问题</p>\n<ul>\n<li>自旋操作如果长时间不成功，会给CPU带来很大的开销</li>\n<li>CAS只能同时保证一个共享变量的原子操作</li>\n<li>ABA问题</li>\n</ul>\n<h1 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a><code>ABA</code>问题</h1><p>什么是ABA问题，首先我们理解了CAS，会在最终赋值前先进行比较，判断共享变量的初始值和计算后的值是否相同，相同才会赋值成功，否则会失败。那么如果存在这样一种情况，线程A首先获取了共享变量的值，然后进行相应的操作，在线程A执行过程中，线程B也获取到了共享变量的值，对共享变量的值增加了1并完成了赋值，紧接着线程C获取共享变量的值并对变量值减1，并完成赋值。在B和C都完成操作后，线程A才执行完成，在赋值前判断共享变量的值是否发生变更，因为线程B和线程C的操作正好互补，对于线程A来说共享变量的值并未发生变化，此时线程A会赋值成功。类似的情况就称为ABA问题。看图理解一下：</p>\n<p><img src=\"../../../../img/CAS/image-20211108162921037.png\" alt=\"image-20211108162921037\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ABA问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原子操作类</span></span><br><span class=\"line\">    AtomicInteger atomicInteger = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = atomicInteger.get();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread1 read value: \"</span> + value);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞1s</span></span><br><span class=\"line\">        LockSupport.parkNanos(<span class=\"number\">1000000000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Thread1通过CAS修改value值为3</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update from \"</span> + value + <span class=\"string\">\" to 3\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update fail!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = atomicInteger.get();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value);</span><br><span class=\"line\">        <span class=\"comment\">// Thread2通过CAS修改value值为2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 2\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">            value = atomicInteger.get();</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value);</span><br><span class=\"line\">            <span class=\"comment\">// Thread2通过CAS修改value值为1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 1\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果，出现ABA问题。</p>\n<p><img src=\"../../../../img/CAS/image-20211108212722738.png\" alt=\"image-20211108212722738\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>类比数据库中的乐观锁的情况，基于数据版本实现数据同步的机制，每次修改一次数据，版本号进行累加。</p>\n<p>java中提供的原子引用类<code>AtomicStampedReference&lt;V&gt;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义AtomicStampedReference    Pair.reference值为1, Pair.stamp为1</span></span><br><span class=\"line\">    AtomicStampedReference atomicStampedReference = <span class=\"keyword\">new</span> AtomicStampedReference(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stampHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread1 read value: \"</span> + value + <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">        <span class=\"comment\">// LockSupport 用于创建锁和其他同步类的基本线程阻塞原语</span></span><br><span class=\"line\">        <span class=\"comment\">// 阻塞1s 为线程调度目的禁用当前线程，直至指定的等待时间，除非许可可用</span></span><br><span class=\"line\">        LockSupport.parkNanos(<span class=\"number\">1000000000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Thread1通过CAS修改value值为3   stamp是版本，每次修改可以通过+1保证版本唯一性</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前引用==到预期引用并且当前标记等于预期标记，则原子地将引用和标记的值设置为给定的更新值。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">3</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update from \"</span> + value + <span class=\"string\">\" to 3\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update fail!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stampHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>)atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value+ <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">        <span class=\"comment\">// Thread2通过CAS修改value值为2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">2</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 2\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">            value = (<span class=\"keyword\">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">            stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value+ <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">            <span class=\"comment\">// Thread2通过CAS修改value值为1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">1</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 1\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/CAS/image-20211108214752255.png\" alt=\"image-20211108214752255\"></p>\n","more":"<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a><code>CAS</code></h1><p><code>CAS</code>(Compare And Swap，比较并交换)，通常值的是一种原子操作，针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同就给它赋值另一个值。正所谓比较并交换。</p>\n<blockquote>\n<p>if(value == ‘内存中的值’) { value = new }</p>\n</blockquote>\n<font color='red' style=\"font-weight: bolder\">CAS是一种无锁算法，在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</font>\n\n<p>接下来我看下一个在理解CAS时很常见的一个例子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动十个线程进行累加计算，每个线程计算1万次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 主线程休眠3秒钟</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 查看最终的计算结果</span></span><br><span class=\"line\">    System.out.println(sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行上面的代码可以看到，最终得到的结果和我们预期结果并不一样，我们预期100000，但是最终运行结果始终比其小，且每次执行结果还不一样。从线程并发角度分析，上面的方法是存在并发安全问题的。</p>\n<p>分析：<sunfy-line>在java层面，sum++，是两个操作，等同于sum = sum + 1，线程先获取了共享变量中的sum值，然后去对sum值进行加1操作，然后再将计算结果赋值给sum。这是一个线程操作的完整过程，可见主要分为两个步骤，</p>\n<ul>\n<li>获取变量值进行累加</li>\n<li>将累加结果赋值给原对象</li>\n</ul>\n<p>那么，如果线程A在获取变量值进行累加同时，线程B也获取到了变量值进行累加，这时线程B先完成计算将结果赋值给原对象，随后线程A完成计算进行结果赋值，那最终原变量的值只增加了1，但实际上线程A和线程B分别进行了累加，我们期望结果是累加2，这就是很明显和我们预期不符。</p>\n<p>解决方法：</p>\n<p>个人分为两类：一类是加锁</p>\n<ul>\n<li><p>加锁<code>synchronized</code>，最简单粗暴，重量级锁，对性能影响较大</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将进行计算的操作进行加锁，可以解决此问题</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>ReentrantLock</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给累加计算操作加锁，这个在每次计算结束后，要在finally的第一行进行解锁</span></span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">        sum++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第二类是原子操作：</p>\n<ul>\n<li><p>使用<code>CAS</code>进行原子操作</p>\n<p>自定义一个CAS锁，需要用到Unsafe类，</p>\n<p><img src=\"../../../../img/CAS/image-20211108152724861.png\" alt=\"image-20211108152724861\"></p>\n<p>在这个类中定义了很多方法，我们要使用到的<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5)</code>，根据方法名称<code>compareAndSwapInt</code>，大概可以猜到方法的作用是先进行比较，然后进行交换一个整数值。</p>\n<p>以 <code>compareAndSwapInt</code> 为例，<code>Unsafe</code> 的 <code>compareAndSwapInt</code> 方法接收 4 个参数，分别是：对象实例、内存偏移量、字段期望值、字段新值。该方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unsafe工厂类，用户获取Unsafe对象和获取字段内存偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnsafeFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Unsafe 对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title\">getUnsafe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取字段的内存偏移量</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">getFieldOffset</span><span class=\"params\">(Unsafe unsafe, Class clazz, String fieldName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义CAS锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加锁标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> OFFSET;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = UnsafeFactory.getUnsafe();</span><br><span class=\"line\">            OFFSET = UnsafeFactory.getFieldOffset(</span><br><span class=\"line\">                    UNSAFE, CASLock.class, \"state\");</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 进行CAS运算，返回boolean值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cas</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, OFFSET, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用自定义的CAS锁解决上述问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> CASLock casLock = <span class=\"keyword\">new</span> CASLock();</span><br><span class=\"line\"><span class=\"comment\">// 自旋尝试获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到锁，casLock.cas()进行CAS操作，返回的是原值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (casLock.getState() == <span class=\"number\">0</span> &amp;&amp; casLock.cas()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10000</span>; j++) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            casLock.setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"CAS应用\"><a href=\"#CAS应用\" class=\"headerlink\" title=\"CAS应用\"></a><code>CAS</code>应用</h1><p>看一下UnSafe中常用的几个方法</p>\n<ul>\n<li><code>compareAndSwapInt(Object var1, long var2, int var4, int var5)</code></li>\n<li><code>compareAndSwapObject(Object var1, long var2, Object var4, Object var5)</code></li>\n<li><code>compareAndSwapLong(Object var1, long var2, long var4, long var6)</code></li>\n</ul>\n<p><img src=\"../../../../img/CAS/image-20211108165929154.png\" alt=\"image-20211108165929154\"></p>\n<p>这几个方法都是<code>native</code>方法，这是由java虚拟机提供具体的方法实现，这说明每个方法在不同的虚拟机中的实现可能会略有不同。</p>\n<p>他们接收的参数都是对象实例、内存偏移量、字段期望值、字段新值，这四个参数。方法会针对指定对象实例中的相应偏移量的字段执行 CAS 操作。</p>\n<h1 id=\"CAS分析\"><a href=\"#CAS分析\" class=\"headerlink\" title=\"CAS分析\"></a><code>CAS</code>分析</h1><p>虚拟机对<code>compareAndSwapInt</code>的实现采用的是C++编写的，此处不做说明，不过我们要知道</p>\n<p>不管是 Hotspot 中的 <code>Atomic::cmpxchg</code> 方法（实现CAS操作的关键方法），还是 Java 中的 <code>compareAndSwapInt</code> 方法，它 们本质上都是对相应平台的 CAS 指令的一层简单封装。CAS 指令作为一种硬件原语，有着天然 的原子性，这也正是 CAS 的价值所在。</p>\n<h1 id=\"CAS缺陷\"><a href=\"#CAS缺陷\" class=\"headerlink\" title=\"CAS缺陷\"></a><code>CAS</code>缺陷</h1><p>CAS高效解决了原子操作的问题，但是也存在一些问题</p>\n<ul>\n<li>自旋操作如果长时间不成功，会给CPU带来很大的开销</li>\n<li>CAS只能同时保证一个共享变量的原子操作</li>\n<li>ABA问题</li>\n</ul>\n<h1 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a><code>ABA</code>问题</h1><p>什么是ABA问题，首先我们理解了CAS，会在最终赋值前先进行比较，判断共享变量的初始值和计算后的值是否相同，相同才会赋值成功，否则会失败。那么如果存在这样一种情况，线程A首先获取了共享变量的值，然后进行相应的操作，在线程A执行过程中，线程B也获取到了共享变量的值，对共享变量的值增加了1并完成了赋值，紧接着线程C获取共享变量的值并对变量值减1，并完成赋值。在B和C都完成操作后，线程A才执行完成，在赋值前判断共享变量的值是否发生变更，因为线程B和线程C的操作正好互补，对于线程A来说共享变量的值并未发生变化，此时线程A会赋值成功。类似的情况就称为ABA问题。看图理解一下：</p>\n<p><img src=\"../../../../img/CAS/image-20211108162921037.png\" alt=\"image-20211108162921037\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ABA问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原子操作类</span></span><br><span class=\"line\">    AtomicInteger atomicInteger = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = atomicInteger.get();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread1 read value: \"</span> + value);</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞1s</span></span><br><span class=\"line\">        LockSupport.parkNanos(<span class=\"number\">1000000000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Thread1通过CAS修改value值为3</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update from \"</span> + value + <span class=\"string\">\" to 3\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update fail!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = atomicInteger.get();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value);</span><br><span class=\"line\">        <span class=\"comment\">// Thread2通过CAS修改value值为2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 2\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">            value = atomicInteger.get();</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value);</span><br><span class=\"line\">            <span class=\"comment\">// Thread2通过CAS修改value值为1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (atomicInteger.compareAndSet(value, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 1\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果，出现ABA问题。</p>\n<p><img src=\"../../../../img/CAS/image-20211108212722738.png\" alt=\"image-20211108212722738\"></p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>类比数据库中的乐观锁的情况，基于数据版本实现数据同步的机制，每次修改一次数据，版本号进行累加。</p>\n<p>java中提供的原子引用类<code>AtomicStampedReference&lt;V&gt;</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义AtomicStampedReference    Pair.reference值为1, Pair.stamp为1</span></span><br><span class=\"line\">    AtomicStampedReference atomicStampedReference = <span class=\"keyword\">new</span> AtomicStampedReference(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stampHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread1 read value: \"</span> + value + <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">        <span class=\"comment\">// LockSupport 用于创建锁和其他同步类的基本线程阻塞原语</span></span><br><span class=\"line\">        <span class=\"comment\">// 阻塞1s 为线程调度目的禁用当前线程，直至指定的等待时间，除非许可可用</span></span><br><span class=\"line\">        LockSupport.parkNanos(<span class=\"number\">1000000000L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Thread1通过CAS修改value值为3   stamp是版本，每次修改可以通过+1保证版本唯一性</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前引用==到预期引用并且当前标记等于预期标记，则原子地将引用和标记的值设置为给定的更新值。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">3</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update from \"</span> + value + <span class=\"string\">\" to 3\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread1 update fail!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] stampHolder = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = (<span class=\"keyword\">int</span>)atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value+ <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">        <span class=\"comment\">// Thread2通过CAS修改value值为2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">2</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 2\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// do something</span></span><br><span class=\"line\">            value = (<span class=\"keyword\">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class=\"line\">            stamp = stampHolder[<span class=\"number\">0</span>];</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"Thread2 read value: \"</span> + value+ <span class=\"string\">\", stamp: \"</span> + stamp);</span><br><span class=\"line\">            <span class=\"comment\">// Thread2通过CAS修改value值为1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (atomicStampedReference.compareAndSet(value, <span class=\"number\">1</span>,stamp,stamp+<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"Thread2 update from \"</span> + value + <span class=\"string\">\" to 1\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"Thread2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/CAS/image-20211108214752255.png\" alt=\"image-20211108214752255\"></p>\n","next":{"title":"并发线程池原理分析","path":"api/articles/resource-java-concurrent-threadPool.json","image":"/img/header_img/concurrent/threadpool.png","num_read":135,"num_like":291,"num_collection":741,"num_comments":58},"prev":{"title":"Atomic原子操作分析","path":"api/articles/resource-java-concurrent-Atomic.json","image":"/img/header_img/concurrent/atomic.png","num_read":1809,"num_like":939,"num_collection":872,"num_comments":124},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}