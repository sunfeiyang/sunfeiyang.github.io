{"title":"MQ入门和RabbitMQ基础","num_read":629,"num_like":697,"num_collection":626,"num_comments":40,"slug":"resource-MQ-rabbitMQ-RabbitMQBase","date":"2020-11-17T16:00:00.000Z","img":"/img/header_img/MQ/rabbitmq.PNG","_id":"clhrbp2fk00duo5lgdktrdqt6","project":"MQ","type":"hot","site":{"data":{}},"updated":"2022-09-20T02:01:07.694Z","author":"Sunfy","comments":true,"path":"api/articles/resource-MQ-rabbitMQ-RabbitMQBase.json","webPath":"2020/11/18/resource-MQ-rabbitMQ-RabbitMQBase/","permalink":"https://sunfy9.gitee.io/2020/11/18/resource-MQ-rabbitMQ-RabbitMQBase/","excerpt":"MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。","covers":["../../../../img/RabbitMQBase/image-20201128145309508.png","../../../../img/RabbitMQBase/image-20201128145328279.png","../../../../img/RabbitMQBase/image-20201128145148926.png","../../../../img/RabbitMQBase/image-20201128145208118.png","../../../../img/RabbitMQBase/image-20201128145226488.png","../../../../img/RabbitMQBase/image-20201128145240371.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。<a id=\"more\"></a></p>\n<h3 id=\"MQ的优势\"><a href=\"#MQ的优势\" class=\"headerlink\" title=\"MQ的优势\"></a>MQ的优势</h3><ul>\n<li><p>应用解耦</p>\n<p> 提高系统容错性和可维护性</p>\n</li>\n<li><p>异步提速</p>\n<p> 提升用户体验和系统吞吐量</p>\n</li>\n<li><p>削峰填谷</p>\n<p> 提高系统稳定性</p>\n</li>\n</ul>\n<h3 id=\"MQ的劣势\"><a href=\"#MQ的劣势\" class=\"headerlink\" title=\"MQ的劣势\"></a>MQ的劣势</h3><ul>\n<li><p>系统可用性降低</p>\n<p> 系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。</p>\n</li>\n<li><p>系统复杂度提高</p>\n<p> MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。</p>\n</li>\n</ul>\n<h3 id=\"常见产品\"><a href=\"#常见产品\" class=\"headerlink\" title=\"常见产品\"></a>常见产品</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong> </strong></th>\n<th><strong>Rabbit MQ</strong></th>\n<th><strong>Active MQ</strong>（相对使用不多）</th>\n<th><strong>Rocket MQ</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>公司/社区</td>\n<td>Rabbit</td>\n<td>Apache</td>\n<td>阿里</td>\n<td>Apache</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>Erlang</td>\n<td>Java</td>\n<td>Java</td>\n<td>Scala&amp;Java</td>\n</tr>\n<tr>\n<td>协议支持</td>\n<td>AMQP，XMPP，SMTP，STOMP</td>\n<td>OpenWire,STOMP，REST,XMPP,AMQP</td>\n<td>自定义</td>\n<td>自定义协议，社区封装了http协议支持</td>\n</tr>\n<tr>\n<td>客户端支持语言</td>\n<td>官方支持Erlang，Java，Ruby等,社区产出多种API，几乎支持所有语言</td>\n<td>Java，C，C++，Python，PHP，Perl，.net等</td>\n<td>Java，C++（不成熟）</td>\n<td>官方支持Java,社区产出多种API，如PHP，Python等</td>\n</tr>\n<tr>\n<td>单机吞吐量</td>\n<td>万级（其次）</td>\n<td>万级（最差）</td>\n<td>十万级（最好）</td>\n<td>十万级（次之）</td>\n</tr>\n<tr>\n<td>消息延迟</td>\n<td>微妙级</td>\n<td>毫秒级</td>\n<td>毫秒级</td>\n<td>毫秒以内</td>\n</tr>\n<tr>\n<td>功能特性</td>\n<td>并发能力强，性能极其好，延时低，社区活跃，管理界面丰富</td>\n<td>老牌产品，成熟度高，文档较多</td>\n<td>MQ功能比较完备，扩展性佳</td>\n<td>只支持主要的MQ功能，毕竟是为大数据领域准备的。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<sunfy-line>\n\n<h3 id=\"Rabbit-MQ\"><a href=\"#Rabbit-MQ\" class=\"headerlink\" title=\"Rabbit MQ\"></a>Rabbit MQ</h3><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p>\n<p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 name space 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>\n<p><strong>Connection</strong>： publisher／consumer 和 broker 之间的 TCP 连接</p>\n<p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p>\n<p><strong>Exchange</strong>： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p>\n<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p>\n<p><strong>Binding</strong>： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>\n<h4 id=\"6-种工作模式\"><a href=\"#6-种工作模式\" class=\"headerlink\" title=\"6 种工作模式\"></a>6 种工作模式</h4><p>简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ）。<br>官网对应模式介绍：<a href=\"https://www.rabbitmq.com/getstarted.html\" target=\"_blank\" rel=\"noopener\">https://www.rabbitmq.com/getstarted.html</a></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145309508.png\" alt=\"image-20201128145309508\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145328279.png\" alt=\"image-20201128145328279\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145148926.png\" alt=\"image-20201128145148926\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145208118.png\" alt=\"image-20201128145208118\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145226488.png\" alt=\"image-20201128145226488\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145240371.png\" alt=\"image-20201128145240371\"></p>\n","more":"</p>\n<h3 id=\"MQ的优势\"><a href=\"#MQ的优势\" class=\"headerlink\" title=\"MQ的优势\"></a>MQ的优势</h3><ul>\n<li><p>应用解耦</p>\n<p> 提高系统容错性和可维护性</p>\n</li>\n<li><p>异步提速</p>\n<p> 提升用户体验和系统吞吐量</p>\n</li>\n<li><p>削峰填谷</p>\n<p> 提高系统稳定性</p>\n</li>\n</ul>\n<h3 id=\"MQ的劣势\"><a href=\"#MQ的劣势\" class=\"headerlink\" title=\"MQ的劣势\"></a>MQ的劣势</h3><ul>\n<li><p>系统可用性降低</p>\n<p> 系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。</p>\n</li>\n<li><p>系统复杂度提高</p>\n<p> MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。</p>\n</li>\n</ul>\n<h3 id=\"常见产品\"><a href=\"#常见产品\" class=\"headerlink\" title=\"常见产品\"></a>常见产品</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong> </strong></th>\n<th><strong>Rabbit MQ</strong></th>\n<th><strong>Active MQ</strong>（相对使用不多）</th>\n<th><strong>Rocket MQ</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>公司/社区</td>\n<td>Rabbit</td>\n<td>Apache</td>\n<td>阿里</td>\n<td>Apache</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>Erlang</td>\n<td>Java</td>\n<td>Java</td>\n<td>Scala&amp;Java</td>\n</tr>\n<tr>\n<td>协议支持</td>\n<td>AMQP，XMPP，SMTP，STOMP</td>\n<td>OpenWire,STOMP，REST,XMPP,AMQP</td>\n<td>自定义</td>\n<td>自定义协议，社区封装了http协议支持</td>\n</tr>\n<tr>\n<td>客户端支持语言</td>\n<td>官方支持Erlang，Java，Ruby等,社区产出多种API，几乎支持所有语言</td>\n<td>Java，C，C++，Python，PHP，Perl，.net等</td>\n<td>Java，C++（不成熟）</td>\n<td>官方支持Java,社区产出多种API，如PHP，Python等</td>\n</tr>\n<tr>\n<td>单机吞吐量</td>\n<td>万级（其次）</td>\n<td>万级（最差）</td>\n<td>十万级（最好）</td>\n<td>十万级（次之）</td>\n</tr>\n<tr>\n<td>消息延迟</td>\n<td>微妙级</td>\n<td>毫秒级</td>\n<td>毫秒级</td>\n<td>毫秒以内</td>\n</tr>\n<tr>\n<td>功能特性</td>\n<td>并发能力强，性能极其好，延时低，社区活跃，管理界面丰富</td>\n<td>老牌产品，成熟度高，文档较多</td>\n<td>MQ功能比较完备，扩展性佳</td>\n<td>只支持主要的MQ功能，毕竟是为大数据领域准备的。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<sunfy-line>\n\n<h3 id=\"Rabbit-MQ\"><a href=\"#Rabbit-MQ\" class=\"headerlink\" title=\"Rabbit MQ\"></a>Rabbit MQ</h3><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p>\n<p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 name space 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>\n<p><strong>Connection</strong>： publisher／consumer 和 broker 之间的 TCP 连接</p>\n<p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p>\n<p><strong>Exchange</strong>： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p>\n<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p>\n<p><strong>Binding</strong>： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>\n<h4 id=\"6-种工作模式\"><a href=\"#6-种工作模式\" class=\"headerlink\" title=\"6 种工作模式\"></a>6 种工作模式</h4><p>简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ）。<br>官网对应模式介绍：<a href=\"https://www.rabbitmq.com/getstarted.html\" target=\"_blank\" rel=\"noopener\">https://www.rabbitmq.com/getstarted.html</a></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145309508.png\" alt=\"image-20201128145309508\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145328279.png\" alt=\"image-20201128145328279\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145148926.png\" alt=\"image-20201128145148926\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145208118.png\" alt=\"image-20201128145208118\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145226488.png\" alt=\"image-20201128145226488\"></p>\n<p><img src=\"../../../../img/RabbitMQBase/image-20201128145240371.png\" alt=\"image-20201128145240371\"></p>","next":{"title":"Docker 搭建 Jenkins 实现自动部署","path":"api/articles/resource-RPC-Docker-Centos-Docker-jenkins.json","image":"/img/header_img/docker/docker.jpg","num_read":1321,"num_like":256,"num_collection":179,"num_comments":65},"prev":{"title":"jenkins的docker容器如何装配jdk maven和git","path":"api/articles/resource-RPC-Docker-Centos-Docker-jenkins-mavenjdkgit.json","image":"/img/header_img/docker/docker.jpg","num_read":1678,"num_like":94,"num_collection":662,"num_comments":173},"categories":[{"name":"MQ消息队列","path":"api/categories/MQ消息队列.json","pathContent":"api/categories/MQ消息队列","description":"解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构","cover":"https://sunfy9.gitee.io/project/photo/project/mq.PNG"}],"tags":[{"name":"MQ","path":"api/tags/MQ.json","pathContent":"api/tags/MQ","description":"[MQ]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}