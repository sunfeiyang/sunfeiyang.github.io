{"title":"BlockingQueue概览","num_read":54,"num_like":80,"num_collection":745,"num_comments":261,"slug":"resource-java-concurrent-BlockingQueue","date":"2021-12-11T16:00:00.000Z","img":"/img/header_img/concurrent/BlockingQueue.png","minNumber":2500,"format":"max","_id":"clhrbp2dn009ko5lghui42qmj","project":"concurrent","type":"banner","subtitle":"BlockingQueue是一个在队列基础上又支持了两个附加操作的队列","site":{"data":{}},"updated":"2022-09-19T14:51:00.959Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BlockingQueue.json","webPath":"2021/12/12/resource-java-concurrent-BlockingQueue/","permalink":"https://sunfy9.gitee.io/2021/12/12/resource-java-concurrent-BlockingQueue/","excerpt":null,"covers":["../../../../img/BlockingQueue/31433.png","../../../../img/BlockingQueue/31434.png","../../../../img/BlockingQueue/30911.png","../../../../img/BlockingQueue/image-20211214091850126.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p>了解阻塞队列之前，我们先了解下队列</p>\n<h1 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a><strong>Queue</strong></h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Queue</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//添加一个元素，添加成功返回true, 如果队列满了，返回false</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回并删除队首元素，队列为空则抛出异常</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回并删除队首元素，队列为空则返回null</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">poll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回队首元素，但不移除，队列为空则抛出异常</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">element</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//获取队首元素，但不移除，队列为空则返回null</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">peek</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a><strong>BlockingQueue接口</strong></h1><p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，常用解耦。两个附加操作:</p>\n<ul>\n<li>支持阻塞的插入方法put: 队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>\n<li>支持阻塞的移除方法take: 队列空时，获取元素的线程会等待队列变为非空</li>\n</ul>\n<font style=\"color:red\">BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。</font>\n\n<h2 id=\"入队\"><a href=\"#入队\" class=\"headerlink\" title=\"入队\"></a><strong>入队</strong><sunfy-line></h2><p>（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）</p>\n<p>（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false</p>\n<p>（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置 </p>\n<h2 id=\"出队\"><a href=\"#出队\" class=\"headerlink\" title=\"出队\"></a><strong>出队</strong></h2><p>（1）poll()：如果有数据，出队，如果没有数据，返回null   （不阻塞）</p>\n<p>（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null</p>\n<p>（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据</p>\n<h2 id=\"BlockingQueue常用方法\"><a href=\"#BlockingQueue常用方法\" class=\"headerlink\" title=\"BlockingQueue常用方法\"></a><strong>BlockingQueue常用方法</strong></h2><p>当队列满了无法添加元素，或者是队列空了无法移除元素时：</p>\n<ul>\n<li>抛出异常：add、remove、element</li>\n<li>返回结果但不抛出异常：offer、poll、peek</li>\n<li>阻塞：put、take</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>抛出异常</th>\n<th>返回特定值</th>\n<th>阻塞</th>\n<th>阻塞特定时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>入队</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td>put(e)</td>\n<td>offer(e, time, unit)</td>\n</tr>\n<tr>\n<td>出队</td>\n<td>remove()</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(time, unit)</td>\n</tr>\n<tr>\n<td>获取队首元素</td>\n<td>element()</td>\n<td>peek()</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"阻塞队列特性\"><a href=\"#阻塞队列特性\" class=\"headerlink\" title=\"阻塞队列特性\"></a><strong>阻塞队列特性</strong></h2><h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a><strong>阻塞</strong></h3><p>阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字，所以下面重点介绍阻塞功能：阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。实现阻塞最重要的两个方法是 take 方法和 put 方法。</p>\n<h3 id=\"take-方法\"><a href=\"#take-方法\" class=\"headerlink\" title=\"take 方法\"></a><strong>take 方法</strong></h3><p>take 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。过程如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/31433.png\" alt=\"img\"></p>\n<h3 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a><strong>put 方法</strong></h3><p>put 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中。过程如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/31434.png\" alt=\"img\"></p>\n<p>思考：阻塞队列是否有容量限制？</p>\n<h3 id=\"是否有界\"><a href=\"#是否有界\" class=\"headerlink\" title=\"是否有界\"></a><strong>是否有界</strong></h3><p>阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如 ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h3><p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了，如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/30911.png\" alt=\"img\"></p>\n<p>因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。</p>\n<p>同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者线程不需要关心具体的转账逻辑，只需要把转账任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会去从队列里取出来将要执行的具体的任务，再去通过自己的各种方法来完成本次转账。这样就实现了具体任务与执行任务类之间的解耦，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。</p>\n<h1 id=\"常见阻塞队列\"><a href=\"#常见阻塞队列\" class=\"headerlink\" title=\"常见阻塞队列\"></a><strong>常见阻塞队列</strong></h1><p>BlockingQueue 接口的实现类都被放在了 juc 包中，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>队列</strong></th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ArrayBlockingQueue</strong></td>\n<td>基于数组结构实现的一个有界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedBlockingQueue</strong></td>\n<td>基于链表结构实现的一个有界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>PriorityBlockingQueue</strong></td>\n<td>支持按优先级排序的无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>DelayQueue</strong></td>\n<td>基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>SynchronousQueue</strong></td>\n<td>不存储元素的阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedTransferQueue</strong></td>\n<td>基于链表结构实现的一个无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedBlockingDeque</strong></td>\n<td>基于链表结构实现的一个双端阻塞队列</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"../../../../img/BlockingQueue/image-20211214091850126.png\" alt=\"image-20211214091850126\"></p>\n","more":"<p>了解阻塞队列之前，我们先了解下队列</p>\n<h1 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a><strong>Queue</strong></h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Queue</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Collection</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//添加一个元素，添加成功返回true, 如果队列满了，就会抛出异常</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//添加一个元素，添加成功返回true, 如果队列满了，返回false</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回并删除队首元素，队列为空则抛出异常</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回并删除队首元素，队列为空则返回null</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">poll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//返回队首元素，但不移除，队列为空则抛出异常</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">element</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//获取队首元素，但不移除，队列为空则返回null</span></span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">peek</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a><strong>BlockingQueue接口</strong></h1><p>BlockingQueue 继承了 Queue 接口，是队列的一种。Queue 和 BlockingQueue 都是在 Java 5 中加入的。阻塞队列（BlockingQueue）是一个在队列基础上又支持了两个附加操作的队列，常用解耦。两个附加操作:</p>\n<ul>\n<li>支持阻塞的插入方法put: 队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>\n<li>支持阻塞的移除方法take: 队列空时，获取元素的线程会等待队列变为非空</li>\n</ul>\n<font style=\"color:red\">BlockingQueue和JDK集合包中的Queue接口兼容，同时在其基础上增加了阻塞功能。</font>\n\n<h2 id=\"入队\"><a href=\"#入队\" class=\"headerlink\" title=\"入队\"></a><strong>入队</strong><sunfy-line></h2><p>（1）offer(E e)：如果队列没满，返回true，如果队列已满，返回false（不阻塞）</p>\n<p>（2）offer(E e, long timeout, TimeUnit unit)：可以设置阻塞时间，如果队列已满，则进行阻塞。超过阻塞时间，则返回false</p>\n<p>（3）put(E e)：队列没满的时候是正常的插入，如果队列已满，则阻塞，直至队列空出位置 </p>\n<h2 id=\"出队\"><a href=\"#出队\" class=\"headerlink\" title=\"出队\"></a><strong>出队</strong></h2><p>（1）poll()：如果有数据，出队，如果没有数据，返回null   （不阻塞）</p>\n<p>（2）poll(long timeout, TimeUnit unit)：可以设置阻塞时间，如果没有数据，则阻塞，超过阻塞时间，则返回null</p>\n<p>（3）take()：队列里有数据会正常取出数据并删除；但是如果队列里无数据，则阻塞，直到队列里有数据</p>\n<h2 id=\"BlockingQueue常用方法\"><a href=\"#BlockingQueue常用方法\" class=\"headerlink\" title=\"BlockingQueue常用方法\"></a><strong>BlockingQueue常用方法</strong></h2><p>当队列满了无法添加元素，或者是队列空了无法移除元素时：</p>\n<ul>\n<li>抛出异常：add、remove、element</li>\n<li>返回结果但不抛出异常：offer、poll、peek</li>\n<li>阻塞：put、take</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>抛出异常</th>\n<th>返回特定值</th>\n<th>阻塞</th>\n<th>阻塞特定时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>入队</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td>put(e)</td>\n<td>offer(e, time, unit)</td>\n</tr>\n<tr>\n<td>出队</td>\n<td>remove()</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(time, unit)</td>\n</tr>\n<tr>\n<td>获取队首元素</td>\n<td>element()</td>\n<td>peek()</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"阻塞队列特性\"><a href=\"#阻塞队列特性\" class=\"headerlink\" title=\"阻塞队列特性\"></a><strong>阻塞队列特性</strong></h2><h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a><strong>阻塞</strong></h3><p>阻塞队列区别于其他类型的队列的最主要的特点就是“阻塞”这两个字，所以下面重点介绍阻塞功能：阻塞功能使得生产者和消费者两端的能力得以平衡，当有任何一端速度过快时，阻塞队列便会把过快的速度给降下来。实现阻塞最重要的两个方法是 take 方法和 put 方法。</p>\n<h3 id=\"take-方法\"><a href=\"#take-方法\" class=\"headerlink\" title=\"take 方法\"></a><strong>take 方法</strong></h3><p>take 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。过程如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/31433.png\" alt=\"img\"></p>\n<h3 id=\"put-方法\"><a href=\"#put-方法\" class=\"headerlink\" title=\"put 方法\"></a><strong>put 方法</strong></h3><p>put 方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中。过程如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/31434.png\" alt=\"img\"></p>\n<p>思考：阻塞队列是否有容量限制？</p>\n<h3 id=\"是否有界\"><a href=\"#是否有界\" class=\"headerlink\" title=\"是否有界\"></a><strong>是否有界</strong></h3><p>阻塞队列还有一个非常重要的属性，那就是容量的大小，分为有界和无界两种。无界队列意味着里面可以容纳非常多的元素，例如 LinkedBlockingQueue 的上限是 Integer.MAX_VALUE，是非常大的一个数，可以近似认为是无限容量，因为我们几乎无法把这个容量装满。但是有的阻塞队列是有界的，例如 ArrayBlockingQueue 如果容量满了，也不会扩容，所以一旦满了就无法再往里放数据了。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h3><p>BlockingQueue 是线程安全的，我们在很多场景下都可以利用线程安全的队列来优雅地解决我们业务自身的线程安全问题。比如说，使用生产者/消费者模式的时候，我们生产者只需要往队列里添加元素，而消费者只需要从队列里取出它们就可以了，如图所示：</p>\n<p><img src=\"../../../../img/BlockingQueue/30911.png\" alt=\"img\"></p>\n<p>因为阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的，不会发生线程安全问题。生产者/消费者直接使用线程安全的队列就可以，而不需要自己去考虑更多的线程安全问题。这也就意味着，考虑锁等线程安全问题的重任从“你”转移到了“队列”上，降低了我们开发的难度和工作量。</p>\n<p>同时，队列它还能起到一个隔离的作用。比如说我们开发一个银行转账的程序，那么生产者线程不需要关心具体的转账逻辑，只需要把转账任务，如账户和金额等信息放到队列中就可以，而不需要去关心银行这个类如何实现具体的转账业务。而作为银行这个类来讲，它会去从队列里取出来将要执行的具体的任务，再去通过自己的各种方法来完成本次转账。这样就实现了具体任务与执行任务类之间的解耦，任务被放在了阻塞队列中，而负责放任务的线程是无法直接访问到我们银行具体实现转账操作的对象的，实现了隔离，提高了安全性。</p>\n<h1 id=\"常见阻塞队列\"><a href=\"#常见阻塞队列\" class=\"headerlink\" title=\"常见阻塞队列\"></a><strong>常见阻塞队列</strong></h1><p>BlockingQueue 接口的实现类都被放在了 juc 包中，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>队列</strong></th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>ArrayBlockingQueue</strong></td>\n<td>基于数组结构实现的一个有界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedBlockingQueue</strong></td>\n<td>基于链表结构实现的一个有界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>PriorityBlockingQueue</strong></td>\n<td>支持按优先级排序的无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>DelayQueue</strong></td>\n<td>基于优先级队列（PriorityBlockingQueue）实现的无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>SynchronousQueue</strong></td>\n<td>不存储元素的阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedTransferQueue</strong></td>\n<td>基于链表结构实现的一个无界阻塞队列</td>\n</tr>\n<tr>\n<td><strong>LinkedBlockingDeque</strong></td>\n<td>基于链表结构实现的一个双端阻塞队列</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"../../../../img/BlockingQueue/image-20211214091850126.png\" alt=\"image-20211214091850126\"></p>\n","next":{"title":"从一条SQL的执行理解MySQL","inTheUpdate":true,"path":"api/articles/resource-DB-MySQL-MySQL-sql.json","image":"/img/header_img/DB/sql.png","num_read":1454,"num_like":678,"num_collection":43,"num_comments":80},"prev":{"title":"ArrayBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-01-ArrayBlockingQueue.json","image":"/img/header_img/concurrent/ArrayBlockingQueue.png","num_read":375,"num_like":921,"num_collection":786,"num_comments":130},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}