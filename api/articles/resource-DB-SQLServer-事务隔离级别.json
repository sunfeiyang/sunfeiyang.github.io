{"title":"SQLSERVER数据库事务隔离级别","num_read":887,"num_like":626,"num_collection":692,"num_comments":90,"slug":"resource-DB-SQLServer-事务隔离级别","date":"2022-07-05T16:00:00.000Z","img":"/img/header_img/DB/Transactionisolationlevel.png","format":"max","_id":"clhrbp2ax002ao5lgfe9u71n5","project":"DB","subtitle":"事务隔离级别","hot":"read","site":{"data":{}},"updated":"2022-09-23T05:27:52.164Z","comments":true,"path":"api/articles/resource-DB-SQLServer-事务隔离级别.json","webPath":"2022/07/06/resource-DB-SQLServer-事务隔离级别/","permalink":"https://sunfy9.gitee.io/2022/07/06/resource-DB-SQLServer-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","excerpt":null,"covers":["../../../../img/事务隔离级别/281738195298579.png","../../../../img/事务隔离级别/281741564356912.png","../../../../img/事务隔离级别/281747098898874.png","../../../../img/事务隔离级别/281800071398195.png","../../../../img/事务隔离级别/281804234676071.png","../../../../img/事务隔离级别/281806149045782.png","../../../../img/事务隔离级别/281809389821163.png","../../../../img/事务隔离级别/281810073734271.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h2 id=\"SQL-Server-事务隔离级别详解\"><a href=\"#SQL-Server-事务隔离级别详解\" class=\"headerlink\" title=\"SQL Server 事务隔离级别详解\"></a><a href=\"https://www.cnblogs.com/chenmh/p/3998614.html\" target=\"_blank\" rel=\"noopener\">SQL Server 事务隔离级别详解</a></h2><p>标签： SQL SEERVER/MSSQL SERVER/SQL/事务隔离级别选项/设置数据库事务级别</p>\n<p><strong>SQL 事务隔离级别</strong></p>\n<p><strong>概述</strong></p>\n<p>​     隔离级别用于决定如果控制并发用户如何读写数据的操作，同时对性能也有一定的影响作用。</p>\n<p><strong>步骤</strong></p>\n<p>事务隔离级别通过影响读操作来间接地影响写操作；可以在回话级别上设置事务隔离级别也可以在查询（表级别）级别上设置事务隔离级别。<br>事务隔离级别总共有6个隔离级别：<br>READ UNCOMMITTED(未提交读,读脏),相当于(NOLOCK)<br>READ COMMITTED(已提交读,默认级别)<br>REPEATABLE READ(可以重复读),相当于(HOLDLOCK)<br>SERIALIZABLE(可序列化)<br>SNAPSHOT(快照)<br>READ COMMITTED SNAPSHOT(已经提交读隔离)<br>对于前四个隔离级别：READ UNCOMMITTED<READ COMMITTED<REPEATABLE READ<SERIALIZABLE\n隔离级别越高,读操作的请求锁定就越严格,锁的持有时间久越长;所以隔离级别越高,一致性就越高,并发性就越低,同时性能也相对影响越大.<sunfy-line></p>\n<p><strong>获取事务隔离级别(isolation level)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBCC USEROPTIONS</span><br></pre></td></tr></table></figure>\n<p><strong>设置隔离</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置回话隔离</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL &lt;ISOLATION NAME&gt;</span><br><span class=\"line\">--注意:在设置回话隔离时(REPEATABLE READ)两个单词需要用空格间隔开,但是在表隔离中可以粘在一起(REPEATABLEREAD)</span><br><span class=\"line\"></span><br><span class=\"line\">设置查询表隔离</span><br><span class=\"line\">SELECT ....FROM &lt;TABLE&gt; WITH (&lt;ISOLATION NAME&gt;)</span><br></pre></td></tr></table></figure>\n<p><strong>1.READ UNCOMMITTED</strong></p>\n<p>READ UNCOMMITTED:未提交读，读脏数据<br>默认的读操作:需要请求共享锁,允许其他事物读锁定的数据但不允许修改.<br>READ UNCOMMITTED:读操作不申请锁,运行读取未提交的修改,也就是允许读脏数据,读操作不会影响写操作请求排他锁.</p>\n<p> 创建测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL,</span><br><span class=\"line\">Price FLOAT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00),(11,11.00),(12,12.00),(13,13.00),(14,14.00);</span><br><span class=\"line\">GO</span><br><span class=\"line\">SELECT ID,Price FROM Orders</span><br></pre></td></tr></table></figure>\n<p>新建回话1将订单10的价格加1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281738195298579.png\" alt=\"img\"></p>\n<p>在另一个回话2中执行查询操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先不添加隔离级别,默认是READ COMMITTED,由于数据之前的更新操作使用了排他锁，所以查询一直在等待锁释放*&#x2F;</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---将查询的隔离级别设置为READ UNCOMMITTED允许未提交读，读操作之前不请求共享锁。</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10;</span><br><span class=\"line\">--当然也可以使用表隔离,效果是一样的</span><br><span class=\"line\">SELECT ID,Price FROM Orders WITH (NOLOCK)</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281741564356912.png\" alt=\"img\"></p>\n<p>假设在回话1中对操作执行回滚操作,这样价格还是之前的10,但是回话2中则读取到的是回滚前的价格11,这样就属于一个读脏操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROLLBACK TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><strong>2.READ COMMITTED</strong></p>\n<p>READ COMMITTED（已提交读）是SQL SERVER默认的隔离级别，可以避免读取未提交的数据，隔离级别比<strong>READ UNCOMMITTED</strong>未提交读的级别更高;<br>该隔离级别读操作之前首先申请并获得共享锁，允许其他读操作读取该锁定的数据，但是写操作必须等待锁释放，一般读操作读取完就会立刻释放共享锁。</p>\n<p>新建回话1将订单10的价格加1,此时回话1的排他锁锁住了订单10的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281747098898874.png\" alt=\"img\"></p>\n<p>在回话2中执行查询，将隔离级别设置为READ COMMITTED</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---由于READ COMMITTED需要申请获得共享锁，而锁与回话1的排他锁冲突，回话被堵塞，</span><br><span class=\"line\"></span><br><span class=\"line\">----在回话1中执行事务提交</span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\">&#x2F;*由于回话1事务提交，释放了订单10的排他锁，此时回话2申请共享锁成功查到到订单10的价格为修改后的价格11，READ COMMITTED由于是已提交读隔离级别，所以不会读脏数据.</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n<p>重置数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;10</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p>注意：但是由于READ COMMITTED读操作一完成就立即释放共享锁,读操作不会在一个事务过程中保持共享锁,也就是说在一个事务的的两个查询过程之间有另一个回话对数据资源进行了更改,会导致一个事务的两次查询得到的结果不一致,这种现象称之为不可重复读.</p>\n<p><strong>3.REPEATABLE READ</strong></p>\n<p>REPEATABLE READ(可重复读)：保证在一个事务中的两个读操作之间，其他的事务不能修改当前事务读取的数据，该级别事务获取数据前必须先获得共享锁同时获得的共享锁不立即释放一直保持共享锁至事务完成，所以此隔离级别查询完并提交事务很重要。</p>\n<p>在回话1中执行查询订单10,将回话级别设置为REPEATABLE READ</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p>新建回话2修改订单10的价格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---由于回话1的隔离级别REPEATABLE READ申请的共享锁一直要保持到事务结束，所以回话2无法获取排他锁，处于等待状态</span><br></pre></td></tr></table></figure>\n<p>在回话1中执行下面语句，然后提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281800071398195.png\" alt=\"img\"></p>\n<p>回话1的两次查询得到的结果一致，前面的两个隔离级别无法得到一致的数据，此时事务已提交同时释放共享锁，回话2申请排他锁成功，对行执行更新</p>\n<p>REPEATABLE READ隔离级别保证一个事务中的两次查询到的结果一致，同时保证了丢失更新<br>丢失更新：两个事务同时读取了同一个值然后基于最初的值进行计算，接着再更新，就会导致两个事务的更新相互覆盖。<br>例如酒店订房例子，两个人同时预定同一酒店的房间，首先两个人同时查询到还有一间房间可以预定，然后两个人同时提交预定操作，事务1执行number=1-0，同时事务2也执行number=1-0最后修改number=0,这就导致两个人其中一个人的操作被另一个人所覆盖，REPEATABLE READ隔离级别就能避免这种丢失更新的现象，当事务1查询房间时事务就一直保持共享锁直到事务提交，而不是像前面的几个隔离级别查询完就是否共享锁，就能避免其他事务获取排他锁。</p>\n<p> <strong>4.SERIALIZABLE</strong></p>\n<p>SERIALIZABLE(可序列化)，对于前面的REPEATABLE READ能保证事务可重复读，但是事务只锁定查询第一次运行时获取的数据资源（数据行），而不能锁定查询结果之外的行，就是原本不存在于数据表中的数据。因此在一个事务中当第一个查询和第二个查询过程之间，有其他事务执行插入操作且插入数据满足第一次查询读取过滤的条件时，那么在第二次查询的结果中就会存在这些新插入的数据，使两次查询结果不一致，这种读操作称之为幻读。<br>为了避免幻读需要将隔离级别设置为SERIALIZABLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>在回话1中执行查询操作,并将事务隔离级别设置为REPEATABLE READ(先测试一下前面更低级别的隔离)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class=\"line\">BEGIN TRANSACTION </span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281804234676071.png\" alt=\"img\"></p>\n<p>在回话2中执行插入操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO Orders VALUES(15,15.00,1)</span><br></pre></td></tr></table></figure>\n<p>返回回话1重新执行查询操作并提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281806149045782.png\" alt=\"img\"></p>\n<p>结果回话1中第二次查询到的数据包含了回话2新插入的数据，两次查询结果不一致（验证之前的隔离级别不能保证幻读）</p>\n<p>重新插入测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>接下来将回话级别设置为SERIALIZABLE,在回话1中执行查询操作,并将事务隔离级别设置为SERIALIZABLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE</span><br><span class=\"line\">BEGIN TRANSACTION </span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281809389821163.png\" alt=\"img\"></p>\n<p>在回话2中执行插入操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO Orders VALUES(15,15.00,1)</span><br></pre></td></tr></table></figure>\n<p>返回回话1重新执行查询操作并提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281810073734271.png\" alt=\"img\"></p>\n<p>两次执行的查询结果相同</p>\n<p>重置所有打开回话的默认隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br></pre></td></tr></table></figure>\n<p><strong>5.SNAPSHOT</strong></p>\n<p>SNAPSHOT快照：SNAPSHOT和READ COMMITTED SNAPSHOT两种隔离（可以把事务已经提交的行的上一版本保存在TEMPDB数据库中）<br>SNAPSHOT隔离级别在逻辑上与SERIALIZABLE类似<br>READ COMMITTED SNAPSHOT隔离级别在逻辑上与 READ COMMITTED类似<br>不过在快照隔离级别下读操作不需要申请获得共享锁，所以即便是数据已经存在排他锁也不影响读操作。而且仍然可以得到和SERIALIZABLE与READ COMMITTED隔离级别类似的一致性；如果目前版本与预期的版本不一致，读操作可以从TEMPDB中获取预期的版本。</p>\n<p>如果启用任何一种基于快照的隔离级别，DELETE和UPDATE语句在做出修改前都会把行的当前版本复制到TEMPDB中，而INSERT语句不需要在TEMPDB中进行版本控制，因为此时还没有行的旧数据</p>\n<p>无论启用哪种基于快照的隔离级别都会对更新和删除操作产生性能的负面影响，但是有利于提高读操作的性能因为读操作不需要获取共享锁；</p>\n<p><strong>5.1SNAPSHOT</strong></p>\n<p>SNAPSHOT 在SNAPSHOT隔离级别下,当读取数据时可以保证操作读取的行是事务开始时可用的最后提交版本<br>同时SNAPSHOT隔离级别也满足前面的已提交读,可重复读,不幻读;该隔离级别实用的不是共享锁,而是行版本控制<br>使用SNAPSHOT隔离级别首先需要在数据库级别上设置相关选项</p>\n<p>在打开的所有查询窗口中执行以下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET ALLOW_SNAPSHOT_ISOLATION ON;</span><br></pre></td></tr></table></figure>\n<p>重置测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在回话1中打开事务,将订单10的价格加1,并查询跟新后的价格</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---查询到更新后的价格为11</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中将隔离级别设置为SNAPSHOT,并打开事务(此时查询也不会因为回话1的排他锁而等待,依然可以查询到数据)</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL SNAPSHOT</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">---查询到的结果还是回话1修改前的价格,由于回话1在默认的READ COMMITTED隔离级别下运行,SQL SERVER必须在更新前把行的一个副本复制到TEMPDB数据库中</span><br><span class=\"line\">--在SNAPSHOT级别启动事务会请求行版本</span><br><span class=\"line\"></span><br><span class=\"line\">---现在在回话1中执行提交事务,此时订单10的价格为11</span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">---再次在回话二中查询订单10的价格并提交事务,结果还是10,因为事务要保证两次查询的结果相同</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">---此时如果在回话2中重新打开一个事务,查询到的订单10的价格则是11</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*SNAPSHOT隔离级别保证操作读取的行是事务开始时可用的最后已提交版本,由于回话1的事务未提交,所以订单10的最后提交版本还是修改前的价格10,所以回话2读取到的价格是回话2事务开始前的已提交版本价格10,当回话1提交事务后,回话2重新新建一个事务此时事务开启前的价格已经是11了，所以查询到的价格是11，同时SNAPSHOT隔离级别还能保证SERIALIZABLE的隔离级别*&#x2F;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2READ COMMITTED SNAPSHOT</strong></p>\n<p>READ COMMITTED SNAPSHOT也是基于行版本控制,但是READ COMMITTED SNAPSHOT的隔离级别是读操作之前的最后已提交版本,而不是事务前的已提交版本，有点类似前面的READ COMMITTED能保证已提交读,但是不能保证可重复读,不能避免幻读,但是又比 READ COMMITTED隔离级别多出了不需要获取共享锁就可以读取数据</p>\n<p>要启用READ COMMITTED SNAPSHOT隔离级别同样需要修改数据库选项，在回话1，回话2中执行以下操作(执行下面的操作当前连接必须是数据库的唯一连接，可以通过查询已连接当前数据库的进程,然后KILL掉那些进程,然后再执行该操作,否则可能无法执行成功)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET READ_COMMITTED_SNAPSHOT ON</span><br><span class=\"line\"></span><br><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br><span class=\"line\"></span><br><span class=\"line\">-----在回话1中打开事务,将订单10的价格加1,并查询跟新后的价格,并保持事务一直处于打开状态</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">--查询到的价格是11</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中打开事务查询订单10并一直保持事务处于打开状态(此时由于回话1还未提交事务,所以回话2中查询到的还是回话1执行事务之前保存的行版本)</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">--查询到的价格还是10</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话1中提交事务</span><br><span class=\"line\">COMMIT TRANSACTION </span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中再次执行查询订单10的价格,并提交事务</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">COMMIT TRANSACTION </span><br><span class=\"line\">--此时的价格为回话1修改后的价格11,而不是事务之前已提交版本的价格,也就是READ COMMITTED SNAPSHOT隔离级别在同一事务中两次查询的结果不一致.</span><br></pre></td></tr></table></figure>\n<p>关闭所有连接,然后打开一个新的连接,禁用之前设置的数据库快照隔离级别选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET ALLOW_SNAPSHOT_ISOLATION OFF;</span><br><span class=\"line\"></span><br><span class=\"line\">ALTER DATABASE TEST SET READ_COMMITTED_SNAPSHOT OFF;</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong></p>\n<p>   理解了事务隔离级别有助于理解事务的死锁。</p>\n","more":"<h2 id=\"SQL-Server-事务隔离级别详解\"><a href=\"#SQL-Server-事务隔离级别详解\" class=\"headerlink\" title=\"SQL Server 事务隔离级别详解\"></a><a href=\"https://www.cnblogs.com/chenmh/p/3998614.html\" target=\"_blank\" rel=\"noopener\">SQL Server 事务隔离级别详解</a></h2><p>标签： SQL SEERVER/MSSQL SERVER/SQL/事务隔离级别选项/设置数据库事务级别</p>\n<p><strong>SQL 事务隔离级别</strong></p>\n<p><strong>概述</strong></p>\n<p>​     隔离级别用于决定如果控制并发用户如何读写数据的操作，同时对性能也有一定的影响作用。</p>\n<p><strong>步骤</strong></p>\n<p>事务隔离级别通过影响读操作来间接地影响写操作；可以在回话级别上设置事务隔离级别也可以在查询（表级别）级别上设置事务隔离级别。<br>事务隔离级别总共有6个隔离级别：<br>READ UNCOMMITTED(未提交读,读脏),相当于(NOLOCK)<br>READ COMMITTED(已提交读,默认级别)<br>REPEATABLE READ(可以重复读),相当于(HOLDLOCK)<br>SERIALIZABLE(可序列化)<br>SNAPSHOT(快照)<br>READ COMMITTED SNAPSHOT(已经提交读隔离)<br>对于前四个隔离级别：READ UNCOMMITTED<READ COMMITTED<REPEATABLE READ<SERIALIZABLE\n隔离级别越高,读操作的请求锁定就越严格,锁的持有时间久越长;所以隔离级别越高,一致性就越高,并发性就越低,同时性能也相对影响越大.<sunfy-line></p>\n<p><strong>获取事务隔离级别(isolation level)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBCC USEROPTIONS</span><br></pre></td></tr></table></figure>\n<p><strong>设置隔离</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设置回话隔离</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL &lt;ISOLATION NAME&gt;</span><br><span class=\"line\">--注意:在设置回话隔离时(REPEATABLE READ)两个单词需要用空格间隔开,但是在表隔离中可以粘在一起(REPEATABLEREAD)</span><br><span class=\"line\"></span><br><span class=\"line\">设置查询表隔离</span><br><span class=\"line\">SELECT ....FROM &lt;TABLE&gt; WITH (&lt;ISOLATION NAME&gt;)</span><br></pre></td></tr></table></figure>\n<p><strong>1.READ UNCOMMITTED</strong></p>\n<p>READ UNCOMMITTED:未提交读，读脏数据<br>默认的读操作:需要请求共享锁,允许其他事物读锁定的数据但不允许修改.<br>READ UNCOMMITTED:读操作不申请锁,运行读取未提交的修改,也就是允许读脏数据,读操作不会影响写操作请求排他锁.</p>\n<p> 创建测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL,</span><br><span class=\"line\">Price FLOAT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00),(11,11.00),(12,12.00),(13,13.00),(14,14.00);</span><br><span class=\"line\">GO</span><br><span class=\"line\">SELECT ID,Price FROM Orders</span><br></pre></td></tr></table></figure>\n<p>新建回话1将订单10的价格加1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281738195298579.png\" alt=\"img\"></p>\n<p>在另一个回话2中执行查询操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先不添加隔离级别,默认是READ COMMITTED,由于数据之前的更新操作使用了排他锁，所以查询一直在等待锁释放*&#x2F;</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---将查询的隔离级别设置为READ UNCOMMITTED允许未提交读，读操作之前不请求共享锁。</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10;</span><br><span class=\"line\">--当然也可以使用表隔离,效果是一样的</span><br><span class=\"line\">SELECT ID,Price FROM Orders WITH (NOLOCK)</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281741564356912.png\" alt=\"img\"></p>\n<p>假设在回话1中对操作执行回滚操作,这样价格还是之前的10,但是回话2中则读取到的是回滚前的价格11,这样就属于一个读脏操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROLLBACK TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><strong>2.READ COMMITTED</strong></p>\n<p>READ COMMITTED（已提交读）是SQL SERVER默认的隔离级别，可以避免读取未提交的数据，隔离级别比<strong>READ UNCOMMITTED</strong>未提交读的级别更高;<br>该隔离级别读操作之前首先申请并获得共享锁，允许其他读操作读取该锁定的数据，但是写操作必须等待锁释放，一般读操作读取完就会立刻释放共享锁。</p>\n<p>新建回话1将订单10的价格加1,此时回话1的排他锁锁住了订单10的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281747098898874.png\" alt=\"img\"></p>\n<p>在回话2中执行查询，将隔离级别设置为READ COMMITTED</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---由于READ COMMITTED需要申请获得共享锁，而锁与回话1的排他锁冲突，回话被堵塞，</span><br><span class=\"line\"></span><br><span class=\"line\">----在回话1中执行事务提交</span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\">&#x2F;*由于回话1事务提交，释放了订单10的排他锁，此时回话2申请共享锁成功查到到订单10的价格为修改后的价格11，READ COMMITTED由于是已提交读隔离级别，所以不会读脏数据.</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n<p>重置数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;10</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p>注意：但是由于READ COMMITTED读操作一完成就立即释放共享锁,读操作不会在一个事务过程中保持共享锁,也就是说在一个事务的的两个查询过程之间有另一个回话对数据资源进行了更改,会导致一个事务的两次查询得到的结果不一致,这种现象称之为不可重复读.</p>\n<p><strong>3.REPEATABLE READ</strong></p>\n<p>REPEATABLE READ(可重复读)：保证在一个事务中的两个读操作之间，其他的事务不能修改当前事务读取的数据，该级别事务获取数据前必须先获得共享锁同时获得的共享锁不立即释放一直保持共享锁至事务完成，所以此隔离级别查询完并提交事务很重要。</p>\n<p>在回话1中执行查询订单10,将回话级别设置为REPEATABLE READ</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br></pre></td></tr></table></figure>\n<p>新建回话2修改订单10的价格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---由于回话1的隔离级别REPEATABLE READ申请的共享锁一直要保持到事务结束，所以回话2无法获取排他锁，处于等待状态</span><br></pre></td></tr></table></figure>\n<p>在回话1中执行下面语句，然后提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price FROM Orders </span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281800071398195.png\" alt=\"img\"></p>\n<p>回话1的两次查询得到的结果一致，前面的两个隔离级别无法得到一致的数据，此时事务已提交同时释放共享锁，回话2申请排他锁成功，对行执行更新</p>\n<p>REPEATABLE READ隔离级别保证一个事务中的两次查询到的结果一致，同时保证了丢失更新<br>丢失更新：两个事务同时读取了同一个值然后基于最初的值进行计算，接着再更新，就会导致两个事务的更新相互覆盖。<br>例如酒店订房例子，两个人同时预定同一酒店的房间，首先两个人同时查询到还有一间房间可以预定，然后两个人同时提交预定操作，事务1执行number=1-0，同时事务2也执行number=1-0最后修改number=0,这就导致两个人其中一个人的操作被另一个人所覆盖，REPEATABLE READ隔离级别就能避免这种丢失更新的现象，当事务1查询房间时事务就一直保持共享锁直到事务提交，而不是像前面的几个隔离级别查询完就是否共享锁，就能避免其他事务获取排他锁。</p>\n<p> <strong>4.SERIALIZABLE</strong></p>\n<p>SERIALIZABLE(可序列化)，对于前面的REPEATABLE READ能保证事务可重复读，但是事务只锁定查询第一次运行时获取的数据资源（数据行），而不能锁定查询结果之外的行，就是原本不存在于数据表中的数据。因此在一个事务中当第一个查询和第二个查询过程之间，有其他事务执行插入操作且插入数据满足第一次查询读取过滤的条件时，那么在第二次查询的结果中就会存在这些新插入的数据，使两次查询结果不一致，这种读操作称之为幻读。<br>为了避免幻读需要将隔离级别设置为SERIALIZABLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>在回话1中执行查询操作,并将事务隔离级别设置为REPEATABLE READ(先测试一下前面更低级别的隔离)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class=\"line\">BEGIN TRANSACTION </span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281804234676071.png\" alt=\"img\"></p>\n<p>在回话2中执行插入操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO Orders VALUES(15,15.00,1)</span><br></pre></td></tr></table></figure>\n<p>返回回话1重新执行查询操作并提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281806149045782.png\" alt=\"img\"></p>\n<p>结果回话1中第二次查询到的数据包含了回话2新插入的数据，两次查询结果不一致（验证之前的隔离级别不能保证幻读）</p>\n<p>重新插入测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<p>接下来将回话级别设置为SERIALIZABLE,在回话1中执行查询操作,并将事务隔离级别设置为SERIALIZABLE</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE</span><br><span class=\"line\">BEGIN TRANSACTION </span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281809389821163.png\" alt=\"img\"></p>\n<p>在回话2中执行插入操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO Orders VALUES(15,15.00,1)</span><br></pre></td></tr></table></figure>\n<p>返回回话1重新执行查询操作并提交事务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE TYPE&#x3D;1</span><br><span class=\"line\">COMMIT TRANSACTION</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/事务隔离级别/281810073734271.png\" alt=\"img\"></p>\n<p>两次执行的查询结果相同</p>\n<p>重置所有打开回话的默认隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br></pre></td></tr></table></figure>\n<p><strong>5.SNAPSHOT</strong></p>\n<p>SNAPSHOT快照：SNAPSHOT和READ COMMITTED SNAPSHOT两种隔离（可以把事务已经提交的行的上一版本保存在TEMPDB数据库中）<br>SNAPSHOT隔离级别在逻辑上与SERIALIZABLE类似<br>READ COMMITTED SNAPSHOT隔离级别在逻辑上与 READ COMMITTED类似<br>不过在快照隔离级别下读操作不需要申请获得共享锁，所以即便是数据已经存在排他锁也不影响读操作。而且仍然可以得到和SERIALIZABLE与READ COMMITTED隔离级别类似的一致性；如果目前版本与预期的版本不一致，读操作可以从TEMPDB中获取预期的版本。</p>\n<p>如果启用任何一种基于快照的隔离级别，DELETE和UPDATE语句在做出修改前都会把行的当前版本复制到TEMPDB中，而INSERT语句不需要在TEMPDB中进行版本控制，因为此时还没有行的旧数据</p>\n<p>无论启用哪种基于快照的隔离级别都会对更新和删除操作产生性能的负面影响，但是有利于提高读操作的性能因为读操作不需要获取共享锁；</p>\n<p><strong>5.1SNAPSHOT</strong></p>\n<p>SNAPSHOT 在SNAPSHOT隔离级别下,当读取数据时可以保证操作读取的行是事务开始时可用的最后提交版本<br>同时SNAPSHOT隔离级别也满足前面的已提交读,可重复读,不幻读;该隔离级别实用的不是共享锁,而是行版本控制<br>使用SNAPSHOT隔离级别首先需要在数据库级别上设置相关选项</p>\n<p>在打开的所有查询窗口中执行以下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET ALLOW_SNAPSHOT_ISOLATION ON;</span><br></pre></td></tr></table></figure>\n<p>重置测试数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在回话1中打开事务,将订单10的价格加1,并查询跟新后的价格</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">---查询到更新后的价格为11</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中将隔离级别设置为SNAPSHOT,并打开事务(此时查询也不会因为回话1的排他锁而等待,依然可以查询到数据)</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL SNAPSHOT</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">---查询到的结果还是回话1修改前的价格,由于回话1在默认的READ COMMITTED隔离级别下运行,SQL SERVER必须在更新前把行的一个副本复制到TEMPDB数据库中</span><br><span class=\"line\">--在SNAPSHOT级别启动事务会请求行版本</span><br><span class=\"line\"></span><br><span class=\"line\">---现在在回话1中执行提交事务,此时订单10的价格为11</span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">---再次在回话二中查询订单10的价格并提交事务,结果还是10,因为事务要保证两次查询的结果相同</span><br><span class=\"line\"></span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">---此时如果在回话2中重新打开一个事务,查询到的订单10的价格则是11</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">COMMIT TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*SNAPSHOT隔离级别保证操作读取的行是事务开始时可用的最后已提交版本,由于回话1的事务未提交,所以订单10的最后提交版本还是修改前的价格10,所以回话2读取到的价格是回话2事务开始前的已提交版本价格10,当回话1提交事务后,回话2重新新建一个事务此时事务开启前的价格已经是11了，所以查询到的价格是11，同时SNAPSHOT隔离级别还能保证SERIALIZABLE的隔离级别*&#x2F;</span><br></pre></td></tr></table></figure>\n<p><strong>5.2READ COMMITTED SNAPSHOT</strong></p>\n<p>READ COMMITTED SNAPSHOT也是基于行版本控制,但是READ COMMITTED SNAPSHOT的隔离级别是读操作之前的最后已提交版本,而不是事务前的已提交版本，有点类似前面的READ COMMITTED能保证已提交读,但是不能保证可重复读,不能避免幻读,但是又比 READ COMMITTED隔离级别多出了不需要获取共享锁就可以读取数据</p>\n<p>要启用READ COMMITTED SNAPSHOT隔离级别同样需要修改数据库选项，在回话1，回话2中执行以下操作(执行下面的操作当前连接必须是数据库的唯一连接，可以通过查询已连接当前数据库的进程,然后KILL掉那些进程,然后再执行该操作,否则可能无法执行成功)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET READ_COMMITTED_SNAPSHOT ON</span><br><span class=\"line\"></span><br><span class=\"line\">IF OBJECT_ID(&#39;Orders&#39;,&#39;U&#39;) IS NOT NULL DROP TABLE Orders </span><br><span class=\"line\">GO</span><br><span class=\"line\">CREATE TABLE Orders</span><br><span class=\"line\">(ID INT NOT NULL PRIMARY KEY,</span><br><span class=\"line\">Price FLOAT NOT NULL,</span><br><span class=\"line\">type INT NOT NULL</span><br><span class=\"line\">);</span><br><span class=\"line\">INSERT INTO Orders VALUES(10,10.00,1),(11,11.00,1),(12,12.00,1),(13,13.00,1),(14,14.00,1);</span><br><span class=\"line\">GO</span><br><span class=\"line\"></span><br><span class=\"line\">-----在回话1中打开事务,将订单10的价格加1,并查询跟新后的价格,并保持事务一直处于打开状态</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">UPDATE Orders </span><br><span class=\"line\">SET Price&#x3D;Price+1</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">--查询到的价格是11</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中打开事务查询订单10并一直保持事务处于打开状态(此时由于回话1还未提交事务,所以回话2中查询到的还是回话1执行事务之前保存的行版本)</span><br><span class=\"line\">BEGIN TRANSACTION</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">--查询到的价格还是10</span><br><span class=\"line\"></span><br><span class=\"line\">---在回话1中提交事务</span><br><span class=\"line\">COMMIT TRANSACTION </span><br><span class=\"line\"></span><br><span class=\"line\">---在回话2中再次执行查询订单10的价格,并提交事务</span><br><span class=\"line\">SELECT ID,Price,type FROM Orders</span><br><span class=\"line\">WHERE ID&#x3D;10</span><br><span class=\"line\">COMMIT TRANSACTION </span><br><span class=\"line\">--此时的价格为回话1修改后的价格11,而不是事务之前已提交版本的价格,也就是READ COMMITTED SNAPSHOT隔离级别在同一事务中两次查询的结果不一致.</span><br></pre></td></tr></table></figure>\n<p>关闭所有连接,然后打开一个新的连接,禁用之前设置的数据库快照隔离级别选项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER DATABASE TEST SET ALLOW_SNAPSHOT_ISOLATION OFF;</span><br><span class=\"line\"></span><br><span class=\"line\">ALTER DATABASE TEST SET READ_COMMITTED_SNAPSHOT OFF;</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong></p>\n<p>   理解了事务隔离级别有助于理解事务的死锁。</p>\n","next":{"title":"java技术栈","path":"api/articles/resource-java-Base-java技术栈.json","image":"/img/header_img/java/java.png","num_read":665,"num_like":950,"num_collection":165,"num_comments":32},"prev":{"title":"关于2>&1 &的详细解释","path":"api/articles/resource-MicroService-other-关于2-1-的详细解释.json","image":"/img/header_img/MicroService/MicroService.PNG","num_read":1775,"num_like":123,"num_collection":176,"num_comments":123},"categories":[{"name":"数据库","path":"api/categories/数据库.json","pathContent":"api/categories/数据库","description":"结构化存储格式+事务和并发控制+内存管理+SQL访问接口","cover":"https://sunfy9.gitee.io/project/photo/project/db.jpg"}],"tags":[{"name":"sqlServer","path":"api/tags/sqlServer.json","pathContent":"api/tags/sqlServer","description":"[sqlServer]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}