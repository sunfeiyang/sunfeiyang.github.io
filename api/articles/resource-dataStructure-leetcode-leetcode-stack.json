{"title":"数据结构测试题---栈/队列","num_read":1808,"num_like":1072,"num_collection":866,"num_comments":27,"slug":"resource-dataStructure-leetcode-leetcode-stack","date":"2021-09-01T16:00:00.000Z","img":"/img/header_img/dataStructure/stack.jpg","format":"max","_id":"clhrbp2aj0000o5lgh1gsawiz","project":"dataStructure","site":{"data":{}},"updated":"2022-01-15T04:11:26.000Z","comments":true,"path":"api/articles/resource-dataStructure-leetcode-leetcode-stack.json","webPath":"2021/09/02/resource-dataStructure-leetcode-leetcode-stack/","permalink":"https://sunfy9.gitee.io/2021/09/02/resource-dataStructure-leetcode-leetcode-stack/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. 有效的括号</a></h1><p><a href=\"https://sunfy.top/2021/07/12/resource-file-algorithm-800-algorithm/#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：s = \"()\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：s = \"()[]&#123;&#125;\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：s = \"(]\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：s = \"([)]\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 5：</span><br><span class=\"line\">输入：s = \"&#123;[]&#125;\"</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 仅由括号 <code>&#39;()[]{}&#39;</code> 组成</li>\n</ul>\n<h2 id=\"方法一：栈\"><a href=\"#方法一：栈\" class=\"headerlink\" title=\"方法一：栈\"></a><sunfy-line>方法一：栈</h2><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p>\n<p>我们遍历给定的字符串 <code>s</code>。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>\n<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 <code>s</code> 无效，返回 <code>False</code>。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p>\n<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 <code>s</code> 中的所有左括号闭合，返回 <code>True</code>，否则返回 <code>False</code>。</p>\n<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Character, Character&gt; pairs = <span class=\"keyword\">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class=\"line\">            put(<span class=\"string\">')'</span>, <span class=\"string\">'('</span>);</span><br><span class=\"line\">            put(<span class=\"string\">']'</span>, <span class=\"string\">'['</span>);</span><br><span class=\"line\">            put(<span class=\"string\">'&#125;'</span>, <span class=\"string\">'&#123;'</span>);</span><br><span class=\"line\">        &#125;&#125;;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;Character&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li>\n<li>空间复杂度：<code>O(n+∣Σ∣)</code>，其中 <code>Σ</code> 表示字符集，本题中字符串只包含 <code>6</code> 种括号，<code>∣Σ∣=6</code>。栈中的字符数量为 <code>O(n)</code>，而哈希表使用的空间为 <code>O(∣Σ∣)</code>，相加即可得到总空间复杂度。</li>\n</ul>\n<h1 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232. 用栈实现队列\"></a><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\" target=\"_blank\" rel=\"noopener\">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>\n<p>实现 <code>MyQueue</code> 类：</p>\n<ul>\n<li>void push(int x) 将元素 x 推到队列的末尾</li>\n<li>int pop() 从队列的开头移除并返回元素</li>\n<li>int peek() 返回队列开头的元素</li>\n<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>\n<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n</ul>\n<p>进阶：</p>\n<ul>\n<li>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\"><span class=\"section\">[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]</span></span><br><span class=\"line\">[[], [1], [2], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"section\">[null, null, null, 1, 1, false]</span></span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MyQueue myQueue = new MyQueue();</span><br><span class=\"line\">myQueue.push(1); // queue is: [1]</span><br><span class=\"line\">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class=\"line\">myQueue.peek(); // return 1</span><br><span class=\"line\">myQueue.pop(); // return 1, queue is [2]</span><br><span class=\"line\">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= x &lt;= 9</li>\n<li>最多调用 100 次 push、pop、peek 和 empty</li>\n<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</li>\n</ul>\n<h2 id=\"方法一：双栈\"><a href=\"#方法一：双栈\" class=\"headerlink\" title=\"方法一：双栈\"></a>方法一：双栈</h2><p>思路</p>\n<p>将一个栈当作输入栈，用于压入 <code>push</code> 传入的数据；另一个栈当作输出栈，用于 <code>pop</code> 和 <code>peek</code> 操作。</p>\n<p>每次 <code>pop</code> 或 <code>peek</code> 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> </span>&#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; inStack;</span><br><span class=\"line\">    Deque&lt;Integer&gt; outStack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        inStack = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        outStack = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        inStack.push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outStack.isEmpty()) &#123;</span><br><span class=\"line\">            in2out();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outStack.isEmpty()) &#123;</span><br><span class=\"line\">            in2out();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">in2out</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!inStack.isEmpty()) &#123;</span><br><span class=\"line\">            outStack.push(inStack.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>push</code> 和 <code>empty</code> 为 <code>O(1)</code>，<code>pop</code> 和 <code>peek</code> 为均摊 <code>O(1)</code>。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 <code>O(1)</code>。</li>\n<li>空间复杂度：<code>O(n)</code>。其中 <code>n</code> 是操作总数。对于有 <code>n</code> 次 <code>push</code> 操作的情况，队列中会有 <code>n</code> 个元素，故空间复杂度为 <code>O(n)</code>。</li>\n</ul>\n","more":"<h1 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" target=\"_blank\" rel=\"noopener\">20. 有效的括号</a></h1><p><a href=\"https://sunfy.top/2021/07/12/resource-file-algorithm-800-algorithm/#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\" target=\"_blank\" rel=\"noopener\">站内链接</a></p>\n<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：s = \"()\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：s = \"()[]&#123;&#125;\"</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：s = \"(]\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\">输入：s = \"([)]\"</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">示例 5：</span><br><span class=\"line\">输入：s = \"&#123;[]&#125;\"</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 仅由括号 <code>&#39;()[]{}&#39;</code> 组成</li>\n</ul>\n<h2 id=\"方法一：栈\"><a href=\"#方法一：栈\" class=\"headerlink\" title=\"方法一：栈\"></a><sunfy-line>方法一：栈</h2><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p>\n<p>我们遍历给定的字符串 <code>s</code>。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p>\n<p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 <code>s</code> 无效，返回 <code>False</code>。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p>\n<p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 <code>s</code> 中的所有左括号闭合，返回 <code>True</code>，否则返回 <code>False</code>。</p>\n<p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 <code>False</code>，省去后续的遍历判断过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Map&lt;Character, Character&gt; pairs = <span class=\"keyword\">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;</span><br><span class=\"line\">            put(<span class=\"string\">')'</span>, <span class=\"string\">'('</span>);</span><br><span class=\"line\">            put(<span class=\"string\">']'</span>, <span class=\"string\">'['</span>);</span><br><span class=\"line\">            put(<span class=\"string\">'&#125;'</span>, <span class=\"string\">'&#123;'</span>);</span><br><span class=\"line\">        &#125;&#125;;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;Character&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.pop();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li>\n<li>空间复杂度：<code>O(n+∣Σ∣)</code>，其中 <code>Σ</code> 表示字符集，本题中字符串只包含 <code>6</code> 种括号，<code>∣Σ∣=6</code>。栈中的字符数量为 <code>O(n)</code>，而哈希表使用的空间为 <code>O(∣Σ∣)</code>，相加即可得到总空间复杂度。</li>\n</ul>\n<h1 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232. 用栈实现队列\"></a><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\" target=\"_blank\" rel=\"noopener\">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>\n<p>实现 <code>MyQueue</code> 类：</p>\n<ul>\n<li>void push(int x) 将元素 x 推到队列的末尾</li>\n<li>int pop() 从队列的开头移除并返回元素</li>\n<li>int peek() 返回队列开头的元素</li>\n<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>\n</ul>\n<p>说明：</p>\n<ul>\n<li>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>\n<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n</ul>\n<p>进阶：</p>\n<ul>\n<li>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\"><span class=\"section\">[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]</span></span><br><span class=\"line\">[[], [1], [2], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"section\">[null, null, null, 1, 1, false]</span></span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MyQueue myQueue = new MyQueue();</span><br><span class=\"line\">myQueue.push(1); // queue is: [1]</span><br><span class=\"line\">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class=\"line\">myQueue.peek(); // return 1</span><br><span class=\"line\">myQueue.pop(); // return 1, queue is [2]</span><br><span class=\"line\">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= x &lt;= 9</li>\n<li>最多调用 100 次 push、pop、peek 和 empty</li>\n<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</li>\n</ul>\n<h2 id=\"方法一：双栈\"><a href=\"#方法一：双栈\" class=\"headerlink\" title=\"方法一：双栈\"></a>方法一：双栈</h2><p>思路</p>\n<p>将一个栈当作输入栈，用于压入 <code>push</code> 传入的数据；另一个栈当作输出栈，用于 <code>pop</code> 和 <code>peek</code> 操作。</p>\n<p>每次 <code>pop</code> 或 <code>peek</code> 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> </span>&#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; inStack;</span><br><span class=\"line\">    Deque&lt;Integer&gt; outStack;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        inStack = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        outStack = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        inStack.push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outStack.isEmpty()) &#123;</span><br><span class=\"line\">            in2out();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outStack.isEmpty()) &#123;</span><br><span class=\"line\">            in2out();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">in2out</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!inStack.isEmpty()) &#123;</span><br><span class=\"line\">            outStack.push(inStack.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>push</code> 和 <code>empty</code> 为 <code>O(1)</code>，<code>pop</code> 和 <code>peek</code> 为均摊 <code>O(1)</code>。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 <code>O(1)</code>。</li>\n<li>空间复杂度：<code>O(n)</code>。其中 <code>n</code> 是操作总数。对于有 <code>n</code> 次 <code>push</code> 操作的情况，队列中会有 <code>n</code> 个元素，故空间复杂度为 <code>O(n)</code>。</li>\n</ul>\n","next":{"title":"定时刷新页面","path":"api/articles/resource-desk-html-定时刷新页面.json","image":"/img/header_img/desk/refresh.gif","num_read":774,"num_like":226,"num_collection":168,"num_comments":123},"prev":{"title":"微服务基本介绍","path":"api/articles/resource-MicroService-other-微服务基本介绍.json","image":"/img/header_img/MicroService/MicroService.PNG","num_read":1350,"num_like":877,"num_collection":495,"num_comments":160},"categories":[{"name":"数据结构","path":"api/categories/数据结构.json","pathContent":"api/categories/数据结构","description":"一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。","cover":"https://sunfy9.gitee.io/project/photo/project/dataStructure.png"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json","pathContent":"api/tags/leetcode","description":"[leetcode]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}