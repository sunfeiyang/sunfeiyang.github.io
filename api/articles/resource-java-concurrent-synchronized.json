{"title":"synchronized原理分析","num_read":671,"num_like":563,"num_collection":313,"num_comments":125,"slug":"resource-java-concurrent-synchronized","date":"2021-11-16T16:00:00.000Z","img":"/img/header_img/concurrent/synchronized.png","_id":"clhrbp2dl0097o5lgegl65gvn","project":"concurrent","subtitle":"用于屏蔽掉各种硬件和操作系统的内存访问差异，原理分析","site":{"data":{}},"updated":"2022-01-12T05:42:00.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-synchronized.json","webPath":"2021/11/17/resource-java-concurrent-synchronized/","permalink":"https://sunfy9.gitee.io/2021/11/17/resource-java-concurrent-synchronized/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>应用场景： 解决线程安全问题</p>\n<p>加锁： 序列化的访问临界资源</p>\n<p>java中的实现 :    </p>\n<ul>\n<li>阻塞： synchronized reentrantLock</li>\n<li>非阻塞：  cas+自旋</li>\n</ul>\n<h1 id=\"synchronized的使用\"><a href=\"#synchronized的使用\" class=\"headerlink\" title=\"synchronized的使用\"></a>synchronized的使用</h1><p>方式：  方法上    代码块中    （锁对象）</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>jvm指令：  方法上（acc_synchronized ）  代码块（ monitorenter monitorexit）</p>\n<p>管程（Monitor): java锁体系的设计思想，设计理论基础</p>\n<p>MESA：  入口等待队列 （互斥）     多个条件队列 （同步    阻塞唤醒机制）</p>\n<p>java实现monitor:    Object     wait/notify/notifyAll     重量级操作 ： （用户态到内核态的切换） </p>\n<p>优化： 重量级锁     偏向锁   轻量级锁</p>\n<p>偏向锁： 不存在竞争       偏向某个线程     thread1,后续进入同步块的逻辑没有加锁解锁的开销</p>\n<p>轻量级锁： 线程间存在轻微的竞争（线程交替执行，临界区逻辑简单）  CAS获取锁，失败膨胀</p>\n<p>重量级锁：  多线程竞争激烈的场景     膨胀期间创建一个monitor对象      CAS自旋     阻塞</p>\n<p>加锁/解锁      加锁解锁的标记    识别是哪种锁（锁状态）</p>\n<p>synchronized加锁加在对象上，锁对象是如何记录锁状态的？</p>\n<p><strong>对象的内存布局</strong> </p>\n<p>跟踪锁状态如何变化的？  </p>\n<p>误区：</p>\n<p>关于偏向锁轻量级锁重量级锁存在的理解误区:</p>\n<ul>\n<li><p>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级2锁       （不存在无锁——&gt;偏向锁）</p>\n<p> 2.轻量级锁自旋获取锁失败，会膨胀升级为重量级锁             （轻量级锁不存在自旋）</p>\n</li>\n<li><p>重量级锁不存在自旋     （重量级锁存在自旋 ）</p>\n</li>\n</ul>\n<p>jvm对synchronized的优化</p>\n<p>针对偏向锁（偏向锁撤销存在性能问题）  批量重偏向  批量撤销</p>\n<p>针对重量级锁 ：  自旋优化  自适应自旋</p>\n<p>锁粗化， 锁消除</p>\n","more":"<h1 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h1><p>应用场景： 解决线程安全问题</p>\n<p>加锁： 序列化的访问临界资源</p>\n<p>java中的实现 :    </p>\n<ul>\n<li>阻塞： synchronized reentrantLock</li>\n<li>非阻塞：  cas+自旋</li>\n</ul>\n<h1 id=\"synchronized的使用\"><a href=\"#synchronized的使用\" class=\"headerlink\" title=\"synchronized的使用\"></a>synchronized的使用</h1><p>方式：  方法上    代码块中    （锁对象）</p>\n<h1 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h1><p>jvm指令：  方法上（acc_synchronized ）  代码块（ monitorenter monitorexit）</p>\n<p>管程（Monitor): java锁体系的设计思想，设计理论基础</p>\n<p>MESA：  入口等待队列 （互斥）     多个条件队列 （同步    阻塞唤醒机制）</p>\n<p>java实现monitor:    Object     wait/notify/notifyAll     重量级操作 ： （用户态到内核态的切换） </p>\n<p>优化： 重量级锁     偏向锁   轻量级锁</p>\n<p>偏向锁： 不存在竞争       偏向某个线程     thread1,后续进入同步块的逻辑没有加锁解锁的开销</p>\n<p>轻量级锁： 线程间存在轻微的竞争（线程交替执行，临界区逻辑简单）  CAS获取锁，失败膨胀</p>\n<p>重量级锁：  多线程竞争激烈的场景     膨胀期间创建一个monitor对象      CAS自旋     阻塞</p>\n<p>加锁/解锁      加锁解锁的标记    识别是哪种锁（锁状态）</p>\n<p>synchronized加锁加在对象上，锁对象是如何记录锁状态的？</p>\n<p><strong>对象的内存布局</strong> </p>\n<p>跟踪锁状态如何变化的？  </p>\n<p>误区：</p>\n<p>关于偏向锁轻量级锁重量级锁存在的理解误区:</p>\n<ul>\n<li><p>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级2锁       （不存在无锁——&gt;偏向锁）</p>\n<p> 2.轻量级锁自旋获取锁失败，会膨胀升级为重量级锁             （轻量级锁不存在自旋）</p>\n</li>\n<li><p>重量级锁不存在自旋     （重量级锁存在自旋 ）</p>\n</li>\n</ul>\n<p>jvm对synchronized的优化</p>\n<p>针对偏向锁（偏向锁撤销存在性能问题）  批量重偏向  批量撤销</p>\n<p>针对重量级锁 ：  自旋优化  自适应自旋</p>\n<p>锁粗化， 锁消除</p>\n","next":{"title":"synchronized基本使用","path":"api/articles/resource-java-concurrent-synchronizedBase.json","image":"/img/header_img/concurrent/synchronizedBase.png","num_read":617,"num_like":596,"num_collection":556,"num_comments":133},"prev":{"title":"Oauth2协议及其密码授权模式","isLock":true,"path":"api/articles/resource-MicroService-other-oauth2.json","image":"/img/header_img/MicroService/oauth2.png","num_read":1590,"num_like":44,"num_collection":701,"num_comments":106},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}