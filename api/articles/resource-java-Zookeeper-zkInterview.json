{"title":"Zookeeper常见的面试题","num_read":187,"num_like":767,"num_collection":509,"num_comments":279,"slug":"resource-java-Zookeeper-zkInterview","date":"2022-01-04T16:00:00.000Z","img":"/img/header_img/zookeeper.png","_id":"clhrbp2dj008no5lg18v1cgas","type":"like","subtitle":"常见的Zookeeper面试题集锦","site":{"data":{}},"updated":"2022-01-13T13:47:54.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-Zookeeper-zkInterview.json","webPath":"2022/01/05/resource-java-Zookeeper-zkInterview/","permalink":"https://sunfy9.gitee.io/2022/01/05/resource-java-Zookeeper-zkInterview/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>简述ZAB 协议</p>\n<p>zk的数据模型和节点类型</p>\n<p>简述zk的命名服务、配置管理、集群管理</p>\n<p>Zookeeper watch机制</p>\n<p>zk和eureka的区别<sunfy-line></p>\n<h1 id=\"简述ZAB协议\"><a href=\"#简述ZAB协议\" class=\"headerlink\" title=\"简述ZAB协议\"></a>简述ZAB协议</h1><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性</p>\n<p>所有客户端的请求都是写入到Leader进程中，然后，由Leader同步到其他节点，称为Follower。在集群数据同步的过程中，如果出现Follower节点崩溃或者Leader进程崩溃时，都会通过Zab协议来保证数据一致性</p>\n<p>ZAB协议包括两种基本的模式：<strong>崩溃恢复和消息广播</strong>。</p>\n<h2 id=\"消息广播：\"><a href=\"#消息广播：\" class=\"headerlink\" title=\"消息广播：\"></a>消息广播：</h2><p>集群中所有的事务请求都由Leader节点来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal分发给集群中其他所有的Follower。</p>\n<p>完成广播之后，Leader等待Follwer反馈，当有过半数的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit信息就是确认将之前的Proposal提交。</p>\n<p>Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数&gt;=N/2+1，N是全部的Follower节点数量。</p>\n<h2 id=\"崩溃恢复：\"><a href=\"#崩溃恢复：\" class=\"headerlink\" title=\"崩溃恢复：\"></a>崩溃恢复：</h2><ul>\n<li>初始化集群，刚刚启动的时候</li>\n<li>Leader崩溃，因为故障宕机</li>\n<li>Leader失去了半数的机器支持，与集群中超过一半的节点断连</li>\n</ul>\n<p>此时开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，使数据一致，当与过半的机器同步完成后，就退出恢复模式，然后进入消息广播模式</p>\n<p>整个ZooKeeper集群的一致性保证就是在上面两个状态之前切换，当Leader服务正常时，就是正常的消息广播模式；当Leader不可用时，则进入崩溃恢复模式，崩溃恢复阶段会进行数据同步，完成以后，重新进入消息广播阶段。</p>\n<p>Zxid是Zab协议的一个事务编号，Zxid是一个64位的数字，其中低32位是一个简单的单调递增计数器，针对客户端每一个事务请求，计数器加1；而高32位则代表Leader周期年代的编号。</p>\n<p>Leader周期（epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的Leader选举出现时，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值，然后加1，以此作为新的周期ID。高32位代表了每代Leader的唯一性，低32位则代表了每代Leader中事务的唯一性。</p>\n<h2 id=\"zab节点的三种状态：\"><a href=\"#zab节点的三种状态：\" class=\"headerlink\" title=\"zab节点的三种状态：\"></a>zab节点的三种状态：</h2><ul>\n<li>following：服从leader的命令</li>\n<li>leading：负责协调事务</li>\n<li>election/looking：选举状态</li>\n</ul>\n<h1 id=\"zk的数据模型和节点类型\"><a href=\"#zk的数据模型和节点类型\" class=\"headerlink\" title=\"zk的数据模型和节点类型\"></a>zk的数据模型和节点类型</h1><p>数据模型：树形结构</p>\n<p>zk维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。</p>\n<p>zk在内存中构造了个DataTree的数据结构，维护着path到dataNode的映射以及dataNode间的树状层级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以，zk最适于读多写少且轻量级数据的应用场景。</p>\n<p>数据仅存储在内存是很不安全的，zk采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢失的情况下能快速恢复。</p>\n<p>树中的每个节点被称为—Znode</p>\n<p>Znode兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子Znode。具有增、删、改、查等操作。</p>\n<p>Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作</p>\n<p>Znode存储数据大小有限制。每个Znode的数据大小至多1M，常规使用中应该远小于此值。</p>\n<p>Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”/zookeeper”用以保存管理信息，比如关键配额信息。</p>\n<p>持久节点：一旦创建、该数据节点会一直存储在zk服务器上、即使创建该节点的客户端与服务端的会话关闭了、该节点也不会被删除</p>\n<p>临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在zk上被删除。</p>\n<p>有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性质。</p>\n<h1 id=\"简述zk的命名服务、配置管理、集群管理\"><a href=\"#简述zk的命名服务、配置管理、集群管理\" class=\"headerlink\" title=\"简述zk的命名服务、配置管理、集群管理\"></a>简述zk的命名服务、配置管理、集群管理</h1><h2 id=\"命名服务：\"><a href=\"#命名服务：\" class=\"headerlink\" title=\"命名服务：\"></a>命名服务：</h2><p>通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</p>\n<h2 id=\"配置管理：\"><a href=\"#配置管理：\" class=\"headerlink\" title=\"配置管理：\"></a>配置管理：</h2><p>实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p>\n<h2 id=\"集群管理：\"><a href=\"#集群管理：\" class=\"headerlink\" title=\"集群管理：\"></a>集群管理：</h2><p>集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对应的临时目录节点会被删除，其他所有机器都收到通知。新机器加入也是类似。</p>\n<h1 id=\"Zookeeper-watch机制\"><a href=\"#Zookeeper-watch机制\" class=\"headerlink\" title=\"Zookeeper watch机制\"></a>Zookeeper watch机制</h1><p>客户端，可以通过在znode上设置watch，实现实时监听znode的变化</p>\n<p>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端</p>\n<ul>\n<li>父节点的创建，修改，删除都会触发Watcher事件。</li>\n<li>子节点的创建，删除会触发Watcher事件。</li>\n</ul>\n<p>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0默认持久递归，可以触发多次</p>\n<p>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力</p>\n<p>Watcher机制包括三个角色：客户端线程、客户端的WatchManager以及ZooKeeper服务器</p>\n<ul>\n<li>客户端向ZooKeeper服务器注册一个Watcher监听</li>\n<li>把这个监听信息存储到客户端的WatchManager中</li>\n<li>当ZooKeeper中的节点发生变化时，会通知客户端，客户端会调用相应Watcher对象中的回调方法。watch回调是串行同步的</li>\n</ul>\n<h1 id=\"zk和eureka的区别\"><a href=\"#zk和eureka的区别\" class=\"headerlink\" title=\"zk和eureka的区别\"></a>zk和eureka的区别</h1><p>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。</p>\n<p>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。</p>\n<p>eureka：AP设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。</p>\n<p>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）</p>\n<p>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注册发现来说是非常好的选择。</p>\n","more":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>简述ZAB 协议</p>\n<p>zk的数据模型和节点类型</p>\n<p>简述zk的命名服务、配置管理、集群管理</p>\n<p>Zookeeper watch机制</p>\n<p>zk和eureka的区别<sunfy-line></p>\n<h1 id=\"简述ZAB协议\"><a href=\"#简述ZAB协议\" class=\"headerlink\" title=\"简述ZAB协议\"></a>简述ZAB协议</h1><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性</p>\n<p>所有客户端的请求都是写入到Leader进程中，然后，由Leader同步到其他节点，称为Follower。在集群数据同步的过程中，如果出现Follower节点崩溃或者Leader进程崩溃时，都会通过Zab协议来保证数据一致性</p>\n<p>ZAB协议包括两种基本的模式：<strong>崩溃恢复和消息广播</strong>。</p>\n<h2 id=\"消息广播：\"><a href=\"#消息广播：\" class=\"headerlink\" title=\"消息广播：\"></a>消息广播：</h2><p>集群中所有的事务请求都由Leader节点来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal分发给集群中其他所有的Follower。</p>\n<p>完成广播之后，Leader等待Follwer反馈，当有过半数的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit信息就是确认将之前的Proposal提交。</p>\n<p>Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数&gt;=N/2+1，N是全部的Follower节点数量。</p>\n<h2 id=\"崩溃恢复：\"><a href=\"#崩溃恢复：\" class=\"headerlink\" title=\"崩溃恢复：\"></a>崩溃恢复：</h2><ul>\n<li>初始化集群，刚刚启动的时候</li>\n<li>Leader崩溃，因为故障宕机</li>\n<li>Leader失去了半数的机器支持，与集群中超过一半的节点断连</li>\n</ul>\n<p>此时开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，使数据一致，当与过半的机器同步完成后，就退出恢复模式，然后进入消息广播模式</p>\n<p>整个ZooKeeper集群的一致性保证就是在上面两个状态之前切换，当Leader服务正常时，就是正常的消息广播模式；当Leader不可用时，则进入崩溃恢复模式，崩溃恢复阶段会进行数据同步，完成以后，重新进入消息广播阶段。</p>\n<p>Zxid是Zab协议的一个事务编号，Zxid是一个64位的数字，其中低32位是一个简单的单调递增计数器，针对客户端每一个事务请求，计数器加1；而高32位则代表Leader周期年代的编号。</p>\n<p>Leader周期（epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的Leader选举出现时，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值，然后加1，以此作为新的周期ID。高32位代表了每代Leader的唯一性，低32位则代表了每代Leader中事务的唯一性。</p>\n<h2 id=\"zab节点的三种状态：\"><a href=\"#zab节点的三种状态：\" class=\"headerlink\" title=\"zab节点的三种状态：\"></a>zab节点的三种状态：</h2><ul>\n<li>following：服从leader的命令</li>\n<li>leading：负责协调事务</li>\n<li>election/looking：选举状态</li>\n</ul>\n<h1 id=\"zk的数据模型和节点类型\"><a href=\"#zk的数据模型和节点类型\" class=\"headerlink\" title=\"zk的数据模型和节点类型\"></a>zk的数据模型和节点类型</h1><p>数据模型：树形结构</p>\n<p>zk维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。</p>\n<p>zk在内存中构造了个DataTree的数据结构，维护着path到dataNode的映射以及dataNode间的树状层级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以，zk最适于读多写少且轻量级数据的应用场景。</p>\n<p>数据仅存储在内存是很不安全的，zk采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢失的情况下能快速恢复。</p>\n<p>树中的每个节点被称为—Znode</p>\n<p>Znode兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子Znode。具有增、删、改、查等操作。</p>\n<p>Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作</p>\n<p>Znode存储数据大小有限制。每个Znode的数据大小至多1M，常规使用中应该远小于此值。</p>\n<p>Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”/zookeeper”用以保存管理信息，比如关键配额信息。</p>\n<p>持久节点：一旦创建、该数据节点会一直存储在zk服务器上、即使创建该节点的客户端与服务端的会话关闭了、该节点也不会被删除</p>\n<p>临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在zk上被删除。</p>\n<p>有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性质。</p>\n<h1 id=\"简述zk的命名服务、配置管理、集群管理\"><a href=\"#简述zk的命名服务、配置管理、集群管理\" class=\"headerlink\" title=\"简述zk的命名服务、配置管理、集群管理\"></a>简述zk的命名服务、配置管理、集群管理</h1><h2 id=\"命名服务：\"><a href=\"#命名服务：\" class=\"headerlink\" title=\"命名服务：\"></a>命名服务：</h2><p>通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</p>\n<h2 id=\"配置管理：\"><a href=\"#配置管理：\" class=\"headerlink\" title=\"配置管理：\"></a>配置管理：</h2><p>实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p>\n<h2 id=\"集群管理：\"><a href=\"#集群管理：\" class=\"headerlink\" title=\"集群管理：\"></a>集群管理：</h2><p>集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对应的临时目录节点会被删除，其他所有机器都收到通知。新机器加入也是类似。</p>\n<h1 id=\"Zookeeper-watch机制\"><a href=\"#Zookeeper-watch机制\" class=\"headerlink\" title=\"Zookeeper watch机制\"></a>Zookeeper watch机制</h1><p>客户端，可以通过在znode上设置watch，实现实时监听znode的变化</p>\n<p>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端</p>\n<ul>\n<li>父节点的创建，修改，删除都会触发Watcher事件。</li>\n<li>子节点的创建，删除会触发Watcher事件。</li>\n</ul>\n<p>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0默认持久递归，可以触发多次</p>\n<p>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力</p>\n<p>Watcher机制包括三个角色：客户端线程、客户端的WatchManager以及ZooKeeper服务器</p>\n<ul>\n<li>客户端向ZooKeeper服务器注册一个Watcher监听</li>\n<li>把这个监听信息存储到客户端的WatchManager中</li>\n<li>当ZooKeeper中的节点发生变化时，会通知客户端，客户端会调用相应Watcher对象中的回调方法。watch回调是串行同步的</li>\n</ul>\n<h1 id=\"zk和eureka的区别\"><a href=\"#zk和eureka的区别\" class=\"headerlink\" title=\"zk和eureka的区别\"></a>zk和eureka的区别</h1><p>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。</p>\n<p>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。</p>\n<p>eureka：AP设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。</p>\n<p>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）</p>\n<p>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注册发现来说是非常好的选择。</p>\n","next":{"title":"Redis常见的面试题","path":"api/articles/resource-java-redis-redisInterview.json","image":"/img/header_img/java/redisInterview.png","num_read":539,"num_like":465,"num_collection":258,"num_comments":163},"prev":{"title":"MQ常见的面试题","path":"api/articles/resource-MQ-other-MQKAFKAInterview.json","image":"/img/header_img/MQ/MQKAFKAInterview.png","num_read":496,"num_like":448,"num_collection":343,"num_comments":80},"categories":[{"name":"分布式中间件","path":"api/categories/分布式中间件.json","pathContent":"api/categories/分布式中间件","description":"包含Zookeeper、Redis、等相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}],"tags":[{"name":"Interview","path":"api/tags/Interview.json","pathContent":"api/tags/Interview","description":"面试题相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"},{"name":"Zookeeper","path":"api/tags/Zookeeper.json","pathContent":"api/tags/Zookeeper","description":"一个分布式的，开放源码的分布式应用程序协调服务","cover":"https://sunfy9.gitee.io/img/header_img/java/zookeeper.png"}]}