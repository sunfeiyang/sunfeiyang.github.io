{"title":"Atomic原子操作分析","num_read":1082,"num_like":902,"num_collection":522,"num_comments":30,"slug":"resource-java-concurrent-Atomic","date":"2021-11-07T16:00:00.000Z","img":"/img/header_img/concurrent/atomic.png","_id":"clhrbp2do009xo5lg7efo9vco","project":"concurrent","subtitle":"操作简单， 性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。","site":{"data":{}},"updated":"2022-09-19T14:51:18.426Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-Atomic.json","webPath":"2021/11/08/resource-java-concurrent-Atomic/","permalink":"https://sunfy9.gitee.io/2021/11/08/resource-java-concurrent-Atomic/","excerpt":null,"covers":["../../../../img/Atomic/image-20211108171153907.png","../../../../img/Atomic/image-20211108220955472.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"Atomic\"><a href=\"#Atomic\" class=\"headerlink\" title=\"Atomic\"></a>Atomic</h1><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过 Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在<code>JUC</code>下的atomic包提供了一系列的操作简单， 性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都采用的是乐观锁策略去原子更新数据，在java中则是使用<code>CAS</code>操作具体实现。 </p>\n<p>在<code>java.util.concurrent.atomic</code>包里提供了一组原子操作类： </p>\n<p><img src=\"../../../../img/Atomic/image-20211108171153907.png\" alt=\"image-20211108171153907\"></p>\n<ul>\n<li>基本类型：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>； </li>\n<li>引用类型：<code>AtomicReference</code>、<code>AtomicStampedRerence</code>、<code>AtomicMarkableReference</code>；</li>\n<li>数组类型：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code> </li>\n<li>对象属性原子修改器：<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code> </li>\n<li>原子类型累加器（<code>jdk1.8</code>增加的类）：<code>DoubleAccumulator</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code>、<code>LongAdder</code>、<code>Striped64</code></li>\n</ul>\n<h1 id=\"原子更新基本类型\"><a href=\"#原子更新基本类型\" class=\"headerlink\" title=\"原子更新基本类型\"></a>原子更新基本类型<sunfy-line></h1><p><img src=\"../../../../img/Atomic/image-20211108220955472.png\" alt=\"image-20211108220955472\"></p>\n<ul>\n<li><p>以原子方式将实例原值加1，返回自增前的原值</p>\n<blockquote>\n<p>getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</p>\n</blockquote>\n</li>\n<li><p>将实例中的值更新为新值，并返回旧值</p>\n<blockquote>\n<p>getAndSet(int newValue)</p>\n</blockquote>\n</li>\n<li><p>以原子的方式将实例中的原值进行加1操作，并返回相加后的结果</p>\n<blockquote>\n<p>incrementAndGet()</p>\n</blockquote>\n</li>\n<li><p>以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果</p>\n<blockquote>\n<p>addAndGet(int delta)</p>\n</blockquote>\n</li>\n</ul>\n<p>总结，可以看到方法的命名规则还是比较容易理解的，根据方法中先获取还是先累加，先获取就获取的是原值，后获取返回的则是操作后的值。</p>\n<h1 id=\"原子更新数组类型\"><a href=\"#原子更新数组类型\" class=\"headerlink\" title=\"原子更新数组类型\"></a>原子更新数组类型</h1><ul>\n<li><p>以原子更新的方式将数组中索引为i的元素与输入值相加</p>\n<blockquote>\n<p>addAndGet(int i, int delta)</p>\n</blockquote>\n</li>\n<li><p>以原子更新的方式将数组中索引为i的元素自增加1</p>\n<blockquote>\n<p>getAndIncrement(int i)</p>\n</blockquote>\n</li>\n<li><p>将数组中索引为i的位置的元素进行更新</p>\n<blockquote>\n<p>compareAndSet(int i, int expect, int update)</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"原子更新引用类型\"><a href=\"#原子更新引用类型\" class=\"headerlink\" title=\"原子更新引用类型\"></a>原子更新引用类型</h1><p><code>AtomicReference</code>作用是对普通对象的封装，它可以保证你在修改对象引用时的线程安全性。</p>\n<h1 id=\"对象属性原子修改器\"><a href=\"#对象属性原子修改器\" class=\"headerlink\" title=\"对象属性原子修改器\"></a>对象属性原子修改器</h1><p><code>AtomicIntegerFieldUpdater</code>可以线程安全地更新对象中的整型变量。</p>\n<p>对于<code>AtomicIntegerFieldUpdater</code> 的使用稍微有一些限制和约束，约束如下： </p>\n<ul>\n<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见.<code>eg:volatile int value = 3</code> </li>\n<li>字段的描述类型（修饰符public/protected/default/private）与调用者与操作对象字段的 关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父 类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。 </li>\n<li>只能是实例变量，不能是类变量，也就是说不能加static关键字。</li>\n<li>只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和 volatile是有冲突的，这两个关键字不能同时存在。</li>\n<li>对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改int/long类型的字 段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 <code>AtomicReferenceFieldUpdater</code>。</li>\n</ul>\n","more":"<h1 id=\"Atomic\"><a href=\"#Atomic\" class=\"headerlink\" title=\"Atomic\"></a>Atomic</h1><p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过 Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在<code>JUC</code>下的atomic包提供了一系列的操作简单， 性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都采用的是乐观锁策略去原子更新数据，在java中则是使用<code>CAS</code>操作具体实现。 </p>\n<p>在<code>java.util.concurrent.atomic</code>包里提供了一组原子操作类： </p>\n<p><img src=\"../../../../img/Atomic/image-20211108171153907.png\" alt=\"image-20211108171153907\"></p>\n<ul>\n<li>基本类型：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>； </li>\n<li>引用类型：<code>AtomicReference</code>、<code>AtomicStampedRerence</code>、<code>AtomicMarkableReference</code>；</li>\n<li>数组类型：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code> </li>\n<li>对象属性原子修改器：<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code> </li>\n<li>原子类型累加器（<code>jdk1.8</code>增加的类）：<code>DoubleAccumulator</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code>、<code>LongAdder</code>、<code>Striped64</code></li>\n</ul>\n<h1 id=\"原子更新基本类型\"><a href=\"#原子更新基本类型\" class=\"headerlink\" title=\"原子更新基本类型\"></a>原子更新基本类型<sunfy-line></h1><p><img src=\"../../../../img/Atomic/image-20211108220955472.png\" alt=\"image-20211108220955472\"></p>\n<ul>\n<li><p>以原子方式将实例原值加1，返回自增前的原值</p>\n<blockquote>\n<p>getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)</p>\n</blockquote>\n</li>\n<li><p>将实例中的值更新为新值，并返回旧值</p>\n<blockquote>\n<p>getAndSet(int newValue)</p>\n</blockquote>\n</li>\n<li><p>以原子的方式将实例中的原值进行加1操作，并返回相加后的结果</p>\n<blockquote>\n<p>incrementAndGet()</p>\n</blockquote>\n</li>\n<li><p>以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果</p>\n<blockquote>\n<p>addAndGet(int delta)</p>\n</blockquote>\n</li>\n</ul>\n<p>总结，可以看到方法的命名规则还是比较容易理解的，根据方法中先获取还是先累加，先获取就获取的是原值，后获取返回的则是操作后的值。</p>\n<h1 id=\"原子更新数组类型\"><a href=\"#原子更新数组类型\" class=\"headerlink\" title=\"原子更新数组类型\"></a>原子更新数组类型</h1><ul>\n<li><p>以原子更新的方式将数组中索引为i的元素与输入值相加</p>\n<blockquote>\n<p>addAndGet(int i, int delta)</p>\n</blockquote>\n</li>\n<li><p>以原子更新的方式将数组中索引为i的元素自增加1</p>\n<blockquote>\n<p>getAndIncrement(int i)</p>\n</blockquote>\n</li>\n<li><p>将数组中索引为i的位置的元素进行更新</p>\n<blockquote>\n<p>compareAndSet(int i, int expect, int update)</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"原子更新引用类型\"><a href=\"#原子更新引用类型\" class=\"headerlink\" title=\"原子更新引用类型\"></a>原子更新引用类型</h1><p><code>AtomicReference</code>作用是对普通对象的封装，它可以保证你在修改对象引用时的线程安全性。</p>\n<h1 id=\"对象属性原子修改器\"><a href=\"#对象属性原子修改器\" class=\"headerlink\" title=\"对象属性原子修改器\"></a>对象属性原子修改器</h1><p><code>AtomicIntegerFieldUpdater</code>可以线程安全地更新对象中的整型变量。</p>\n<p>对于<code>AtomicIntegerFieldUpdater</code> 的使用稍微有一些限制和约束，约束如下： </p>\n<ul>\n<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见.<code>eg:volatile int value = 3</code> </li>\n<li>字段的描述类型（修饰符public/protected/default/private）与调用者与操作对象字段的 关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父 类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。 </li>\n<li>只能是实例变量，不能是类变量，也就是说不能加static关键字。</li>\n<li>只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和 volatile是有冲突的，这两个关键字不能同时存在。</li>\n<li>对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改int/long类型的字 段，不能修改其包装类型（Integer/Long）。如果要修改包装类型就需要使用 <code>AtomicReferenceFieldUpdater</code>。</li>\n</ul>\n","next":{"title":"CAS操作分析","path":"api/articles/resource-java-concurrent-CAS.json","image":"/img/header_img/concurrent/cas.png","num_read":1169,"num_like":464,"num_collection":491,"num_comments":94},"prev":{"title":"关于分布式唯一ID的思考","path":"api/articles/resource-MicroService-other-分布式唯一ID.json","image":"/img/header_img/MicroService/snowflake.png","num_read":168,"num_like":304,"num_collection":361,"num_comments":25},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}