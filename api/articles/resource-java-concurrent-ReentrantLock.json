{"title":"AQS之独占锁ReentrantLock","num_read":1727,"num_like":898,"num_collection":340,"num_comments":255,"slug":"resource-java-concurrent-ReentrantLock","date":"2021-11-15T16:00:00.000Z","img":"/img/header_img/concurrent/ReentrantLock.png","minNumber":500,"format":"max","_id":"clhrbp2dn009no5lge529f2p1","project":"concurrent","subtitle":"是一种基于AQS框架的应用实现，是一种互斥锁，可以保证线程安全。","site":{"data":{}},"updated":"2022-09-19T14:46:06.293Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-ReentrantLock.json","webPath":"2021/11/16/resource-java-concurrent-ReentrantLock/","permalink":"https://sunfy9.gitee.io/2021/11/16/resource-java-concurrent-ReentrantLock/","excerpt":null,"covers":["../../../../img/ReentrantLock/image-20211116222602021.png","../../../../img/ReentrantLock/image-20211116224412185.png","../../../../img/ReentrantLock/image-20211116230146439.png","../../../../img/ReentrantLock/image-20211116224648154.png","../../../../img/ReentrantLock/image-20211117100515974.png","../../../../img/ReentrantLock/image-20211117100926315.png","../../../../img/ReentrantLock/image-20211116224734790.png","../../../../img/ReentrantLock/image-20211116225053821.png","../../../../img/ReentrantLock/image-20211116225235439.png","../../../../img/ReentrantLock/image-20211116230245671.png","../../../../img/ReentrantLock/image-20211116230919961.png","../../../../img/ReentrantLock/image-20211116231028070.png","../../../../img/ReentrantLock/image-20211116231209250.png","../../../../img/ReentrantLock/image-20211117103436500.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"什么是ReentrantLock\"><a href=\"#什么是ReentrantLock\" class=\"headerlink\" title=\"什么是ReentrantLock\"></a>什么是<code>ReentrantLock</code></h1><p><code>ReentrantLock</code>是一种基于<code>AQS</code>框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于<code>synchronized</code>是一种互斥锁，可以保证线程安全。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>可中断</li>\n<li>可以设置超时时间</li>\n<li>可以设置为公平锁</li>\n<li>支持多个条件变量</li>\n<li>同<code>synchronized</code>一样，支持可重入</li>\n</ul>\n<h2 id=\"synchronized与ReentrantLock区别\"><a href=\"#synchronized与ReentrantLock区别\" class=\"headerlink\" title=\"synchronized与ReentrantLock区别\"></a><code>synchronized</code>与<code>ReentrantLock</code>区别</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>sYNCHRONIZED</th>\n<th>rEENTRANTLOCK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>层级</td>\n<td>JVM层级</td>\n<td>JDK层级</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法在代码中直接判断</td>\n<td>可以通过<code>isLocked</code>判断</td>\n</tr>\n<tr>\n<td>公平</td>\n<td>非公平锁</td>\n<td>可以是公平也可以非公平</td>\n</tr>\n<tr>\n<td>中断</td>\n<td>不可被中断</td>\n<td><code>lockinterruptibly</code>可以中断</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>发生异常会自动释放锁</td>\n<td>在finally块中显示释放锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>立即返回是否成功的<code>tryLock()</code>，等待指定时长的获取</td>\n<td>已经在等待的线程是后来的线程先获得锁</td>\n</tr>\n<tr>\n<td></td>\n<td>队列，先进先出，先来的线程先获得锁</td>\n<td>栈，先进后出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"ReentrantLock用法\"><a href=\"#ReentrantLock用法\" class=\"headerlink\" title=\"ReentrantLock用法\"></a><code>ReentrantLock</code>用法<sunfy-line></h1><ul>\n<li><p>创建锁</p>\n<p>公平锁</p>\n<blockquote>\n<p>ReentrantLock lock = new ReentrantLock(true);</p>\n</blockquote>\n<p>非公平锁</p>\n<blockquote>\n<p>ReentrantLock lock = new ReentrantLock();</p>\n<p>参数默认为false，所以传入false或者不传参数都是非公平锁</p>\n</blockquote>\n</li>\n<li><p>对临界区加锁</p>\n<blockquote>\n<p>lock.lock();</p>\n<p>加锁完成后，要将临界区代码使用try进行异常处理</p>\n</blockquote>\n</li>\n<li><p>必须显示解锁</p>\n<blockquote>\n<p>在finally中显示的解锁</p>\n<p>lock.unlock();</p>\n</blockquote>\n</li>\n</ul>\n<p>下面看几个例子，从锁的五个特性入手，进行针对性的理解</p>\n<h2 id=\"重入\"><a href=\"#重入\" class=\"headerlink\" title=\"重入\"></a>重入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同一个锁，在线程1中加锁一次，并在线程1中调用线程2，输出结果正常</span></span><br><span class=\"line\"><span class=\"comment\">// 不过注意我们需要对两次加锁分别进行解锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    method1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"execute method1\"</span>);</span><br><span class=\"line\">        method2();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"execute method2\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\">execute method1</span><br><span class=\"line\">execute method2</span><br></pre></td></tr></table></figure>\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p>需要在线程中手动设置为可中断，<code>lock.lockInterruptibly();</code></p>\n<p>显示调用中断锁：<code>t1.interrupt();</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"t1启动...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置可中断</span></span><br><span class=\"line\">            lock.lockInterruptibly();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"t1获得了锁\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"t1等锁的过程中被中断\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"main线程获得了锁\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        <span class=\"comment\">//先让线程t1执行</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 手动中断锁</span></span><br><span class=\"line\">        t1.interrupt();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"线程t1执行中断\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h2><p>通过<code>lock.tryLock()</code>尝试获取锁，如果未获取到，直接返回失败</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!lock.tryLock()) &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">\"获取锁失败，立即返回false\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>lock.tryLock(3, TimeUnit.SECONDS)</code>尝试在指定时间内获取锁，如果在设定时间内获取到则放回true，否则返回false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lock.tryLock(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"等待 3s 后获取锁失败，直接返回\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公平\"><a href=\"#公平\" class=\"headerlink\" title=\"公平\"></a>公平</h2><p>先创建500个线程并启动线程，等所有线程创建好之后，然后去竞争锁，如果设置的为公平锁，那必然符合队列的先进先出原则（FIFO），若设置为非公平锁，那就可能出现后创建的线程在之前先执行。因为非公平锁在创建后会先尝试去获取一下锁，如果获取到则直接执行，如果获取不到才会放入等待队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ReentrantLock lock = new ReentrantLock(true); //公平锁</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(); <span class=\"comment\">//非公平锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.debug(Thread.currentThread().getName() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"t\"</span> + i).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1s 之后去争抢锁</span></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(Thread.currentThread().getName() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"强行插入\"</span> + i).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><p>定义信号量为变量1，变量2</p>\n<p>在主线程中，分别修改变量1和变量2的值，并分别调用相应条件的<code>signal1.signal();</code>，激活线程继续执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//变量1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!has1)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"未获取到变量1，等待中...\"</span>);</span><br><span class=\"line\">                signal1.await();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"获取到变量1\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//变量2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!has2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"未获取到变量2，等待中...\"</span>);</span><br><span class=\"line\">                signal2.await();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"获取到变量2\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Condition signal1 = lock.newCondition();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Condition signal2 = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> has1 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> has2 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ReentrantLockDemo6 test = <span class=\"keyword\">new</span> ReentrantLockDemo6();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        test.signal1();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        test.signal2();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            has1 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"唤醒变量1等待线程\"</span>);</span><br><span class=\"line\">            signal1.signal();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"t1\"</span>).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            has2 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"唤醒变量2等待线程\"</span>);</span><br><span class=\"line\">            signal2.signal();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"t2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果</p>\n<p>未获取到变量1，等待中…<br>未获取到变量2，等待中…<br>唤醒变量1等待线程<br>唤醒变量2等待线程<br>获取到变量1<br>获取到变量2</p>\n</blockquote>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><p>带着问题看源码：</p>\n<ul>\n<li><code>ReentrantLock</code>加锁解锁逻辑</li>\n<li>如何实现公平与非公平</li>\n<li>如何实现可重入锁机制</li>\n<li>线程竞争锁失败的入队阻塞逻辑</li>\n<li>获取锁的线程释放锁唤醒阻塞线程</li>\n<li>竞争锁的逻辑如何实现</li>\n</ul>\n<p>首先我们先看下<code>ReentrantLock</code>所有的方法，从方法的名称中我们也大概能判断相应的方法的功能。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116222602021.png\" alt=\"image-20211116222602021\"></p>\n<h2 id=\"Node说明\"><a href=\"#Node说明\" class=\"headerlink\" title=\"Node说明\"></a>Node说明</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示节点在共享模式下等待的标记 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"comment\">/** 指示节点正在以独占模式等待的标记 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示线程已取消的 waitStatus 值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示后继线程需要解停的waitStatus 值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** waitStatus 值指示线程正在等待条件 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示下一个acquireShared 应无条件传播的waitStatus值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReentrantLock</code>在进行线程判断的时候重点会使用到上面的几个参数进行判断。</p>\n<h2 id=\"加锁逻辑\"><a href=\"#加锁逻辑\" class=\"headerlink\" title=\"加锁逻辑\"></a>加锁逻辑</h2><p><img src=\"../../../../img/ReentrantLock/image-20211116224412185.png\" alt=\"image-20211116224412185\"></p>\n<p>先来看下公平锁：</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230146439.png\" alt=\"image-20211116230146439\"></p>\n<p><code>acquire</code>:以独占模式获取，忽略中断。 通过至少调用一次tryAcquire ，成功返回。 否则线程会排队，可能会反复阻塞和解除阻塞，调用tryAcquire直到成功。 此方法可用于实现方法Lock.lock 。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116224648154.png\" alt=\"image-20211116224648154\"></p>\n<p><code>tryAcquire</code>:tryAcquire 的公平版本。 除非递归调用或没有服务员或是第一个，否则不要授予访问权限。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117100515974.png\" alt=\"image-20211117100515974\"></p>\n<p>非公平版本:执行不公平的 tryLock。 tryAcquire 在子类中实现，但两者都需要对 trylock 方法进行非公平尝试</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117100926315.png\" alt=\"image-20211117100926315\"></p>\n<p><code>addWaiter</code>:为当前线程和给定模式创建和排队节点。参数：模式 – Node.EXCLUSIVE 为独占，Node.SHARED 为共享返回：新节点</p>\n<p>此处因为初始化<code>pred==null</code>会先调用<code>enq(node)</code>进行等待队列的初始化，第二个线程再次调用到此方法时，pred不为null，则会进行入队操作</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116224734790.png\" alt=\"image-20211116224734790\"></p>\n<p><code>acquireQueued</code>:以独占不间断模式获取已在队列中的线程。 由条件等待方法以及获取使用。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116225053821.png\" alt=\"image-20211116225053821\"></p>\n<p><code>enq</code>:将节点插入队列，必要时进行初始化。<strong>此处才对等待队列进行了初始化，此处非常值得学习，体会如何初始化一个队列</strong></p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116225235439.png\" alt=\"image-20211116225235439\"></p>\n<p>接下来我们再对比看下非公平锁：</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230245671.png\" alt=\"image-20211116230245671\"></p>\n<p>对比可以看到，非公平锁比公平锁就多了一层判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    setExclusiveOwnerThread(Thread.currentThread());</span><br></pre></td></tr></table></figure>\n<p>方法中直接去尝试获取锁，如果锁获取成功，则直接设置独占所有者线程。这我们就能明白<code>ReentrantLock</code>就是通过这个判断来实现了公平锁和非公平锁。</p>\n<h2 id=\"解锁逻辑\"><a href=\"#解锁逻辑\" class=\"headerlink\" title=\"解锁逻辑\"></a>解锁逻辑</h2><p><code>unlock</code>:尝试释放此锁。<br>如果当前线程是此锁的持有者，则持有计数递减。 如果保持计数现在为零，则释放锁。 如果当前线程不是此锁的持有者，则抛出<code>IllegalMonitorStateException</code> </p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230919961.png\" alt=\"image-20211116230919961\"></p>\n<p><code>release</code>:以独占模式发布。 如果tryRelease返回 true，则通过解除阻塞一个或多个线程tryRelease实现。 此方法可用于实现方法Lock.unlock 。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116231028070.png\" alt=\"image-20211116231028070\"></p>\n<p><code>unparkSuccessor</code>:唤醒节点的后继节点（如果存在）。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116231209250.png\" alt=\"image-20211116231209250\"></p>\n<p>解锁后去唤醒等待队列中的后继节点。</p>\n<h2 id=\"重入锁机制\"><a href=\"#重入锁机制\" class=\"headerlink\" title=\"重入锁机制\"></a>重入锁机制</h2><p>在<code>ReentrantLock</code>中定义，在尝试获取锁时会进行判断定义的<code>state</code>的数值，如果获取到state是0，则说明是首次获取锁，加锁成功并设置当前拥有独占访问权限的线程。否则会判断当前线程尝试加锁线程是否为当前锁的线程，如果是同一个线程，那么会累加<code>state</code>值，从而支持可重入。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117103436500.png\" alt=\"image-20211117103436500\"></p>\n","more":"<h1 id=\"什么是ReentrantLock\"><a href=\"#什么是ReentrantLock\" class=\"headerlink\" title=\"什么是ReentrantLock\"></a>什么是<code>ReentrantLock</code></h1><p><code>ReentrantLock</code>是一种基于<code>AQS</code>框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于<code>synchronized</code>是一种互斥锁，可以保证线程安全。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>可中断</li>\n<li>可以设置超时时间</li>\n<li>可以设置为公平锁</li>\n<li>支持多个条件变量</li>\n<li>同<code>synchronized</code>一样，支持可重入</li>\n</ul>\n<h2 id=\"synchronized与ReentrantLock区别\"><a href=\"#synchronized与ReentrantLock区别\" class=\"headerlink\" title=\"synchronized与ReentrantLock区别\"></a><code>synchronized</code>与<code>ReentrantLock</code>区别</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>sYNCHRONIZED</th>\n<th>rEENTRANTLOCK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>层级</td>\n<td>JVM层级</td>\n<td>JDK层级</td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td>无法在代码中直接判断</td>\n<td>可以通过<code>isLocked</code>判断</td>\n</tr>\n<tr>\n<td>公平</td>\n<td>非公平锁</td>\n<td>可以是公平也可以非公平</td>\n</tr>\n<tr>\n<td>中断</td>\n<td>不可被中断</td>\n<td><code>lockinterruptibly</code>可以中断</td>\n</tr>\n<tr>\n<td>释放锁</td>\n<td>发生异常会自动释放锁</td>\n<td>在finally块中显示释放锁</td>\n</tr>\n<tr>\n<td>获取锁</td>\n<td>立即返回是否成功的<code>tryLock()</code>，等待指定时长的获取</td>\n<td>已经在等待的线程是后来的线程先获得锁</td>\n</tr>\n<tr>\n<td></td>\n<td>队列，先进先出，先来的线程先获得锁</td>\n<td>栈，先进后出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"ReentrantLock用法\"><a href=\"#ReentrantLock用法\" class=\"headerlink\" title=\"ReentrantLock用法\"></a><code>ReentrantLock</code>用法<sunfy-line></h1><ul>\n<li><p>创建锁</p>\n<p>公平锁</p>\n<blockquote>\n<p>ReentrantLock lock = new ReentrantLock(true);</p>\n</blockquote>\n<p>非公平锁</p>\n<blockquote>\n<p>ReentrantLock lock = new ReentrantLock();</p>\n<p>参数默认为false，所以传入false或者不传参数都是非公平锁</p>\n</blockquote>\n</li>\n<li><p>对临界区加锁</p>\n<blockquote>\n<p>lock.lock();</p>\n<p>加锁完成后，要将临界区代码使用try进行异常处理</p>\n</blockquote>\n</li>\n<li><p>必须显示解锁</p>\n<blockquote>\n<p>在finally中显示的解锁</p>\n<p>lock.unlock();</p>\n</blockquote>\n</li>\n</ul>\n<p>下面看几个例子，从锁的五个特性入手，进行针对性的理解</p>\n<h2 id=\"重入\"><a href=\"#重入\" class=\"headerlink\" title=\"重入\"></a>重入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同一个锁，在线程1中加锁一次，并在线程1中调用线程2，输出结果正常</span></span><br><span class=\"line\"><span class=\"comment\">// 不过注意我们需要对两次加锁分别进行解锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    method1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"execute method1\"</span>);</span><br><span class=\"line\">        method2();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"execute method2\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\">execute method1</span><br><span class=\"line\">execute method2</span><br></pre></td></tr></table></figure>\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p>需要在线程中手动设置为可中断，<code>lock.lockInterruptibly();</code></p>\n<p>显示调用中断锁：<code>t1.interrupt();</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"t1启动...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置可中断</span></span><br><span class=\"line\">            lock.lockInterruptibly();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"t1获得了锁\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"t1等锁的过程中被中断\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"main线程获得了锁\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        <span class=\"comment\">//先让线程t1执行</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 手动中断锁</span></span><br><span class=\"line\">        t1.interrupt();</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"线程t1执行中断\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h2><p>通过<code>lock.tryLock()</code>尝试获取锁，如果未获取到，直接返回失败</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!lock.tryLock()) &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">\"获取锁失败，立即返回false\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>lock.tryLock(3, TimeUnit.SECONDS)</code>尝试在指定时间内获取锁，如果在设定时间内获取到则放回true，否则返回false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lock.tryLock(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"等待 3s 后获取锁失败，直接返回\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"公平\"><a href=\"#公平\" class=\"headerlink\" title=\"公平\"></a>公平</h2><p>先创建500个线程并启动线程，等所有线程创建好之后，然后去竞争锁，如果设置的为公平锁，那必然符合队列的先进先出原则（FIFO），若设置为非公平锁，那就可能出现后创建的线程在之前先执行。因为非公平锁在创建后会先尝试去获取一下锁，如果获取到则直接执行，如果获取不到才会放入等待队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ReentrantLock lock = new ReentrantLock(true); //公平锁</span></span><br><span class=\"line\">ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock(); <span class=\"comment\">//非公平锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.debug(Thread.currentThread().getName() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"t\"</span> + i).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1s 之后去争抢锁</span></span><br><span class=\"line\">Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(Thread.currentThread().getName() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">\"强行插入\"</span> + i).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><p>定义信号量为变量1，变量2</p>\n<p>在主线程中，分别修改变量1和变量2的值，并分别调用相应条件的<code>signal1.signal();</code>，激活线程继续执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//变量1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!has1)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"未获取到变量1，等待中...\"</span>);</span><br><span class=\"line\">                signal1.await();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"获取到变量1\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//变量2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!has2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">\"未获取到变量2，等待中...\"</span>);</span><br><span class=\"line\">                signal2.await();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">\"获取到变量2\"</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Condition signal1 = lock.newCondition();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Condition signal2 = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> has1 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> has2 = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ReentrantLockDemo6 test = <span class=\"keyword\">new</span> ReentrantLockDemo6();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        test.signal1();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        test.signal2();</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            has1 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"唤醒变量1等待线程\"</span>);</span><br><span class=\"line\">            signal1.signal();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"t1\"</span>).start();</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt;&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            has2 = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            log.debug(<span class=\"string\">\"唤醒变量2等待线程\"</span>);</span><br><span class=\"line\">            signal2.signal();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"string\">\"t2\"</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出结果</p>\n<p>未获取到变量1，等待中…<br>未获取到变量2，等待中…<br>唤醒变量1等待线程<br>唤醒变量2等待线程<br>获取到变量1<br>获取到变量2</p>\n</blockquote>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><p>带着问题看源码：</p>\n<ul>\n<li><code>ReentrantLock</code>加锁解锁逻辑</li>\n<li>如何实现公平与非公平</li>\n<li>如何实现可重入锁机制</li>\n<li>线程竞争锁失败的入队阻塞逻辑</li>\n<li>获取锁的线程释放锁唤醒阻塞线程</li>\n<li>竞争锁的逻辑如何实现</li>\n</ul>\n<p>首先我们先看下<code>ReentrantLock</code>所有的方法，从方法的名称中我们也大概能判断相应的方法的功能。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116222602021.png\" alt=\"image-20211116222602021\"></p>\n<h2 id=\"Node说明\"><a href=\"#Node说明\" class=\"headerlink\" title=\"Node说明\"></a>Node说明</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示节点在共享模式下等待的标记 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"comment\">/** 指示节点正在以独占模式等待的标记 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示线程已取消的 waitStatus 值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示后继线程需要解停的waitStatus 值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** waitStatus 值指示线程正在等待条件 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** 指示下一个acquireShared 应无条件传播的waitStatus值 */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReentrantLock</code>在进行线程判断的时候重点会使用到上面的几个参数进行判断。</p>\n<h2 id=\"加锁逻辑\"><a href=\"#加锁逻辑\" class=\"headerlink\" title=\"加锁逻辑\"></a>加锁逻辑</h2><p><img src=\"../../../../img/ReentrantLock/image-20211116224412185.png\" alt=\"image-20211116224412185\"></p>\n<p>先来看下公平锁：</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230146439.png\" alt=\"image-20211116230146439\"></p>\n<p><code>acquire</code>:以独占模式获取，忽略中断。 通过至少调用一次tryAcquire ，成功返回。 否则线程会排队，可能会反复阻塞和解除阻塞，调用tryAcquire直到成功。 此方法可用于实现方法Lock.lock 。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116224648154.png\" alt=\"image-20211116224648154\"></p>\n<p><code>tryAcquire</code>:tryAcquire 的公平版本。 除非递归调用或没有服务员或是第一个，否则不要授予访问权限。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117100515974.png\" alt=\"image-20211117100515974\"></p>\n<p>非公平版本:执行不公平的 tryLock。 tryAcquire 在子类中实现，但两者都需要对 trylock 方法进行非公平尝试</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117100926315.png\" alt=\"image-20211117100926315\"></p>\n<p><code>addWaiter</code>:为当前线程和给定模式创建和排队节点。参数：模式 – Node.EXCLUSIVE 为独占，Node.SHARED 为共享返回：新节点</p>\n<p>此处因为初始化<code>pred==null</code>会先调用<code>enq(node)</code>进行等待队列的初始化，第二个线程再次调用到此方法时，pred不为null，则会进行入队操作</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116224734790.png\" alt=\"image-20211116224734790\"></p>\n<p><code>acquireQueued</code>:以独占不间断模式获取已在队列中的线程。 由条件等待方法以及获取使用。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116225053821.png\" alt=\"image-20211116225053821\"></p>\n<p><code>enq</code>:将节点插入队列，必要时进行初始化。<strong>此处才对等待队列进行了初始化，此处非常值得学习，体会如何初始化一个队列</strong></p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116225235439.png\" alt=\"image-20211116225235439\"></p>\n<p>接下来我们再对比看下非公平锁：</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230245671.png\" alt=\"image-20211116230245671\"></p>\n<p>对比可以看到，非公平锁比公平锁就多了一层判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">    setExclusiveOwnerThread(Thread.currentThread());</span><br></pre></td></tr></table></figure>\n<p>方法中直接去尝试获取锁，如果锁获取成功，则直接设置独占所有者线程。这我们就能明白<code>ReentrantLock</code>就是通过这个判断来实现了公平锁和非公平锁。</p>\n<h2 id=\"解锁逻辑\"><a href=\"#解锁逻辑\" class=\"headerlink\" title=\"解锁逻辑\"></a>解锁逻辑</h2><p><code>unlock</code>:尝试释放此锁。<br>如果当前线程是此锁的持有者，则持有计数递减。 如果保持计数现在为零，则释放锁。 如果当前线程不是此锁的持有者，则抛出<code>IllegalMonitorStateException</code> </p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116230919961.png\" alt=\"image-20211116230919961\"></p>\n<p><code>release</code>:以独占模式发布。 如果tryRelease返回 true，则通过解除阻塞一个或多个线程tryRelease实现。 此方法可用于实现方法Lock.unlock 。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116231028070.png\" alt=\"image-20211116231028070\"></p>\n<p><code>unparkSuccessor</code>:唤醒节点的后继节点（如果存在）。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211116231209250.png\" alt=\"image-20211116231209250\"></p>\n<p>解锁后去唤醒等待队列中的后继节点。</p>\n<h2 id=\"重入锁机制\"><a href=\"#重入锁机制\" class=\"headerlink\" title=\"重入锁机制\"></a>重入锁机制</h2><p>在<code>ReentrantLock</code>中定义，在尝试获取锁时会进行判断定义的<code>state</code>的数值，如果获取到state是0，则说明是首次获取锁，加锁成功并设置当前拥有独占访问权限的线程。否则会判断当前线程尝试加锁线程是否为当前锁的线程，如果是同一个线程，那么会累加<code>state</code>值，从而支持可重入。</p>\n<p><img src=\"../../../../img/ReentrantLock/image-20211117103436500.png\" alt=\"image-20211117103436500\"></p>\n","next":{"title":"对AQS的理解","path":"api/articles/resource-java-concurrent-AQS.json","image":"/img/header_img/concurrent/aqs.png","num_read":786,"num_like":933,"num_collection":173,"num_comments":61},"prev":{"title":"synchronized基本使用","path":"api/articles/resource-java-concurrent-synchronizedBase.json","image":"/img/header_img/concurrent/synchronizedBase.png","num_read":596,"num_like":836,"num_collection":94,"num_comments":129},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}