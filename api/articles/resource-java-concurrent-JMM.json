{"title":"java内存模型（JMM）","num_read":660,"num_like":153,"num_collection":572,"num_comments":221,"slug":"resource-java-concurrent-JMM","date":"2021-10-24T16:00:00.000Z","img":"/img/header_img/concurrent/jmm.png","format":"gallery","_id":"clhrbp2do009zo5lggap56zqw","project":"concurrent","subtitle":"用于屏蔽掉各种硬件和操作系统的内存访问差异","site":{"data":{}},"updated":"2022-09-19T14:47:15.036Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-JMM.json","webPath":"2021/10/25/resource-java-concurrent-JMM/","permalink":"https://sunfy9.gitee.io/2021/10/25/resource-java-concurrent-JMM/","excerpt":null,"covers":["../../../../img/JMM/image-20211028165151065.png","../../../../img/JMM/27711.png","../../../../img/JMM/28089.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>java虚拟机规范中定义了java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。</p>\n<p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：<strong>规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</strong>。</p>\n<p>JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<strong>JMM是围绕原子性、有序性、可见性展开的</strong>。</p>\n<p><img src=\"../../../../img/JMM/image-20211028165151065.png\" alt=\"image-20211028165151065\"></p>\n<h1 id=\"内存交互操作\"><a href=\"#内存交互操作\" class=\"headerlink\" title=\"内存交互操作\"></a>内存交互操作<sunfy-line></h1><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>\n<ul>\n<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>\n<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>\n<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>\n<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>\n<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>\n<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>\n<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>\n</ul>\n<p><img src=\"../../../../img/JMM/27711.png\" alt=\"img\"></p>\n<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>\n<ul>\n<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>\n<li>不允许read和load、store和write操作之一单独出现</li>\n<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>\n<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>\n<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>\n<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>\n<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>\n<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>\n</ul>\n<h1 id=\"JMM与硬件内存架构的关系\"><a href=\"#JMM与硬件内存架构的关系\" class=\"headerlink\" title=\"JMM与硬件内存架构的关系\"></a>JMM与硬件内存架构的关系</h1><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：</p>\n<p><img src=\"../../../../img/JMM/28089.png\" alt=\"img\"></p>\n<h1 id=\"JMM的内存可见性保证\"><a href=\"#JMM的内存可见性保证\" class=\"headerlink\" title=\"JMM的内存可见性保证\"></a>JMM的内存可见性保证</h1><p>按程序类型，Java程序的内存可见性保证可以分为下列3类：</p>\n<ul>\n<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>\n<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>\n<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。 JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。</li>\n</ul>\n<p>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。</p>\n<p>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。</p>\n<p>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</p>\n<p>3）顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（32位处理器）。</p>\n<blockquote>\n<p>JVM在32位处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性</p>\n</blockquote>\n","more":"<h1 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h1><p>java虚拟机规范中定义了java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。</p>\n<p>JMM规范了Java虚拟机与计算机内存是如何协同工作的：<strong>规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</strong>。</p>\n<p>JMM描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<strong>JMM是围绕原子性、有序性、可见性展开的</strong>。</p>\n<p><img src=\"../../../../img/JMM/image-20211028165151065.png\" alt=\"image-20211028165151065\"></p>\n<h1 id=\"内存交互操作\"><a href=\"#内存交互操作\" class=\"headerlink\" title=\"内存交互操作\"></a>内存交互操作<sunfy-line></h1><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>\n<ul>\n<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>\n<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>\n<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>\n<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>\n<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>\n<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>\n<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>\n</ul>\n<p><img src=\"../../../../img/JMM/27711.png\" alt=\"img\"></p>\n<p>Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>\n<ul>\n<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>\n<li>不允许read和load、store和write操作之一单独出现</li>\n<li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>\n<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>\n<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>\n<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li>\n<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>\n<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>\n<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>\n</ul>\n<h1 id=\"JMM与硬件内存架构的关系\"><a href=\"#JMM与硬件内存架构的关系\" class=\"headerlink\" title=\"JMM与硬件内存架构的关系\"></a>JMM与硬件内存架构的关系</h1><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系：</p>\n<p><img src=\"../../../../img/JMM/28089.png\" alt=\"img\"></p>\n<h1 id=\"JMM的内存可见性保证\"><a href=\"#JMM的内存可见性保证\" class=\"headerlink\" title=\"JMM的内存可见性保证\"></a>JMM的内存可见性保证</h1><p>按程序类型，Java程序的内存可见性保证可以分为下列3类：</p>\n<ul>\n<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>\n<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>\n<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。 JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。</li>\n</ul>\n<p>未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异。</p>\n<p>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行，比如正确同步的多线程程序在临界区内的重排序。</p>\n<p>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。</p>\n<p>3）顺序一致性模型保证对所有的内存读/写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性（32位处理器）。</p>\n<blockquote>\n<p>JVM在32位处理器上运行时，可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个32位的写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作将不具有原子性。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性</p>\n</blockquote>\n","next":{"title":"并发基础概念","path":"api/articles/resource-java-concurrent-concurrent.json","image":"/img/header_img/concurrent/concurrentBase.png","num_read":1082,"num_like":105,"num_collection":766,"num_comments":186},"prev":{"title":"并发的可见性深入分析","path":"api/articles/resource-java-concurrent-visibility.json","image":"/img/header_img/concurrent/visibility.png","num_read":597,"num_like":1016,"num_collection":67,"num_comments":77},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}