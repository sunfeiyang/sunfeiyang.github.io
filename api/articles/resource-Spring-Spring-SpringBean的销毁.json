{"title":"SpringBean的销毁","num_read":890,"num_like":458,"num_collection":622,"num_comments":207,"slug":"resource-Spring-Spring-SpringBean的销毁","date":"2021-09-14T16:00:00.000Z","img":"/img/header_img/spring/destruction.png","_id":"cl8dzd09j000pprlg1g6lgjbt","project":"Spring","subtitle":"发生在Spring容器关闭过程中的","site":{"data":{}},"updated":"2022-01-12T05:51:04.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-Spring-Spring-SpringBean的销毁.json","webPath":"2021/09/15/resource-Spring-Spring-SpringBean的销毁/","permalink":"https://fy-blog.gitee.io/sunfy-framework/2021/09/15/resource-Spring-Spring-SpringBean%E7%9A%84%E9%94%80%E6%AF%81/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"Spring中Bean的销毁\"><a href=\"#Spring中Bean的销毁\" class=\"headerlink\" title=\"Spring中Bean的销毁\"></a>Spring中Bean的销毁</h1><p>Bean销毁是发生在Spring容器关闭过程中的。 </p>\n<p>在Spring容器关闭时，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">UserService userService = (UserService) context.getBean(<span class=\"string\">\"userService\"</span>);</span><br><span class=\"line\">userService.test();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容器关闭</span></span><br><span class=\"line\">context.close();</span><br></pre></td></tr></table></figure>\n<p>在Bean创建过程中，在最后（初始化之后），有一个步骤会去判断当前创建的Bean是不是DisposableBean：</p>\n<ul>\n<li>当前Bean是否实现了DisposableBean接口</li>\n<li>或者，当前Bean是否实现了AutoCloseable接口</li>\n<li>BeanDefinition中是否指定了destroyMethod</li>\n<li>调用DestructionAwareBeanPostProcessor.requiresDestruction(bean)进行判断<ul>\n<li>ApplicationListenerDetector中直接使得ApplicationListener是DisposableBean</li>\n<li>InitDestroyAnnotationBeanPostProcessor中使得拥有@PreDestroy注解了的方法就是DisposableBean</li>\n</ul>\n</li>\n<li>把符合上述任意一个条件的Bean适配成DisposableBeanAdapter对象，并存入disposableBeans中（一个LinkedHashMap）<sunfy-line></li>\n</ul>\n<p>在Spring容器关闭过程时：</p>\n<ul>\n<li>首先发布ContextClosedEvent事件</li>\n<li>调用lifecycleProcessor的onCloese()方法</li>\n<li>销毁单例Bean<ul>\n<li>遍历disposableBeans<ul>\n<li>把每个disposableBean从单例池中移除</li>\n<li>调用disposableBean的destroy()</li>\n<li>如果这个disposableBean还被其他Bean依赖了，那么也得销毁其他Bean</li>\n<li>如果这个disposableBean还包含了inner beans，将这些Bean从单例池中移除掉 (inner bean参考<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans</a>)</li>\n</ul>\n</li>\n<li>清空manualSingletonNames，是一个Set，存的是用户手动注册的单例Bean的beanName</li>\n<li>清空allBeanNamesByType，是一个Map，key是bean类型，value是该类型所有的beanName数组</li>\n<li>清空singletonBeanNamesByType，和allBeanNamesByType类似，只不过只存了单例Bean</li>\n</ul>\n</li>\n</ul>\n<p>这里涉及到一个设计模式：<strong>适配器模式</strong></p>\n<p>在销毁时，Spring会找出实现了DisposableBean接口的Bean。 </p>\n<p>但是我们在定义一个Bean时，如果这个Bean实现了DisposableBean接口，或者实现了AutoCloseable接口，或者在BeanDefinition中指定了destroyMethodName，那么这个Bean都属于“DisposableBean”，这些Bean在容器关闭时都要调用相应的销毁方法。</p>\n<p>所以，这里就需要进行适配，将实现了DisposableBean接口、或者AutoCloseable接口等适配成实现了DisposableBean接口，所以就用到了DisposableBeanAdapter。</p>\n<p>会把实现了AutoCloseable接口的类封装成DisposableBeanAdapter，而DisposableBeanAdapter实现了DisposableBean接口。</p>\n","more":"<h1 id=\"Spring中Bean的销毁\"><a href=\"#Spring中Bean的销毁\" class=\"headerlink\" title=\"Spring中Bean的销毁\"></a>Spring中Bean的销毁</h1><p>Bean销毁是发生在Spring容器关闭过程中的。 </p>\n<p>在Spring容器关闭时，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">UserService userService = (UserService) context.getBean(<span class=\"string\">\"userService\"</span>);</span><br><span class=\"line\">userService.test();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容器关闭</span></span><br><span class=\"line\">context.close();</span><br></pre></td></tr></table></figure>\n<p>在Bean创建过程中，在最后（初始化之后），有一个步骤会去判断当前创建的Bean是不是DisposableBean：</p>\n<ul>\n<li>当前Bean是否实现了DisposableBean接口</li>\n<li>或者，当前Bean是否实现了AutoCloseable接口</li>\n<li>BeanDefinition中是否指定了destroyMethod</li>\n<li>调用DestructionAwareBeanPostProcessor.requiresDestruction(bean)进行判断<ul>\n<li>ApplicationListenerDetector中直接使得ApplicationListener是DisposableBean</li>\n<li>InitDestroyAnnotationBeanPostProcessor中使得拥有@PreDestroy注解了的方法就是DisposableBean</li>\n</ul>\n</li>\n<li>把符合上述任意一个条件的Bean适配成DisposableBeanAdapter对象，并存入disposableBeans中（一个LinkedHashMap）<sunfy-line></li>\n</ul>\n<p>在Spring容器关闭过程时：</p>\n<ul>\n<li>首先发布ContextClosedEvent事件</li>\n<li>调用lifecycleProcessor的onCloese()方法</li>\n<li>销毁单例Bean<ul>\n<li>遍历disposableBeans<ul>\n<li>把每个disposableBean从单例池中移除</li>\n<li>调用disposableBean的destroy()</li>\n<li>如果这个disposableBean还被其他Bean依赖了，那么也得销毁其他Bean</li>\n<li>如果这个disposableBean还包含了inner beans，将这些Bean从单例池中移除掉 (inner bean参考<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans</a>)</li>\n</ul>\n</li>\n<li>清空manualSingletonNames，是一个Set，存的是用户手动注册的单例Bean的beanName</li>\n<li>清空allBeanNamesByType，是一个Map，key是bean类型，value是该类型所有的beanName数组</li>\n<li>清空singletonBeanNamesByType，和allBeanNamesByType类似，只不过只存了单例Bean</li>\n</ul>\n</li>\n</ul>\n<p>这里涉及到一个设计模式：<strong>适配器模式</strong></p>\n<p>在销毁时，Spring会找出实现了DisposableBean接口的Bean。 </p>\n<p>但是我们在定义一个Bean时，如果这个Bean实现了DisposableBean接口，或者实现了AutoCloseable接口，或者在BeanDefinition中指定了destroyMethodName，那么这个Bean都属于“DisposableBean”，这些Bean在容器关闭时都要调用相应的销毁方法。</p>\n<p>所以，这里就需要进行适配，将实现了DisposableBean接口、或者AutoCloseable接口等适配成实现了DisposableBean接口，所以就用到了DisposableBeanAdapter。</p>\n<p>会把实现了AutoCloseable接口的类封装成DisposableBeanAdapter，而DisposableBeanAdapter实现了DisposableBean接口。</p>\n","next":{"title":"Spring依赖注入方式和源码分析","path":"api/articles/resource-Spring-Spring-Spring依赖注入方式和源码分析.json","image":"/img/header_img/spring/DependencyInjection.png","num_read":1444,"num_like":857,"num_collection":878,"num_comments":122},"prev":{"title":"Spring启动过程源码解析","path":"api/articles/resource-Spring-Spring-Spring启动过程源码解析.json","image":"/sunfy-framework/img/header_img/spring/process.png","num_read":1800,"num_like":477,"num_collection":145,"num_comments":58},"categories":[{"name":"Spring全家桶","path":"api/categories/Spring全家桶.json","pathContent":"api/categories/Spring全家桶","description":"更快、更容易、更安全","cover":"https://sunfy9.gitee.io/project/photo/project/spring.png"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json","pathContent":"api/tags/Spring","description":"更快、更容易、更安全","cover":"https://sunfy9.gitee.io/project/photo/project/spring.png"}]}