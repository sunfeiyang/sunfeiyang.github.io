{"title":"Oauth2协议及其密码授权模式","num_read":1173,"num_like":1030,"num_collection":658,"num_comments":109,"slug":"resource-MicroService-other-oauth2","date":"2021-11-24T16:00:00.000Z","img":"/img/header_img/MicroService/oauth2.png","format":"gallery","_id":"clhrbp2e100cto5lge0np27cj","project":"MicroService","subtitle":"将应用拆分成一个一个的服务,每一个服务都是提供特定的功能，一个服务只做一件事","hot":"read","site":{"data":{}},"isLock":true,"updated":"2022-09-20T01:55:07.259Z","author":"Sunfy","comments":true,"path":"api/articles/resource-MicroService-other-oauth2.json","webPath":"2021/11/25/resource-MicroService-other-oauth2/","permalink":"https://sunfy9.gitee.io/2021/11/25/resource-MicroService-other-oauth2/","excerpt":null,"covers":["../../../../img/oauth2/clipboard-16378335965551.png","../../../../img/oauth2/clipboard-16378335965562.png","../../../../img/oauth2/clipboard-16378335965573.png","../../../../img/oauth2/6a92a862da97a4692c755c7e186dfd07.jpg","../../../../img/oauth2/clipboard-16378335965574.png","../../../../img/oauth2/clipboard-16378335965575.png","../../../../img/oauth2/clipboard-16378335965576.png","../../../../img/oauth2/clipboard-16378335965577.png","../../../../img/oauth2/clipboard-16378335965588.png","../../../../img/oauth2/clipboard-16378335965589.png","../../../../img/oauth2/clipboard-163783359655810.png","../../../../img/oauth2/clipboard-163783359655811.png","../../../../img/oauth2/image-20201218143315750.png","../../../../img/oauth2/clipboard-163783359655812.png","../../../../img/oauth2/clipboard-163783359655813.png","../../../../img/oauth2/clipboard-163783359655814.png","../../../../img/oauth2/clipboard-163783359655815.png","../../../../img/oauth2/clipboard-163783359655816.png","../../../../img/oauth2/clipboard-163783359655817.png","../../../../img/oauth2/clipboard-163783359655818.png","../../../../img/oauth2/clipboard-163783359655819.png","../../../../img/oauth2/clipboard-163783359655920.png","../../../../img/oauth2/clipboard-163783359655921.png","../../../../img/oauth2/clipboard-163783359655922.png","../../../../img/oauth2/clipboard-163783359655923.png","../../../../img/oauth2/clipboard-163783359655924.png","../../../../img/oauth2/clipboard-163783359655925.png","../../../../img/oauth2/clipboard-163783359655926.png","../../../../img/oauth2/clipboard-163783359655927.png","../../../../img/oauth2/clipboard-163783359655928.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p>学习本课程的前提： 了解Oauth2协议及其密码授权模式，熟悉Spring Security Oauth2和JWT的使用，熟悉Spring Cloud Gateway网关使用。</p>\n<p><strong>1. 架构设计分析</strong></p>\n<p><strong>1.1 多点登录</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965551.png\" alt=\"img\"></p>\n<p><strong>1.2 单点登录</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965562.png\" alt=\"img\"></p>\n<p><strong>1.3 微服务接入网关实现单点登录设计思路</strong></p>\n<p>网关整合 OAuth2.0 有两种思路，一种是授权服务器生成令牌, 所有请求统一在网关层验证，判断权限等操作；另一种是由各资源服务处理，网关只做请求转发。  比较常用的是第一种，把API网关作为OAuth2.0的资源服务器角色，实现接入客户端权限拦截、令牌解析并转发当前登录用户信息给微服务，这样下游微服务就不需要关心令牌格式解析以及OAuth2.0相关机制了。  </p>\n<p>网关在认证授权体系里主要负责两件事：<sunfy-line>（1）作为OAuth2.0的资源服务器角色，实现接入方访问权限拦截。 （2）令牌解析并转发当前登录用户信息（明文token）给微服务 微服务拿到明文token(明文token中包含登录用户的身份和权限信息)后也需要做两件事： （1）用户授权拦截（看当前用户是否有权访问该资源） （2）将用户信息存储进当前线程上下文（有利于后续业务逻辑随时获取当前用户信息） </p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965573.png\" alt=\"img\"></p>\n<p><strong>2. 搭建微服务授权中心</strong></p>\n<p>授权中心的认证依赖：</p>\n<ul>\n<li>第三方客户端的信息</li>\n<li>微服务的信息</li>\n<li>登录用户的信息</li>\n</ul>\n<p>创建微服务tulingmall-auth</p>\n<p><strong>2.1 引入依赖</strong></p>\n<p><strong>2.2 添加yml配置</strong></p>\n<p><strong>2.3 配置授权服务器</strong></p>\n<p><strong>基于DB模式配置授权服务器存储第三方客户端的信息</strong></p>\n<p>在oauth_client_details中添加第三方客户端信息（client_id  client_secret  scope等等）</p>\n<p><strong>基于内存模式配置授权服务器存储第三方客户端的信息</strong></p>\n<p><strong>2.4 配置SpringSecurity</strong></p>\n<p><strong>获取会员信息，此处通过feign从tulingmall-member获取会员信息，需要配置feign，核心代码：</strong></p>\n<p><strong>修改授权服务配置，支持密码模式</strong></p>\n<p><strong>2.5 测试模拟用户登录</strong></p>\n<p><strong>授权码模式</strong></p>\n<p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>\n<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>\n<p>适用场景：目前市面上主流的第三方验证都是采用这种模式</p>\n<p><img src=\"../../../../img/oauth2/6a92a862da97a4692c755c7e186dfd07.jpg\" alt=\"img\"></p>\n<p>它的步骤如下：</p>\n<p>（A）用户访问客户端，后者将前者导向授权服务器。</p>\n<p>（B）用户选择是否给予客户端授权。</p>\n<p>（C）假设用户给予授权，授权服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>\n<p>（D）客户端收到授权码，附上早先的”重定向URI”，向授权服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>\n<p>（E）授权服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>\n<p><a href=\"http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a></p>\n<p>获取到code</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965574.png\" alt=\"img\"></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965575.png\" alt=\"img\"></p>\n<p><strong>密码模式</strong></p>\n<p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p>\n<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而授权服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>\n<p>适用场景：自家公司搭建的授权服务器</p>\n<p>测试获取token</p>\n<p><a href=\"http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965576.png\" alt=\"img\"></p>\n<p>测试校验token接口</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965577.png\" alt=\"img\"></p>\n<p>因为授权服务器的security配置需要携带clientId和clientSecret，可以采用basic Auth的方式发请求</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965588.png\" alt=\"img\"></p>\n<p>注意： 传参是token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965589.png\" alt=\"img\"></p>\n<p><strong>2.6 配置资源服务器</strong></p>\n<p>测试携带token访问资源</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655810.png\" alt=\"img\"></p>\n<p>或者请求头配置Authorization</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655811.png\" alt=\"img\"></p>\n<p><strong>2.7 Spring Security Oauth2整合JWT</strong></p>\n<p>JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网：<a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a></p>\n<p>JWT令牌的优点：</p>\n<ul>\n<li>jwt基于json，非常方便解析。</li>\n<li>可以在令牌中自定义丰富的内容，易扩展。</li>\n<li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</li>\n<li>资源服务使用JWT可不依赖认证服务即可完成授权。</li>\n</ul>\n<p>缺点：</p>\n<p>​    JWT令牌较长，占存储空间比较大。  </p>\n<p>JWT组成</p>\n<p>一个JWT实际上就是一个字符串，它由三部分组成，头部（header）、载荷（payload）与签名（signature）。</p>\n<p><img src=\"../../../../img/oauth2/image-20201218143315750.png\" alt=\"img\"></p>\n<p><strong>头部（header）</strong></p>\n<p>头部用于描述关于该JWT的最基本的信息：类型（即JWT）以及签名所用的算法（如HMACSHA256或RSA）等。</p>\n<p>这也可以被表示成一个JSON对象：</p>\n<p>{  “alg”: “HS256”,  “typ”: “JWT” }</p>\n<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分:</p>\n<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>\n<p><strong>载荷（payload）</strong></p>\n<p>第二部分是载荷，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p>\n<ul>\n<li>标准中注册的声明（建议但不强制使用）  </li>\n</ul>\n<p><strong>iss</strong>: jwt签发者</p>\n<p><strong>sub</strong>: jwt所面向的用户</p>\n<p><strong>aud</strong>: 接收jwt的一方</p>\n<p><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</p>\n<p><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</p>\n<p><strong>iat</strong>: jwt的签发时间</p>\n<p><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>\n<ul>\n<li>公共的声明 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.  </li>\n<li>私有的声明 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。  </li>\n</ul>\n<p>定义一个payload：</p>\n<p>{  “sub”: “1234567890”,  “name”: “John Doe”,  “iat”: 1516239022 }</p>\n<p>然后将其进行base64加密，得到Jwt的第二部分:</p>\n<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</p>\n<p><strong>签名（signature）</strong></p>\n<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>\n<ul>\n<li>header (base64后的)</li>\n<li>payload (base64后的)</li>\n<li>secret(盐，一定要保密）  </li>\n</ul>\n<p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分:</p>\n<p>var encodedString = base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, ‘fox’); // khA7TNYc7_0iELcDyTc7gHBZ_xfIcgbfpzUNWwQtzME</p>\n<p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p>\n<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.khA7TNYc7_0iELcDyTc7gHBZ_xfIcgbfpzUNWwQtzME</p>\n<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>\n<p>引入依赖</p>\n<p><!--spring secuity对jwt的支持 spring cloud oauth2已经依赖，可以不配置--> <dependency>    <groupId>org.springframework.security</groupId>    <artifactId>spring-security-jwt</artifactId>    <version>1.0.9.RELEASE</version> </dependency></p>\n<p>添加JWT配置</p>\n<p>在授权服务器配置中指定令牌的存储策略为JWT </p>\n<p>密码模式测试：</p>\n<p><a href=\"http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655812.png\" alt=\"img\"></p>\n<p><strong>将access_token复制到</strong><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\"><strong>https://jwt.io/</strong></a><strong>的Encoded中打开,可以看到会员认证信息</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655813.png\" alt=\"img\"></p>\n<p>测试校验token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655814.png\" alt=\"img\"></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655815.png\" alt=\"img\"></p>\n<p>测试获取token_key</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655816.png\" alt=\"img\"></p>\n<p>测试刷新token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655817.png\" alt=\"img\"></p>\n<p><strong>2.8 优化：实现JWT非对称加密（公钥私钥）</strong></p>\n<p><strong>第一步：生成jks 证书文件</strong></p>\n<p>我们使用jdk自动的工具生成</p>\n<p>命令格式 </p>\n<p>keytool </p>\n<p>-genkeypair  生成密钥对</p>\n<p>-alias jwt(别名) </p>\n<p>-keypass 123456(别名密码) </p>\n<p>-keyalg RSA(生证书的算法名称，RSA是一种非对称加密算法) </p>\n<p>-keysize 1024(密钥长度,证书大小) </p>\n<p>-validity 365(证书有效期，天单位) </p>\n<p>-keystore D:/jwt/jwt.jks(指定生成证书的位置和证书名称) </p>\n<p>-storepass 123456(获取keystore信息的密码)</p>\n<p>-storetype (指定密钥仓库类型)</p>\n<p>使用 “keytool -help” 获取所有可用命令</p>\n<p>keytool -genkeypair -alias jwt -keyalg RSA -keysize 2048 -keystore D:/jwt/jwt.jks</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655818.png\" alt=\"img\"></p>\n<p>将生成的jwt.jks文件cope到授权服务器的resource目录下</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655819.png\" alt=\"img\"></p>\n<p>查看公钥信息</p>\n<p> keytool -list -rfc —keystore jwt.jks  | openssl x509 -inform pem -pubkey</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655920.png\" alt=\"img\"></p>\n<p>第二步：授权服务中增加jwt的属性配置类</p>\n<p>yml中添加jwt配置</p>\n<p>tuling:  jwt:    keyPairName: jwt.jks    keyPairAlias: jwt    keyPairSecret: 123123    keyPairStoreSecret: 123123</p>\n<p>第三步：修改JwtTokenStoreConfig的配置，支持非对称加密</p>\n<p>第四步：扩展JWT中的存储内容</p>\n<p>有时候我们需要扩展JWT中存储的内容，根据自己业务添加字段到Jwt中。 继承TokenEnhancer实现一个JWT内容增强器 </p>\n<p>在JwtTokenStoreConfig中配置TulingTokenEnhancer</p>\n<p>在授权服务器配置中配置JWT的内容增强器  </p>\n<p>1）通过密码模式测试获取token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655921.png\" alt=\"img\"></p>\n<p><a href=\"https://jwt.io/中校验token，可以获取到增强的用户信息，传入私钥和公钥可以校验通过。\" target=\"_blank\" rel=\"noopener\">https://jwt.io/中校验token，可以获取到增强的用户信息，传入私钥和公钥可以校验通过。</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655922.png\" alt=\"img\"></p>\n<p>2）测试校验token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655923.png\" alt=\"img\"></p>\n<p><strong>3. 接入网关服务</strong></p>\n<p>在网关服务tulingmall-gateway中配置tulingmall-auth</p>\n<p>1）yml中添加对tulingmall-auth的路由</p>\n<p>2）编写GateWay的全局过滤器进行权限的校验拦截 </p>\n<p>认证过滤器AuthenticationFilter#filter中需要实现的逻辑</p>\n<p>//1.过滤不需要认证的url,比如/oauth/** //2. 获取token // 从请求头中解析 Authorization  value:  bearer xxxxxxx // 或者从请求参数中解析 access_token //3. 校验token // 拿到token后，通过公钥（需要从授权服务获取公钥）校验 // 校验失败或超时抛出异常 //4. 校验通过后，从token中获取的用户登录信息存储到请求头中</p>\n<p>1）过滤不需要认证的url ，可以通过yml设置不需要认证的url。</p>\n<p>网关中引入授权中心配置</p>\n<p>- id: tulingmall-auth  uri: lb://tulingmall-auth  predicates:  - Path=/oauth/**</p>\n<p>测试： 密码模式 client_id为会员微服务，能够获取到token信息</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655924.png\" alt=\"img\"></p>\n<p>测试：  会员微服务会员登录逻辑</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655925.png\" alt=\"img\"></p>\n<p>2） 解析请求，获取token</p>\n<p>从请求头中解析 Authorization  value:  bearer xxxxxxx 或者 从请求参数中解析 access_token</p>\n<p>引入依赖</p>\n<p>在AuthenticationFilter#filter中实现获取token的逻辑</p>\n<p>//2. 获取token // 从请求头中解析 Authorization  value:  bearer xxxxxxx // 或者从请求参数中解析 access_token //第一步:解析出我们Authorization的请求头  value为: “bearer XXXXXXXXXXXXXX” String authHeader = exchange.getRequest().getHeaders().getFirst(“Authorization”); //第二步:判断Authorization的请求头是否为空 if(StringUtils.isEmpty(authHeader)) {    log.warn(“需要认证的url,请求头为空”);    throw new GateWayException(ResultCode.AUTHORIZATION_HEADER_IS_EMPTY); }</p>\n<p>测试： 通过网关获取用户优惠券信息，因为请求头中不带token信息，所以会抛出异常</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655926.png\" alt=\"img\"></p>\n<p>3）校验token</p>\n<p>拿到token后，通过公钥（需要从授权服务获取公钥）校验，校验失败或超时抛出异常</p>\n<p>引入依赖</p>\n<p>在AuthenticationFilter#filter中实现校验token的逻辑</p>\n<p>//3. 校验token // 拿到token后，通过公钥（需要从授权服务获取公钥）校验 // 校验失败或超时抛出异常 //第三步 校验我们的jwt 若jwt不对或者超时都会抛出异常 Claims claims = JwtUtils.validateJwtToken(authHeader,publicKey);</p>\n<p>校验token逻辑</p>\n<p>工具类</p>\n<p>需要从tulingmall-auth获取公钥，实现公钥获取逻辑</p>\n<p>注意： 此处不能直接通过@LoadBalancer配置RestTemplate去获取公钥，思考为什么？</p>\n<p>源码参考：</p>\n<p>org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration</p>\n<p>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p>\n<p>测试： 正确的token，通过网关获取用户优惠券信息</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655927.png\" alt=\"img\"></p>\n<p>错误的token，抛出异常</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655928.png\" alt=\"img\"></p>\n<p>4）校验通过后，从token中获取的用户登录信息存储到请求头中</p>\n<p>在AuthenticationFilter#filter中，将从token中获取的用户登陆信息存储到请求头中</p>\n<p>//4. 校验通过后，从token中获取的用户登录信息存储到请求头中 //第四步 把从jwt中解析出来的 用户登陆信息存储到请求头中 ServerWebExchange webExchange = wrapHeader(exchange,claims);</p>\n<p> 解析用户登录信息存储到请求头中</p>\n","more":"<p>学习本课程的前提： 了解Oauth2协议及其密码授权模式，熟悉Spring Security Oauth2和JWT的使用，熟悉Spring Cloud Gateway网关使用。</p>\n<p><strong>1. 架构设计分析</strong></p>\n<p><strong>1.1 多点登录</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965551.png\" alt=\"img\"></p>\n<p><strong>1.2 单点登录</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965562.png\" alt=\"img\"></p>\n<p><strong>1.3 微服务接入网关实现单点登录设计思路</strong></p>\n<p>网关整合 OAuth2.0 有两种思路，一种是授权服务器生成令牌, 所有请求统一在网关层验证，判断权限等操作；另一种是由各资源服务处理，网关只做请求转发。  比较常用的是第一种，把API网关作为OAuth2.0的资源服务器角色，实现接入客户端权限拦截、令牌解析并转发当前登录用户信息给微服务，这样下游微服务就不需要关心令牌格式解析以及OAuth2.0相关机制了。  </p>\n<p>网关在认证授权体系里主要负责两件事：<sunfy-line>（1）作为OAuth2.0的资源服务器角色，实现接入方访问权限拦截。 （2）令牌解析并转发当前登录用户信息（明文token）给微服务 微服务拿到明文token(明文token中包含登录用户的身份和权限信息)后也需要做两件事： （1）用户授权拦截（看当前用户是否有权访问该资源） （2）将用户信息存储进当前线程上下文（有利于后续业务逻辑随时获取当前用户信息） </p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965573.png\" alt=\"img\"></p>\n<p><strong>2. 搭建微服务授权中心</strong></p>\n<p>授权中心的认证依赖：</p>\n<ul>\n<li>第三方客户端的信息</li>\n<li>微服务的信息</li>\n<li>登录用户的信息</li>\n</ul>\n<p>创建微服务tulingmall-auth</p>\n<p><strong>2.1 引入依赖</strong></p>\n<p><strong>2.2 添加yml配置</strong></p>\n<p><strong>2.3 配置授权服务器</strong></p>\n<p><strong>基于DB模式配置授权服务器存储第三方客户端的信息</strong></p>\n<p>在oauth_client_details中添加第三方客户端信息（client_id  client_secret  scope等等）</p>\n<p><strong>基于内存模式配置授权服务器存储第三方客户端的信息</strong></p>\n<p><strong>2.4 配置SpringSecurity</strong></p>\n<p><strong>获取会员信息，此处通过feign从tulingmall-member获取会员信息，需要配置feign，核心代码：</strong></p>\n<p><strong>修改授权服务配置，支持密码模式</strong></p>\n<p><strong>2.5 测试模拟用户登录</strong></p>\n<p><strong>授权码模式</strong></p>\n<p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>\n<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>\n<p>适用场景：目前市面上主流的第三方验证都是采用这种模式</p>\n<p><img src=\"../../../../img/oauth2/6a92a862da97a4692c755c7e186dfd07.jpg\" alt=\"img\"></p>\n<p>它的步骤如下：</p>\n<p>（A）用户访问客户端，后者将前者导向授权服务器。</p>\n<p>（B）用户选择是否给予客户端授权。</p>\n<p>（C）假设用户给予授权，授权服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>\n<p>（D）客户端收到授权码，附上早先的”重定向URI”，向授权服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>\n<p>（E）授权服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>\n<p><a href=\"http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=client&amp;redirect_uri=http://www.baidu.com&amp;scope=all</a></p>\n<p>获取到code</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965574.png\" alt=\"img\"></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965575.png\" alt=\"img\"></p>\n<p><strong>密码模式</strong></p>\n<p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p>\n<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而授权服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>\n<p>适用场景：自家公司搭建的授权服务器</p>\n<p>测试获取token</p>\n<p><a href=\"http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965576.png\" alt=\"img\"></p>\n<p>测试校验token接口</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965577.png\" alt=\"img\"></p>\n<p>因为授权服务器的security配置需要携带clientId和clientSecret，可以采用basic Auth的方式发请求</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965588.png\" alt=\"img\"></p>\n<p>注意： 传参是token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-16378335965589.png\" alt=\"img\"></p>\n<p><strong>2.6 配置资源服务器</strong></p>\n<p>测试携带token访问资源</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655810.png\" alt=\"img\"></p>\n<p>或者请求头配置Authorization</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655811.png\" alt=\"img\"></p>\n<p><strong>2.7 Spring Security Oauth2整合JWT</strong></p>\n<p>JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网：<a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\">https://jwt.io/</a></p>\n<p>JWT令牌的优点：</p>\n<ul>\n<li>jwt基于json，非常方便解析。</li>\n<li>可以在令牌中自定义丰富的内容，易扩展。</li>\n<li>通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。</li>\n<li>资源服务使用JWT可不依赖认证服务即可完成授权。</li>\n</ul>\n<p>缺点：</p>\n<p>​    JWT令牌较长，占存储空间比较大。  </p>\n<p>JWT组成</p>\n<p>一个JWT实际上就是一个字符串，它由三部分组成，头部（header）、载荷（payload）与签名（signature）。</p>\n<p><img src=\"../../../../img/oauth2/image-20201218143315750.png\" alt=\"img\"></p>\n<p><strong>头部（header）</strong></p>\n<p>头部用于描述关于该JWT的最基本的信息：类型（即JWT）以及签名所用的算法（如HMACSHA256或RSA）等。</p>\n<p>这也可以被表示成一个JSON对象：</p>\n<p>{  “alg”: “HS256”,  “typ”: “JWT” }</p>\n<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分:</p>\n<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p>\n<p><strong>载荷（payload）</strong></p>\n<p>第二部分是载荷，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：</p>\n<ul>\n<li>标准中注册的声明（建议但不强制使用）  </li>\n</ul>\n<p><strong>iss</strong>: jwt签发者</p>\n<p><strong>sub</strong>: jwt所面向的用户</p>\n<p><strong>aud</strong>: 接收jwt的一方</p>\n<p><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</p>\n<p><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</p>\n<p><strong>iat</strong>: jwt的签发时间</p>\n<p><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>\n<ul>\n<li>公共的声明 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.  </li>\n<li>私有的声明 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。  </li>\n</ul>\n<p>定义一个payload：</p>\n<p>{  “sub”: “1234567890”,  “name”: “John Doe”,  “iat”: 1516239022 }</p>\n<p>然后将其进行base64加密，得到Jwt的第二部分:</p>\n<p>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</p>\n<p><strong>签名（signature）</strong></p>\n<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>\n<ul>\n<li>header (base64后的)</li>\n<li>payload (base64后的)</li>\n<li>secret(盐，一定要保密）  </li>\n</ul>\n<p>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分:</p>\n<p>var encodedString = base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, ‘fox’); // khA7TNYc7_0iELcDyTc7gHBZ_xfIcgbfpzUNWwQtzME</p>\n<p>将这三部分用.连接成一个完整的字符串,构成了最终的jwt:</p>\n<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.khA7TNYc7_0iELcDyTc7gHBZ_xfIcgbfpzUNWwQtzME</p>\n<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>\n<p>引入依赖</p>\n<p><!--spring secuity对jwt的支持 spring cloud oauth2已经依赖，可以不配置--> <dependency>    <groupId>org.springframework.security</groupId>    <artifactId>spring-security-jwt</artifactId>    <version>1.0.9.RELEASE</version> </dependency></p>\n<p>添加JWT配置</p>\n<p>在授权服务器配置中指定令牌的存储策略为JWT </p>\n<p>密码模式测试：</p>\n<p><a href=\"http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all\" target=\"_blank\" rel=\"noopener\">http://localhost:9999/oauth/token?username=test&amp;password=test&amp;grant_type=password&amp;client_id=client&amp;client_secret=123123&amp;scope=all</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655812.png\" alt=\"img\"></p>\n<p><strong>将access_token复制到</strong><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"noopener\"><strong>https://jwt.io/</strong></a><strong>的Encoded中打开,可以看到会员认证信息</strong></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655813.png\" alt=\"img\"></p>\n<p>测试校验token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655814.png\" alt=\"img\"></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655815.png\" alt=\"img\"></p>\n<p>测试获取token_key</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655816.png\" alt=\"img\"></p>\n<p>测试刷新token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655817.png\" alt=\"img\"></p>\n<p><strong>2.8 优化：实现JWT非对称加密（公钥私钥）</strong></p>\n<p><strong>第一步：生成jks 证书文件</strong></p>\n<p>我们使用jdk自动的工具生成</p>\n<p>命令格式 </p>\n<p>keytool </p>\n<p>-genkeypair  生成密钥对</p>\n<p>-alias jwt(别名) </p>\n<p>-keypass 123456(别名密码) </p>\n<p>-keyalg RSA(生证书的算法名称，RSA是一种非对称加密算法) </p>\n<p>-keysize 1024(密钥长度,证书大小) </p>\n<p>-validity 365(证书有效期，天单位) </p>\n<p>-keystore D:/jwt/jwt.jks(指定生成证书的位置和证书名称) </p>\n<p>-storepass 123456(获取keystore信息的密码)</p>\n<p>-storetype (指定密钥仓库类型)</p>\n<p>使用 “keytool -help” 获取所有可用命令</p>\n<p>keytool -genkeypair -alias jwt -keyalg RSA -keysize 2048 -keystore D:/jwt/jwt.jks</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655818.png\" alt=\"img\"></p>\n<p>将生成的jwt.jks文件cope到授权服务器的resource目录下</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655819.png\" alt=\"img\"></p>\n<p>查看公钥信息</p>\n<p> keytool -list -rfc —keystore jwt.jks  | openssl x509 -inform pem -pubkey</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655920.png\" alt=\"img\"></p>\n<p>第二步：授权服务中增加jwt的属性配置类</p>\n<p>yml中添加jwt配置</p>\n<p>tuling:  jwt:    keyPairName: jwt.jks    keyPairAlias: jwt    keyPairSecret: 123123    keyPairStoreSecret: 123123</p>\n<p>第三步：修改JwtTokenStoreConfig的配置，支持非对称加密</p>\n<p>第四步：扩展JWT中的存储内容</p>\n<p>有时候我们需要扩展JWT中存储的内容，根据自己业务添加字段到Jwt中。 继承TokenEnhancer实现一个JWT内容增强器 </p>\n<p>在JwtTokenStoreConfig中配置TulingTokenEnhancer</p>\n<p>在授权服务器配置中配置JWT的内容增强器  </p>\n<p>1）通过密码模式测试获取token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655921.png\" alt=\"img\"></p>\n<p><a href=\"https://jwt.io/中校验token，可以获取到增强的用户信息，传入私钥和公钥可以校验通过。\" target=\"_blank\" rel=\"noopener\">https://jwt.io/中校验token，可以获取到增强的用户信息，传入私钥和公钥可以校验通过。</a></p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655922.png\" alt=\"img\"></p>\n<p>2）测试校验token</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655923.png\" alt=\"img\"></p>\n<p><strong>3. 接入网关服务</strong></p>\n<p>在网关服务tulingmall-gateway中配置tulingmall-auth</p>\n<p>1）yml中添加对tulingmall-auth的路由</p>\n<p>2）编写GateWay的全局过滤器进行权限的校验拦截 </p>\n<p>认证过滤器AuthenticationFilter#filter中需要实现的逻辑</p>\n<p>//1.过滤不需要认证的url,比如/oauth/** //2. 获取token // 从请求头中解析 Authorization  value:  bearer xxxxxxx // 或者从请求参数中解析 access_token //3. 校验token // 拿到token后，通过公钥（需要从授权服务获取公钥）校验 // 校验失败或超时抛出异常 //4. 校验通过后，从token中获取的用户登录信息存储到请求头中</p>\n<p>1）过滤不需要认证的url ，可以通过yml设置不需要认证的url。</p>\n<p>网关中引入授权中心配置</p>\n<p>- id: tulingmall-auth  uri: lb://tulingmall-auth  predicates:  - Path=/oauth/**</p>\n<p>测试： 密码模式 client_id为会员微服务，能够获取到token信息</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655924.png\" alt=\"img\"></p>\n<p>测试：  会员微服务会员登录逻辑</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655925.png\" alt=\"img\"></p>\n<p>2） 解析请求，获取token</p>\n<p>从请求头中解析 Authorization  value:  bearer xxxxxxx 或者 从请求参数中解析 access_token</p>\n<p>引入依赖</p>\n<p>在AuthenticationFilter#filter中实现获取token的逻辑</p>\n<p>//2. 获取token // 从请求头中解析 Authorization  value:  bearer xxxxxxx // 或者从请求参数中解析 access_token //第一步:解析出我们Authorization的请求头  value为: “bearer XXXXXXXXXXXXXX” String authHeader = exchange.getRequest().getHeaders().getFirst(“Authorization”); //第二步:判断Authorization的请求头是否为空 if(StringUtils.isEmpty(authHeader)) {    log.warn(“需要认证的url,请求头为空”);    throw new GateWayException(ResultCode.AUTHORIZATION_HEADER_IS_EMPTY); }</p>\n<p>测试： 通过网关获取用户优惠券信息，因为请求头中不带token信息，所以会抛出异常</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655926.png\" alt=\"img\"></p>\n<p>3）校验token</p>\n<p>拿到token后，通过公钥（需要从授权服务获取公钥）校验，校验失败或超时抛出异常</p>\n<p>引入依赖</p>\n<p>在AuthenticationFilter#filter中实现校验token的逻辑</p>\n<p>//3. 校验token // 拿到token后，通过公钥（需要从授权服务获取公钥）校验 // 校验失败或超时抛出异常 //第三步 校验我们的jwt 若jwt不对或者超时都会抛出异常 Claims claims = JwtUtils.validateJwtToken(authHeader,publicKey);</p>\n<p>校验token逻辑</p>\n<p>工具类</p>\n<p>需要从tulingmall-auth获取公钥，实现公钥获取逻辑</p>\n<p>注意： 此处不能直接通过@LoadBalancer配置RestTemplate去获取公钥，思考为什么？</p>\n<p>源码参考：</p>\n<p>org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration</p>\n<p>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p>\n<p>测试： 正确的token，通过网关获取用户优惠券信息</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655927.png\" alt=\"img\"></p>\n<p>错误的token，抛出异常</p>\n<p><img src=\"../../../../img/oauth2/clipboard-163783359655928.png\" alt=\"img\"></p>\n<p>4）校验通过后，从token中获取的用户登录信息存储到请求头中</p>\n<p>在AuthenticationFilter#filter中，将从token中获取的用户登陆信息存储到请求头中</p>\n<p>//4. 校验通过后，从token中获取的用户登录信息存储到请求头中 //第四步 把从jwt中解析出来的 用户登陆信息存储到请求头中 ServerWebExchange webExchange = wrapHeader(exchange,claims);</p>\n<p> 解析用户登录信息存储到请求头中</p>\n","next":{"title":"synchronized原理分析","path":"api/articles/resource-java-concurrent-synchronized.json","image":"/img/header_img/concurrent/synchronized.png","num_read":465,"num_like":428,"num_collection":763,"num_comments":27},"prev":{"title":"MySQL执行计划和索引实践","inTheUpdate":true,"path":"api/articles/resource-DB-MySQL-MySQL-execution.json","image":"/img/header_img/DB/execution.png","num_read":903,"num_like":383,"num_collection":444,"num_comments":62},"categories":[{"name":"微服务","path":"api/categories/微服务.json","pathContent":"api/categories/微服务","description":"一种云原生框架方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成","cover":"https://sunfy9.gitee.io/project/photo/project/MicroService.PNG"}],"tags":[]}