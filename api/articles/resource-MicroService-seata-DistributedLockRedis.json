{"title":"Redis实现分布式锁","num_read":37,"num_like":248,"num_collection":39,"num_comments":147,"slug":"resource-MicroService-seata-DistributedLockRedis","date":"2022-01-07T16:00:00.000Z","img":"/img/header_img/MicroService/distributedTransactionRedis.PNG","minNumber":1200,"_id":"clhrbp2dx00bso5lge5wlgjs3","project":"MicroService","type":"banner","subtitle":"分布式事务解决方案Redis|Zookeepar|MySQL|seate","hot":"collection","site":{"data":{}},"updated":"2022-09-20T01:55:57.268Z","author":"Sunfy","comments":true,"path":"api/articles/resource-MicroService-seata-DistributedLockRedis.json","webPath":"2022/01/08/resource-MicroService-seata-DistributedLockRedis/","permalink":"https://sunfy9.gitee.io/2022/01/08/resource-MicroService-seata-DistributedLockRedis/","excerpt":null,"covers":["../../../../img/DistributedLockRedis/image-20220110165633311.png","../../../../img/DistributedLockRedis/image-20220110165657738.png","../../../../img/DistributedLockRedis/image-20220110204900047.png","../../../../img/DistributedLockRedis/image-20220110170440709.png","../../../../img/DistributedLockRedis/image-20220110173127535.png","../../../../img/DistributedLockRedis/image-20220110173525838.png","../../../../img/DistributedLockRedis/image-20220110205631625.png","../../../../img/DistributedLockRedis/image-20220110205610353.png","../../../../img/DistributedLockRedis/image-20220110222137957.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"单体架构\"><a href=\"#单体架构\" class=\"headerlink\" title=\"单体架构\"></a>单体架构</h1><p>先介绍一个很简单的业务场景，简单来说就是一个springBoot工程，然后通过请求一个接口去递减Redis中一个值，可以理解为扣库存或其他类似场景。</p>\n<p>如果我们部署的为单体服务，毫无疑问，Redis中初始值20，每次请求递减1，那我们必然是请求20次可以递减为0。这也是我们想要达到的效果。</p>\n<p>简单的代码代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><sunfy-line>在这只贴了<code>controller</code>中的扣减的方法代码，其他的都是最简单的<code>springBoot</code>项目中，没有别的代码。</p>\n<blockquote>\n<p>测试之前要在<code>redis</code>中添加<code>stock</code>键值，初始值为20</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110165633311.png\" alt=\"image-20220110165633311\"></p>\n</blockquote>\n<p>调用接口进行测试结果：</p>\n<blockquote>\n<p>正常输出end，控制台输出-模拟扣减库存成功，库存剩余:19</p>\n</blockquote>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110165657738.png\" alt=\"image-20220110165657738\"></p>\n<p>但是，在高并发下的，我们上述的代码还能满足我们的预期吗？</p>\n<h2 id=\"JMeter测试结果\"><a href=\"#JMeter测试结果\" class=\"headerlink\" title=\"JMeter测试结果\"></a><code>JMeter</code>测试结果</h2><p><img src=\"../../../../img/DistributedLockRedis/image-20220110204900047.png\" alt=\"image-20220110204900047\"></p>\n<p>很显然，上面的代码存在并发问题，我们可以使用同步代码块，保证上面的逻辑达到我们的预期</p>\n<p>修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至次，单体结构下是能够满足我们的预期，我们本篇主要讨论分布式锁的问题，所以单体架构我们就直接使用<code>synchronized</code>，单体服务不是我们本篇的重点，此处不做过多解释。</p>\n<h1 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h1><p>最简单的分布式架构图：</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110170440709.png\" alt=\"image-20220110170440709\"></p>\n<p>我们接下来模拟上图中的架构来简单搭建一个分布式的架构，（基于我们刚刚完成的单体架构）</p>\n<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a><code>nginx</code>配置</h2><figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http中添加</span><br><span class=\"line\">upstream redisLock&#123;</span><br><span class=\"line\">    server 192.168.88.1:8080 weight=1;</span><br><span class=\"line\">    server 192.168.88.1:8081 weight=1; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http-&gt;server中添加</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    root   html;</span><br><span class=\"line\">    index  index.html index.htm;</span><br><span class=\"line\">    proxy_pass http://redisLock/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Springboot启动配置\"><a href=\"#Springboot启动配置\" class=\"headerlink\" title=\"Springboot启动配置\"></a><code>Springboot</code>启动配置</h2><blockquote>\n<p>idea中设置可以并行运行，启动一个8080端口的，然后再启动一个8081端口</p>\n</blockquote>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110173127535.png\" alt=\"image-20220110173127535\"></p>\n<p>分别启动<code>nginx</code>和两个不同端口的<code>springBoot</code>工程，然后访问<code>nginx</code>服务对应的路径<code>http://192.168.88.88/test</code></p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110173525838.png\" alt=\"image-20220110173525838\"></p>\n<p>我们的微服务架构搭建完毕，接下来我们使用压测工具测试一下，看能否达到我们预期效果</p>\n<h2 id=\"JMeter测试\"><a href=\"#JMeter测试\" class=\"headerlink\" title=\"JMeter测试\"></a><code>JMeter</code>测试</h2><p>8081:</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110205631625.png\" alt=\"image-20220110205631625\"></p>\n<p>8080:</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110205610353.png\" alt=\"image-20220110205610353\"></p>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><p>通过两个服务打印的日志我们可以了解到库存17的时候出现了，一个库存卖了两次的问题。可想而知这个和我们的预期不同，我们也就要增加我们本篇重点的分布式的问题。</p>\n<h1 id=\"redis分布式锁\"><a href=\"#redis分布式锁\" class=\"headerlink\" title=\"redis分布式锁\"></a><code>redis</code>分布式锁</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String lock = <span class=\"string\">\"lock\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// stringRedisTemplate是spring封装的redis工具类，相当于jedis.setnx(key,value)</span></span><br><span class=\"line\">    Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(lock, <span class=\"string\">\"sunfy\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aBoolean) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"分布式锁未获取成功\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stringRedisTemplate.delete(lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码如上，我们可以将<code>jvm</code>层级的同步锁修改为基于Redis的分布式锁，上面使用到的<code>stringRedisTemplate</code>是<code>spring</code>封装的Redis工具类，我们需要引入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>stringRedisTemplate.opsForValue().setIfAbsent(lock, &quot;sunfy&quot;)</code>执行时，如果在Redis中如果存在<code>lock</code>的key时，不会做任何的事情，如果Redis中没有对应的key，则会写入对应的key，等同于<code>jedis.setnx(key,value)</code>命令。</p>\n<p>上面代码中我们在执行业务逻辑之前，先写入某个key，写入成功返回true则继续执行具体的业务代码，如果返回false，则说明加锁失败，则返回提示语，不会执行具体的业务逻辑。具体业务代码执行完毕之后，我们再将对应的key进行删除，这样能够保证在分布式或集群环境下我们代码的可靠性，从而达到我们预期的效果。</p>\n<font style=\"color:red\">这样我们就一切安好了吗？当然不是</font>\n\n<h2 id=\"问题1：业务代码异常\"><a href=\"#问题1：业务代码异常\" class=\"headerlink\" title=\"问题1：业务代码异常\"></a>问题1：业务代码异常</h2><p>这个是很常见的，也很容易想明白的问题，业务代码如果抛出异常，那么锁删除的代码将不会执行，那我们后续的代码将永远无法获取到锁。解决这个问题比较容易，将我们的业务代码try{}finally{}，将最后删除锁的逻辑写在finally中，保证删除锁逻辑一定执行，可以保证在业务代码抛出异常的情况，也能正常删除锁。</p>\n<h2 id=\"问题2：删除锁逻辑异常\"><a href=\"#问题2：删除锁逻辑异常\" class=\"headerlink\" title=\"问题2：删除锁逻辑异常\"></a>问题2：删除锁逻辑异常</h2><p>虽说我们将删除锁逻辑放在finally中，保证了代码一定执行，但是在删除锁代码执行过程中如果抛出异常呢，导致删除锁执行失败呢？这样的情况我们不能否认是可能出现的，那我们就需要进一步健壮我们的代码。</p>\n<p>解决这个问题，我们可以通过key的时效来解决，也就是在设置key时设定key的过期时间，过期后自动删除，这样可以保证在锁删除失败的情况下，锁过期后也会自动删除，当然在锁未过期的这段时间内，其他线程是无法获取到锁的。</p>\n<p>增加key的过期时间</p>\n<blockquote>\n<p>stringRedisTemplate.expire(lock, 10, TimeUnit.SECONDS);</p>\n</blockquote>\n<p>此处设置的过期时间为10秒，10秒后当前设定的key会自动删除。</p>\n<h2 id=\"问题3：业务代码在锁超时时间内未执行完成\"><a href=\"#问题3：业务代码在锁超时时间内未执行完成\" class=\"headerlink\" title=\"问题3：业务代码在锁超时时间内未执行完成\"></a>问题3：业务代码在锁超时时间内未执行完成</h2><p>假设我们有一个比较复杂的业务逻辑代码，可能执行时间需要<code>12s</code>，但是我们设置的锁的超时时间只有<code>10s</code>，锁超时后，当前线程持有的锁被删除，但是业务并未执行完成，这样同样会导致业务代码执行不符合我们预期的情况。</p>\n<p>解决这个问题我们就需要给key增加锁续命的逻辑，我们可以通过新起一个线程，监控当前key的过期时间，可以在锁过期时间还剩一半或者三分之一的时候，检查一下当前持有锁的线程是否还是原线程，如果是则给当前key设置过期时间为原本的过期时间，循环往复，直至逻辑执行完成，删除锁。</p>\n<h2 id=\"问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\"><a href=\"#问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\" class=\"headerlink\" title=\"问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\"></a>问题4：高并发的情况下，删除锁的线程和加锁的线程不一致</h2><p>也就是删除了不是本线程加的锁，同样的会导致我们达不到预期的效果，这个的解决方案我们可以在锁的key值上做一些文章，比如在加锁时，锁的key增加当前当前线程的标识，并在删除锁时，判断当前删除的锁是否是本线程加的锁，是则删除，否则不删除。</p>\n<blockquote>\n<p>加锁</p>\n<p>String clientId = UUID.randomUUID().toString();<br>Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lock, clientId,10, TimeUnit.SECONDS);</p>\n<p>解锁</p>\n<p>if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))){<br>   stringRedisTemplate.delete(lockKey);<br>}</p>\n</blockquote>\n<p>这几个问题是我们容易想到的一些问题，但是我们也不能说我们现在的代码就能够百分百解决分布式锁的问题，我们只能尽可能提升代码的健壮性，已保证我们业务达到预期的效果。</p>\n<h1 id=\"Redisson分布式锁\"><a href=\"#Redisson分布式锁\" class=\"headerlink\" title=\"Redisson分布式锁\"></a><code>Redisson</code>分布式锁</h1><p><code>Redisson</code>分布式锁，是一个开源的基于Redis实现的分布式锁，我们上述的这些问题，在<code>Redisson</code>中都已经帮我们时间，我们可以开箱即用，避免我们重复造轮子，也可以让我们更避免很多坑。</p>\n<h2 id=\"实现原理图\"><a href=\"#实现原理图\" class=\"headerlink\" title=\"实现原理图\"></a>实现原理图</h2><p><img src=\"../../../../img/DistributedLockRedis/image-20220110222137957.png\" alt=\"image-20220110222137957\"></p>\n<p>至于<code>Redisson</code>中的实现，里面使用到了大量的lua脚本，篇幅问题我们，此处不做过多介绍。我们就介绍一下如果使用<code>Redisson</code>解决我们上述的业务</p>\n<h2 id=\"引包\"><a href=\"#引包\" class=\"headerlink\" title=\"引包\"></a>引包</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.6.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String lockKey = <span class=\"string\">\"product_101\"</span>;</span><br><span class=\"line\">    RLock redissonLock = redisson.getLock(lockKey);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        redissonLock.lock(); </span><br><span class=\"line\">        <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>)); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        redissonLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，我们使用还是很简单的，只需要简单的调用<code>redissonLock.lock();</code>和<code>redissonLock.unlock();</code>进行加锁解锁就可以了。</p>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><p>我们考虑一种情况，如果我们Redis使用的是集群或者主从架构，当我们在主节点加锁成功后，还未同步给从节点时，主节点的Redis宕机了，那此时还是会出现问题。</p>\n<p>如果要解决这个问题，我们可以采用基于<code>zookeeper</code>实现的分布式锁，因为在<code>zookeeper</code>集群中采用的是强一致性协议，也就是集群中有多个节点都写入成功后，才会返回给客户端加锁成功的反馈，此时如果主节点宕机，那肯定会选择有加锁成功的节点为新的主节点。</p>\n<p>如果非得使用Redis，<code>RedLock</code>中也实现了类似zk集群的形式，不过这个不推荐使用，可能存在bug。</p>\n","more":"<h1 id=\"单体架构\"><a href=\"#单体架构\" class=\"headerlink\" title=\"单体架构\"></a>单体架构</h1><p>先介绍一个很简单的业务场景，简单来说就是一个springBoot工程，然后通过请求一个接口去递减Redis中一个值，可以理解为扣库存或其他类似场景。</p>\n<p>如果我们部署的为单体服务，毫无疑问，Redis中初始值20，每次请求递减1，那我们必然是请求20次可以递减为0。这也是我们想要达到的效果。</p>\n<p>简单的代码代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><sunfy-line>在这只贴了<code>controller</code>中的扣减的方法代码，其他的都是最简单的<code>springBoot</code>项目中，没有别的代码。</p>\n<blockquote>\n<p>测试之前要在<code>redis</code>中添加<code>stock</code>键值，初始值为20</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110165633311.png\" alt=\"image-20220110165633311\"></p>\n</blockquote>\n<p>调用接口进行测试结果：</p>\n<blockquote>\n<p>正常输出end，控制台输出-模拟扣减库存成功，库存剩余:19</p>\n</blockquote>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110165657738.png\" alt=\"image-20220110165657738\"></p>\n<p>但是，在高并发下的，我们上述的代码还能满足我们的预期吗？</p>\n<h2 id=\"JMeter测试结果\"><a href=\"#JMeter测试结果\" class=\"headerlink\" title=\"JMeter测试结果\"></a><code>JMeter</code>测试结果</h2><p><img src=\"../../../../img/DistributedLockRedis/image-20220110204900047.png\" alt=\"image-20220110204900047\"></p>\n<p>很显然，上面的代码存在并发问题，我们可以使用同步代码块，保证上面的逻辑达到我们的预期</p>\n<p>修改代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至次，单体结构下是能够满足我们的预期，我们本篇主要讨论分布式锁的问题，所以单体架构我们就直接使用<code>synchronized</code>，单体服务不是我们本篇的重点，此处不做过多解释。</p>\n<h1 id=\"分布式架构\"><a href=\"#分布式架构\" class=\"headerlink\" title=\"分布式架构\"></a>分布式架构</h1><p>最简单的分布式架构图：</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110170440709.png\" alt=\"image-20220110170440709\"></p>\n<p>我们接下来模拟上图中的架构来简单搭建一个分布式的架构，（基于我们刚刚完成的单体架构）</p>\n<h2 id=\"nginx配置\"><a href=\"#nginx配置\" class=\"headerlink\" title=\"nginx配置\"></a><code>nginx</code>配置</h2><figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http中添加</span><br><span class=\"line\">upstream redisLock&#123;</span><br><span class=\"line\">    server 192.168.88.1:8080 weight=1;</span><br><span class=\"line\">    server 192.168.88.1:8081 weight=1; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http-&gt;server中添加</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    root   html;</span><br><span class=\"line\">    index  index.html index.htm;</span><br><span class=\"line\">    proxy_pass http://redisLock/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Springboot启动配置\"><a href=\"#Springboot启动配置\" class=\"headerlink\" title=\"Springboot启动配置\"></a><code>Springboot</code>启动配置</h2><blockquote>\n<p>idea中设置可以并行运行，启动一个8080端口的，然后再启动一个8081端口</p>\n</blockquote>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110173127535.png\" alt=\"image-20220110173127535\"></p>\n<p>分别启动<code>nginx</code>和两个不同端口的<code>springBoot</code>工程，然后访问<code>nginx</code>服务对应的路径<code>http://192.168.88.88/test</code></p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110173525838.png\" alt=\"image-20220110173525838\"></p>\n<p>我们的微服务架构搭建完毕，接下来我们使用压测工具测试一下，看能否达到我们预期效果</p>\n<h2 id=\"JMeter测试\"><a href=\"#JMeter测试\" class=\"headerlink\" title=\"JMeter测试\"></a><code>JMeter</code>测试</h2><p>8081:</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110205631625.png\" alt=\"image-20220110205631625\"></p>\n<p>8080:</p>\n<p><img src=\"../../../../img/DistributedLockRedis/image-20220110205610353.png\" alt=\"image-20220110205610353\"></p>\n<h2 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h2><p>通过两个服务打印的日志我们可以了解到库存17的时候出现了，一个库存卖了两次的问题。可想而知这个和我们的预期不同，我们也就要增加我们本篇重点的分布式的问题。</p>\n<h1 id=\"redis分布式锁\"><a href=\"#redis分布式锁\" class=\"headerlink\" title=\"redis分布式锁\"></a><code>redis</code>分布式锁</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test1\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String lock = <span class=\"string\">\"lock\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// stringRedisTemplate是spring封装的redis工具类，相当于jedis.setnx(key,value)</span></span><br><span class=\"line\">    Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(lock, <span class=\"string\">\"sunfy\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aBoolean) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"分布式锁未获取成功\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">        stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stringRedisTemplate.delete(lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码如上，我们可以将<code>jvm</code>层级的同步锁修改为基于Redis的分布式锁，上面使用到的<code>stringRedisTemplate</code>是<code>spring</code>封装的Redis工具类，我们需要引入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>stringRedisTemplate.opsForValue().setIfAbsent(lock, &quot;sunfy&quot;)</code>执行时，如果在Redis中如果存在<code>lock</code>的key时，不会做任何的事情，如果Redis中没有对应的key，则会写入对应的key，等同于<code>jedis.setnx(key,value)</code>命令。</p>\n<p>上面代码中我们在执行业务逻辑之前，先写入某个key，写入成功返回true则继续执行具体的业务代码，如果返回false，则说明加锁失败，则返回提示语，不会执行具体的业务逻辑。具体业务代码执行完毕之后，我们再将对应的key进行删除，这样能够保证在分布式或集群环境下我们代码的可靠性，从而达到我们预期的效果。</p>\n<font style=\"color:red\">这样我们就一切安好了吗？当然不是</font>\n\n<h2 id=\"问题1：业务代码异常\"><a href=\"#问题1：业务代码异常\" class=\"headerlink\" title=\"问题1：业务代码异常\"></a>问题1：业务代码异常</h2><p>这个是很常见的，也很容易想明白的问题，业务代码如果抛出异常，那么锁删除的代码将不会执行，那我们后续的代码将永远无法获取到锁。解决这个问题比较容易，将我们的业务代码try{}finally{}，将最后删除锁的逻辑写在finally中，保证删除锁逻辑一定执行，可以保证在业务代码抛出异常的情况，也能正常删除锁。</p>\n<h2 id=\"问题2：删除锁逻辑异常\"><a href=\"#问题2：删除锁逻辑异常\" class=\"headerlink\" title=\"问题2：删除锁逻辑异常\"></a>问题2：删除锁逻辑异常</h2><p>虽说我们将删除锁逻辑放在finally中，保证了代码一定执行，但是在删除锁代码执行过程中如果抛出异常呢，导致删除锁执行失败呢？这样的情况我们不能否认是可能出现的，那我们就需要进一步健壮我们的代码。</p>\n<p>解决这个问题，我们可以通过key的时效来解决，也就是在设置key时设定key的过期时间，过期后自动删除，这样可以保证在锁删除失败的情况下，锁过期后也会自动删除，当然在锁未过期的这段时间内，其他线程是无法获取到锁的。</p>\n<p>增加key的过期时间</p>\n<blockquote>\n<p>stringRedisTemplate.expire(lock, 10, TimeUnit.SECONDS);</p>\n</blockquote>\n<p>此处设置的过期时间为10秒，10秒后当前设定的key会自动删除。</p>\n<h2 id=\"问题3：业务代码在锁超时时间内未执行完成\"><a href=\"#问题3：业务代码在锁超时时间内未执行完成\" class=\"headerlink\" title=\"问题3：业务代码在锁超时时间内未执行完成\"></a>问题3：业务代码在锁超时时间内未执行完成</h2><p>假设我们有一个比较复杂的业务逻辑代码，可能执行时间需要<code>12s</code>，但是我们设置的锁的超时时间只有<code>10s</code>，锁超时后，当前线程持有的锁被删除，但是业务并未执行完成，这样同样会导致业务代码执行不符合我们预期的情况。</p>\n<p>解决这个问题我们就需要给key增加锁续命的逻辑，我们可以通过新起一个线程，监控当前key的过期时间，可以在锁过期时间还剩一半或者三分之一的时候，检查一下当前持有锁的线程是否还是原线程，如果是则给当前key设置过期时间为原本的过期时间，循环往复，直至逻辑执行完成，删除锁。</p>\n<h2 id=\"问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\"><a href=\"#问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\" class=\"headerlink\" title=\"问题4：高并发的情况下，删除锁的线程和加锁的线程不一致\"></a>问题4：高并发的情况下，删除锁的线程和加锁的线程不一致</h2><p>也就是删除了不是本线程加的锁，同样的会导致我们达不到预期的效果，这个的解决方案我们可以在锁的key值上做一些文章，比如在加锁时，锁的key增加当前当前线程的标识，并在删除锁时，判断当前删除的锁是否是本线程加的锁，是则删除，否则不删除。</p>\n<blockquote>\n<p>加锁</p>\n<p>String clientId = UUID.randomUUID().toString();<br>Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lock, clientId,10, TimeUnit.SECONDS);</p>\n<p>解锁</p>\n<p>if (clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))){<br>   stringRedisTemplate.delete(lockKey);<br>}</p>\n</blockquote>\n<p>这几个问题是我们容易想到的一些问题，但是我们也不能说我们现在的代码就能够百分百解决分布式锁的问题，我们只能尽可能提升代码的健壮性，已保证我们业务达到预期的效果。</p>\n<h1 id=\"Redisson分布式锁\"><a href=\"#Redisson分布式锁\" class=\"headerlink\" title=\"Redisson分布式锁\"></a><code>Redisson</code>分布式锁</h1><p><code>Redisson</code>分布式锁，是一个开源的基于Redis实现的分布式锁，我们上述的这些问题，在<code>Redisson</code>中都已经帮我们时间，我们可以开箱即用，避免我们重复造轮子，也可以让我们更避免很多坑。</p>\n<h2 id=\"实现原理图\"><a href=\"#实现原理图\" class=\"headerlink\" title=\"实现原理图\"></a>实现原理图</h2><p><img src=\"../../../../img/DistributedLockRedis/image-20220110222137957.png\" alt=\"image-20220110222137957\"></p>\n<p>至于<code>Redisson</code>中的实现，里面使用到了大量的lua脚本，篇幅问题我们，此处不做过多介绍。我们就介绍一下如果使用<code>Redisson</code>解决我们上述的业务</p>\n<h2 id=\"引包\"><a href=\"#引包\" class=\"headerlink\" title=\"引包\"></a>引包</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.6.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String lockKey = <span class=\"string\">\"product_101\"</span>;</span><br><span class=\"line\">    RLock redissonLock = redisson.getLock(lockKey);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        redissonLock.lock(); </span><br><span class=\"line\">        <span class=\"keyword\">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class=\"string\">\"stock\"</span>)); </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> realStock = stock - <span class=\"number\">1</span>;</span><br><span class=\"line\">            stringRedisTemplate.opsForValue().set(<span class=\"string\">\"stock\"</span>, realStock + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存成功，库存剩余:\"</span> + realStock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"模拟扣减库存失败，库存不足\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        redissonLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"end\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，我们使用还是很简单的，只需要简单的调用<code>redissonLock.lock();</code>和<code>redissonLock.unlock();</code>进行加锁解锁就可以了。</p>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><p>我们考虑一种情况，如果我们Redis使用的是集群或者主从架构，当我们在主节点加锁成功后，还未同步给从节点时，主节点的Redis宕机了，那此时还是会出现问题。</p>\n<p>如果要解决这个问题，我们可以采用基于<code>zookeeper</code>实现的分布式锁，因为在<code>zookeeper</code>集群中采用的是强一致性协议，也就是集群中有多个节点都写入成功后，才会返回给客户端加锁成功的反馈，此时如果主节点宕机，那肯定会选择有加锁成功的节点为新的主节点。</p>\n<p>如果非得使用Redis，<code>RedLock</code>中也实现了类似zk集群的形式，不过这个不推荐使用，可能存在bug。</p>\n","next":{"title":"分布式/微服务常见的面试题","path":"api/articles/resource-MicroService-other-微服务相关面试题.json","image":"/img/header_img/MicroService/MicroServiceInterview.png","num_read":1716,"num_like":68,"num_collection":100,"num_comments":125},"prev":{"title":"SkyWalking简介","path":"api/articles/resource-MicroService-Skywalking-SkywalkingBase.json","image":"/img/header_img/MicroService/SkywalkingBase.png","num_read":1128,"num_like":621,"num_collection":390,"num_comments":86},"categories":[{"name":"微服务","path":"api/categories/微服务.json","pathContent":"api/categories/微服务","description":"一种云原生框架方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成","cover":"https://sunfy9.gitee.io/project/photo/project/MicroService.PNG"}],"tags":[{"name":"Redis","path":"api/tags/Redis.json","pathContent":"api/tags/Redis","description":"[Redis]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"},{"name":"Transaction","path":"api/tags/Transaction.json","pathContent":"api/tags/Transaction","description":"[Transaction]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}