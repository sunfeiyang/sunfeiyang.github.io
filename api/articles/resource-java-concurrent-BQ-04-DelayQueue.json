{"title":"DelayQueue介绍","num_read":909,"num_like":561,"num_collection":266,"num_comments":288,"slug":"resource-java-concurrent-BQ-04-DelayQueue","date":"2021-12-15T16:00:00.000Z","img":"/img/header_img/concurrent/DelayQueue.png","minNumber":600,"format":"standard","_id":"clhrbp2dn009qo5lgftma8cfk","project":"concurrent","subtitle":"DelayQueue 是一个支持延时获取元素的阻塞队列","site":{"data":{}},"updated":"2022-01-12T05:40:28.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-04-DelayQueue.json","webPath":"2021/12/16/resource-java-concurrent-BQ-04-DelayQueue/","permalink":"https://sunfy9.gitee.io/2021/12/16/resource-java-concurrent-BQ-04-DelayQueue/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a><strong>DelayQueue</strong></h1><p>DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。延迟队列的特点是：不是先进先出，而是会按照延迟时间的长短来排序，下一个即将执行的任务会排到队列的最前面。</p>\n<p>它是无界队列，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Delayed</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//getDelay 方法返回的是“还剩下多长的延迟时间才会被执行”，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果返回 0 或者负数则代表任务已过期。</span></span><br><span class=\"line\">    <span class=\"comment\">//元素会根据延迟时间的长短被放到队列的不同位置，越靠近队列头代表越早过期。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个使用优先级队列实现的无界阻塞队列</p>\n<p>数据结构：PriorityQueue，与PriorityBlockingQueue类似，不过没有阻塞功能</p>\n<p>锁：ReentrantLock</p>\n<p>阻塞对象：Condition available</p>\n<p>入队：不阻塞，无界队列，与优先级队列入队相同，available</p>\n<p>出队：<sunfy-line></p>\n<ul>\n<li>为空时阻塞</li>\n<li>检查堆顶元素过期时间<ul>\n<li>小于等于0则出队</li>\n<li>大于0，说明没过期，则阻塞（判断leader线程是否为空（为了保证优先级））<ul>\n<li>不为空（已有线程阻塞），直接阻塞</li>\n<li>为空，则将当前线程置为leader，并按照过期时间进行阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>商城订单超时关闭-订单业务，下单之后如果三十分钟内没有支付自动取消</li>\n<li>异步短信通知功能-饿了么订单通知，下单成功后60s之后给用户发送短信通知</li>\n<li>关闭空闲连接-服务器中，有很多客户端连接，空闲一段时间之后需要关闭</li>\n<li>缓存过期清除-缓存中的对象，超过了存货时间，需要从缓存中移除</li>\n<li>任务超时处理-在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等</li>\n</ul>\n<p><strong>DelayQueue使用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelayQueue&lt;OrderInfo&gt; queue = <span class=\"keyword\">new</span> DelayQueue&lt;OrderInfo&gt;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><strong>原理</strong></h2><p><strong>数据结构</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于保证队列操作的线程安全</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// 优先级队列,存储元素，用于保证延迟低的优先执行</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用于标记当前是否有线程在排队（仅用于取元素时） leader 指向的是第一个从队列获取元素阻塞的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 条件，用于表示现在是否有可取的元素   当新元素到达，或新线程可能需要成为leader时被通知</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayQueue</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayQueue</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>入队put方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    offer(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 入队</span></span><br><span class=\"line\">        q.offer(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.peek() == e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若入队的元素位于队列头部，说明当前元素延迟最小</span></span><br><span class=\"line\">            <span class=\"comment\">// 将 leader 置空</span></span><br><span class=\"line\">            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock(); <span class=\"comment\">// 解锁，真正唤醒阻塞的线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>出队take方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            E first = q.peek();<span class=\"comment\">// 取出堆顶元素   </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)<span class=\"comment\">// 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span></span><br><span class=\"line\">                available.await();</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);<span class=\"comment\">// 堆顶元素的到期时间             </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)<span class=\"comment\">// 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q.poll();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 如果delay大于0 ，则下面要阻塞了</span></span><br><span class=\"line\">                <span class=\"comment\">// 将first置为空方便gc</span></span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                <span class=\"comment\">// 如果前面有其它线程在等待，直接进入等待</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果leader为null，把当前线程赋值给它</span></span><br><span class=\"line\">                    Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                    leader = thisThread;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 等待delay时间后自动醒过来</span></span><br><span class=\"line\">                        <span class=\"comment\">// 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期</span></span><br><span class=\"line\">                        <span class=\"comment\">// 这里即使醒过来后也不一定能获取到元素</span></span><br><span class=\"line\">                        <span class=\"comment\">// 因为有可能其它线程先一步获取了锁并弹出了堆顶元素</span></span><br><span class=\"line\">                        <span class=\"comment\">// 条件锁的唤醒分成两步，先从Condition的队列里出队</span></span><br><span class=\"line\">                        <span class=\"comment\">// 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒</span></span><br><span class=\"line\">                        available.awaitNanos(delay);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; q.peek() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        <span class=\"comment\">// 解锁，真正唤醒阻塞的线程</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","more":"<h1 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a><strong>DelayQueue</strong></h1><p>DelayQueue 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 PriorityQueue 存储元素，同时元素必须实现 Delayed 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。延迟队列的特点是：不是先进先出，而是会按照延迟时间的长短来排序，下一个即将执行的任务会排到队列的最前面。</p>\n<p>它是无界队列，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Delayed</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//getDelay 方法返回的是“还剩下多长的延迟时间才会被执行”，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果返回 0 或者负数则代表任务已过期。</span></span><br><span class=\"line\">    <span class=\"comment\">//元素会根据延迟时间的长短被放到队列的不同位置，越靠近队列头代表越早过期。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个使用优先级队列实现的无界阻塞队列</p>\n<p>数据结构：PriorityQueue，与PriorityBlockingQueue类似，不过没有阻塞功能</p>\n<p>锁：ReentrantLock</p>\n<p>阻塞对象：Condition available</p>\n<p>入队：不阻塞，无界队列，与优先级队列入队相同，available</p>\n<p>出队：<sunfy-line></p>\n<ul>\n<li>为空时阻塞</li>\n<li>检查堆顶元素过期时间<ul>\n<li>小于等于0则出队</li>\n<li>大于0，说明没过期，则阻塞（判断leader线程是否为空（为了保证优先级））<ul>\n<li>不为空（已有线程阻塞），直接阻塞</li>\n<li>为空，则将当前线程置为leader，并按照过期时间进行阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>应用场景</p>\n<ul>\n<li>商城订单超时关闭-订单业务，下单之后如果三十分钟内没有支付自动取消</li>\n<li>异步短信通知功能-饿了么订单通知，下单成功后60s之后给用户发送短信通知</li>\n<li>关闭空闲连接-服务器中，有很多客户端连接，空闲一段时间之后需要关闭</li>\n<li>缓存过期清除-缓存中的对象，超过了存货时间，需要从缓存中移除</li>\n<li>任务超时处理-在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等</li>\n</ul>\n<p><strong>DelayQueue使用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DelayQueue&lt;OrderInfo&gt; queue = <span class=\"keyword\">new</span> DelayQueue&lt;OrderInfo&gt;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><strong>原理</strong></h2><p><strong>数据结构</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于保证队列操作的线程安全</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// 优先级队列,存储元素，用于保证延迟低的优先执行</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;E&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用于标记当前是否有线程在排队（仅用于取元素时） leader 指向的是第一个从队列获取元素阻塞的线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 条件，用于表示现在是否有可取的元素   当新元素到达，或新线程可能需要成为leader时被通知</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayQueue</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayQueue</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>入队put方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    offer(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 入队</span></span><br><span class=\"line\">        q.offer(e);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.peek() == e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若入队的元素位于队列头部，说明当前元素延迟最小</span></span><br><span class=\"line\">            <span class=\"comment\">// 将 leader 置空</span></span><br><span class=\"line\">            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock(); <span class=\"comment\">// 解锁，真正唤醒阻塞的线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>出队take方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            E first = q.peek();<span class=\"comment\">// 取出堆顶元素   </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)<span class=\"comment\">// 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span></span><br><span class=\"line\">                available.await();</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);<span class=\"comment\">// 堆顶元素的到期时间             </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)<span class=\"comment\">// 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q.poll();</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 如果delay大于0 ，则下面要阻塞了</span></span><br><span class=\"line\">                <span class=\"comment\">// 将first置为空方便gc</span></span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                <span class=\"comment\">// 如果前面有其它线程在等待，直接进入等待</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果leader为null，把当前线程赋值给它</span></span><br><span class=\"line\">                    Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                    leader = thisThread;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 等待delay时间后自动醒过来</span></span><br><span class=\"line\">                        <span class=\"comment\">// 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期</span></span><br><span class=\"line\">                        <span class=\"comment\">// 这里即使醒过来后也不一定能获取到元素</span></span><br><span class=\"line\">                        <span class=\"comment\">// 因为有可能其它线程先一步获取了锁并弹出了堆顶元素</span></span><br><span class=\"line\">                        <span class=\"comment\">// 条件锁的唤醒分成两步，先从Condition的队列里出队</span></span><br><span class=\"line\">                        <span class=\"comment\">// 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒</span></span><br><span class=\"line\">                        available.awaitNanos(delay);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; q.peek() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// available条件队列转同步队列,准备唤醒阻塞在available上的线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        <span class=\"comment\">// 解锁，真正唤醒阻塞的线程</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","next":{"title":"SynchronousQueue介绍","path":"api/articles/resource-java-concurrent-BQ-03-SynchronousQueue.json","image":"/img/header_img/concurrent/SynchronousQueue.png","num_read":821,"num_like":496,"num_collection":160,"num_comments":124},"prev":{"title":"PriorityBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-05-PriorityBlockingQueue.json","image":"/img/header_img/concurrent/PriorityBlockingQueue.png","num_read":920,"num_like":81,"num_collection":123,"num_comments":62},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}