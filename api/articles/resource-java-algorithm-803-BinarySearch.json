{"title":"算法常用的解题思路---二分查找（Binary search）","num_read":887,"num_like":119,"num_collection":545,"num_comments":271,"slug":"resource-java-algorithm-803-BinarySearch","date":"2021-07-20T16:00:00.000Z","img":"/img/header_img/interview/BinarySearch.gif","_id":"clhrbp2dh0085o5lgefbe8bhr","project":"algorithm","site":{"data":{}},"updated":"2022-10-28T08:30:06.735Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-algorithm-803-BinarySearch.json","webPath":"2021/07/21/resource-java-algorithm-803-BinarySearch/","permalink":"https://sunfy9.gitee.io/2021/07/21/resource-java-algorithm-803-BinarySearch/","excerpt":null,"covers":["../../../../img/803-BinarySearch/image-20210722171024295.png","../../../../img/803-BinarySearch/image-20210722171047184.png","../../../../img/803-BinarySearch/image-20210722171101779.png","../../../../img/803-BinarySearch/image-20210721173000574.png","../../../../img/803-BinarySearch/image-20210721175714863.png","../../../../img/803-BinarySearch/image-20210721180003894.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p>滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。</p>\n<hr>\n<h1 id=\"使用二分查找的必要条件\"><a href=\"#使用二分查找的必要条件\" class=\"headerlink\" title=\"使用二分查找的必要条件\"></a><strong>使用二分查找的必要条件</strong></h1><p>1.必须采用 <a href=\"https://baike.baidu.com/item/顺序存储结构\" target=\"_blank\" rel=\"noopener\">顺序存储结构</a></p>\n<p>2.必须按关键字大小有序排列</p>\n<h1 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a><a href=\"https://leetcode-cn.com/problems/binary-search/\" target=\"_blank\" rel=\"noopener\">704. 二分查找</a></h1><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code>和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的<code>target</code>，如果目标值存在返回下标，否则返回<code>-1</code>。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找是一种基于比较目标值和数组中间元素的教科书式算法。</p>\n<p>如果目标值等于中间元素，则找到目标值。<br>如果目标值较小，继续在左侧搜索。<br>如果目标值较大，则继续在右侧搜索。</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171024295.png\" alt=\"image-20210722171024295\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化指针 left = 0, right = n - 1。</span><br><span class=\"line\">当 left &lt;= right：</span><br><span class=\"line\">比较中间元素 nums[pivot] 和目标值 target 。</span><br><span class=\"line\">如果 target = nums[pivot]，返回 pivot。</span><br><span class=\"line\">如果 target &lt; nums[pivot]，则在左侧继续搜索 right = pivot - 1。</span><br><span class=\"line\">如果 target &gt; nums[pivot]，则在右侧继续搜索 left = pivot + 1。</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171047184.png\" alt=\"image-20210722171047184\"></p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171101779.png\" alt=\"image-20210722171101779\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码<sunfy-line></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义二分查找变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> center, left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历查找数据，找到则返回</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            center = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[center]  == target) <span class=\"keyword\">return</span> center;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &lt; nums[center]) right = center - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> left = center + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没有找到数据则返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(logN)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278. 第一个错误的版本\"></a><a href=\"https://leetcode-cn.com/problems/first-bad-version/\" target=\"_blank\" rel=\"noopener\">278. 第一个错误的版本</a></h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：n = 5, bad = 4</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">调用 isBadVersion(3) -&gt; false </span><br><span class=\"line\">调用 isBadVersion(5) -&gt; true </span><br><span class=\"line\">调用 isBadVersion(4) -&gt; true</span><br><span class=\"line\">所以，4 是第一个错误的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：n = 1, bad = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路及算法\"><a href=\"#思路及算法\" class=\"headerlink\" title=\"思路及算法\"></a>思路及算法</h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p>\n<p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p>\n<p>具体地，将左右边界分别初始化为 <code>1</code> 和 <code>n</code>，其中 <code>n</code> 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p>\n<p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 <code>O(logn)</code> 次。</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class=\"line\"><span class=\"comment\">      boolean isBadVersion(int version); */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> <span class=\"keyword\">extends</span> <span class=\"title\">VersionControl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义二分查找变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> center, left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            center = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断center版本是否合格</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isBadVersion(center)) &#123;</span><br><span class=\"line\">                right = center;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = center + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(log)</code>，其中 <code>n</code> 是给定版本的数量。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h1 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35. 搜索插入位置\"></a><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. 搜索插入位置</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 5</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 2</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 7</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\"></span><br><span class=\"line\">示例 4:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 0</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">示例 5:</span><br><span class=\"line\">输入: nums = [1], target = 0</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路与算法\"><a href=\"#思路与算法\" class=\"headerlink\" title=\"思路与算法\"></a>思路与算法</h2><p>假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在<code>O(logn)</code>的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。</p>\n<p>考虑这个插入的位置 <code>pos</code>，它成立的条件为：</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210721173000574.png\" alt=\"image-20210721173000574\"></p>\n<p>其中 <code>nums</code> 代表排序数组。由于如果存在这个目标值，我们返回的索引也是<code>pos</code>，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于target 的下标」。</p>\n<p>问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是target 大于数组中的所有数，此时需要插入到数组长度的位置。</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> center = nums.length, left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = ((right - left) &gt;&gt; <span class=\"number\">1</span>) + left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                center = mid;</span><br><span class=\"line\">                right = center - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(logn)</code>，其中 <code>n</code> 为数组的长度。二分查找所需的时间复杂度为 <code>O(logn)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</li>\n</ul>\n<h1 id=\"特别说明\"><a href=\"#特别说明\" class=\"headerlink\" title=\"特别说明\"></a>特别说明</h1><p>可能出现的死循环问题，二分查找中用＞＞1代替/2居然死循环了</p>\n<h2 id=\"运算符的优先级\"><a href=\"#运算符的优先级\" class=\"headerlink\" title=\"运算符的优先级\"></a>运算符的优先级</h2><p><img src=\"../../../../img/803-BinarySearch/image-20210721175714863.png\" alt=\"image-20210721175714863\"></p>\n<p>加减运算符的优先级大于位运算优先级，所有在使用位运算符时一定要添加括号；</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210721180003894.png\" alt=\"image-20210721180003894\"></p>\n<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(NlogN)：维护一个有序的DP数组，二分查找\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLengthOfShortestSubarray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n]; <span class=\"comment\">//dp[i] 长度为i的非递减子序列的最后一个值</span></span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : arr) &#123;</span><br><span class=\"line\">            dp[find(dp, i)] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"keyword\">if</span>(dp[i] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr.length - i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 递归二分查找</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; arr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &gt; arr[arr.length-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = l + ((r-l)&gt;&gt;<span class=\"number\">1</span>); <span class=\"comment\">//移位要加括号，优先级低</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[mid] &gt; target) &#123;</span><br><span class=\"line\">                r = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","more":"<p>滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。</p>\n<hr>\n<h1 id=\"使用二分查找的必要条件\"><a href=\"#使用二分查找的必要条件\" class=\"headerlink\" title=\"使用二分查找的必要条件\"></a><strong>使用二分查找的必要条件</strong></h1><p>1.必须采用 <a href=\"https://baike.baidu.com/item/顺序存储结构\" target=\"_blank\" rel=\"noopener\">顺序存储结构</a></p>\n<p>2.必须按关键字大小有序排列</p>\n<h1 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a><a href=\"https://leetcode-cn.com/problems/binary-search/\" target=\"_blank\" rel=\"noopener\">704. 二分查找</a></h1><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code>和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的<code>target</code>，如果目标值存在返回下标，否则返回<code>-1</code>。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二分查找是一种基于比较目标值和数组中间元素的教科书式算法。</p>\n<p>如果目标值等于中间元素，则找到目标值。<br>如果目标值较小，继续在左侧搜索。<br>如果目标值较大，则继续在右侧搜索。</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171024295.png\" alt=\"image-20210722171024295\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始化指针 left = 0, right = n - 1。</span><br><span class=\"line\">当 left &lt;= right：</span><br><span class=\"line\">比较中间元素 nums[pivot] 和目标值 target 。</span><br><span class=\"line\">如果 target = nums[pivot]，返回 pivot。</span><br><span class=\"line\">如果 target &lt; nums[pivot]，则在左侧继续搜索 right = pivot - 1。</span><br><span class=\"line\">如果 target &gt; nums[pivot]，则在右侧继续搜索 left = pivot + 1。</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171047184.png\" alt=\"image-20210722171047184\"></p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210722171101779.png\" alt=\"image-20210722171101779\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码<sunfy-line></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义二分查找变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> center, left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历查找数据，找到则返回</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            center = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[center]  == target) <span class=\"keyword\">return</span> center;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &lt; nums[center]) right = center - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> left = center + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 没有找到数据则返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(logN)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"278-第一个错误的版本\"><a href=\"#278-第一个错误的版本\" class=\"headerlink\" title=\"278. 第一个错误的版本\"></a><a href=\"https://leetcode-cn.com/problems/first-bad-version/\" target=\"_blank\" rel=\"noopener\">278. 第一个错误的版本</a></h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：n = 5, bad = 4</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">调用 isBadVersion(3) -&gt; false </span><br><span class=\"line\">调用 isBadVersion(5) -&gt; true </span><br><span class=\"line\">调用 isBadVersion(4) -&gt; true</span><br><span class=\"line\">所以，4 是第一个错误的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：n = 1, bad = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路及算法\"><a href=\"#思路及算法\" class=\"headerlink\" title=\"思路及算法\"></a>思路及算法</h2><p>因为题目要求尽量减少调用检查接口的次数，所以不能对每个版本都调用检查接口，而是应该将调用检查接口的次数降到最低。</p>\n<p>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本；当一个版本为错误版本，则该版本之后的所有版本均为错误版本。我们可以利用这个性质进行二分查找。</p>\n<p>具体地，将左右边界分别初始化为 <code>1</code> 和 <code>n</code>，其中 <code>n</code> 是给定的版本数量。设定左右边界之后，每次我们都依据左右边界找到其中间的版本，检查其是否为正确版本。如果该版本为正确版本，那么第一个错误的版本必然位于该版本的右侧，我们缩紧左边界；否则第一个错误的版本必然位于该版本及该版本的左侧，我们缩紧右边界。</p>\n<p>这样我们每判断一次都可以缩紧一次边界，而每次缩紧时两边界距离将变为原来的一半，因此我们至多只需要缩紧 <code>O(logn)</code> 次。</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class=\"line\"><span class=\"comment\">      boolean isBadVersion(int version); */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> <span class=\"keyword\">extends</span> <span class=\"title\">VersionControl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">firstBadVersion</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义二分查找变量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> center, left = <span class=\"number\">1</span>, right = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            center = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 判断center版本是否合格</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isBadVersion(center)) &#123;</span><br><span class=\"line\">                right = center;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = center + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(log)</code>，其中 <code>n</code> 是给定版本的数量。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只需要常数的空间保存若干变量。</li>\n</ul>\n<h1 id=\"35-搜索插入位置\"><a href=\"#35-搜索插入位置\" class=\"headerlink\" title=\"35. 搜索插入位置\"></a><a href=\"https://leetcode-cn.com/problems/search-insert-position/\" target=\"_blank\" rel=\"noopener\">35. 搜索插入位置</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 5</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 2</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 7</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\"></span><br><span class=\"line\">示例 4:</span><br><span class=\"line\">输入: nums = [1,3,5,6], target = 0</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\"></span><br><span class=\"line\">示例 5:</span><br><span class=\"line\">输入: nums = [1], target = 0</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路与算法\"><a href=\"#思路与算法\" class=\"headerlink\" title=\"思路与算法\"></a>思路与算法</h2><p>假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在<code>O(logn)</code>的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。</p>\n<p>考虑这个插入的位置 <code>pos</code>，它成立的条件为：</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210721173000574.png\" alt=\"image-20210721173000574\"></p>\n<p>其中 <code>nums</code> 代表排序数组。由于如果存在这个目标值，我们返回的索引也是<code>pos</code>，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于target 的下标」。</p>\n<p>问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是target 大于数组中的所有数，此时需要插入到数组长度的位置。</p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> center = nums.length, left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = ((right - left) &gt;&gt; <span class=\"number\">1</span>) + left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                center = mid;</span><br><span class=\"line\">                right = center - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> center;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><ul>\n<li>时间复杂度：<code>O(logn)</code>，其中 <code>n</code> 为数组的长度。二分查找所需的时间复杂度为 <code>O(logn)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</li>\n</ul>\n<h1 id=\"特别说明\"><a href=\"#特别说明\" class=\"headerlink\" title=\"特别说明\"></a>特别说明</h1><p>可能出现的死循环问题，二分查找中用＞＞1代替/2居然死循环了</p>\n<h2 id=\"运算符的优先级\"><a href=\"#运算符的优先级\" class=\"headerlink\" title=\"运算符的优先级\"></a>运算符的优先级</h2><p><img src=\"../../../../img/803-BinarySearch/image-20210721175714863.png\" alt=\"image-20210721175714863\"></p>\n<p>加减运算符的优先级大于位运算优先级，所有在使用位运算符时一定要添加括号；</p>\n<p><img src=\"../../../../img/803-BinarySearch/image-20210721180003894.png\" alt=\"image-20210721180003894\"></p>\n<h2 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(NlogN)：维护一个有序的DP数组，二分查找\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLengthOfShortestSubarray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n]; <span class=\"comment\">//dp[i] 长度为i的非递减子序列的最后一个值</span></span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : arr) &#123;</span><br><span class=\"line\">            dp[find(dp, i)] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"keyword\">if</span>(dp[i] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr.length - i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 递归二分查找</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; arr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &gt; arr[arr.length-<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = arr.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = l + ((r-l)&gt;&gt;<span class=\"number\">1</span>); <span class=\"comment\">//移位要加括号，优先级低</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[mid] &gt; target) &#123;</span><br><span class=\"line\">                r = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","next":{"title":"面试题-如何回答好Linux常用命令","path":"api/articles/resource-system-Linux-005LinuxCommand.json","image":"/img/header_img/11.jpg","num_read":497,"num_like":671,"num_collection":745,"num_comments":178},"prev":{"title":"算法常用的解题思路---双指针（Double Pointer）","path":"api/articles/resource-java-algorithm-804-DoublePointer.json","image":"/img/header_img/interview/DoublePointer.gif","num_read":1435,"num_like":452,"num_collection":427,"num_comments":139},"categories":[{"name":"算法","path":"api/categories/算法.json","pathContent":"api/categories/算法","description":"为了更有效的处理数据，提高数据运算效率。","cover":"https://sunfy9.gitee.io/project/photo/project/algorithm.png"}],"tags":[]}