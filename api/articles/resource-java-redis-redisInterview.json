{"title":"Redis常见的面试题","num_read":1130,"num_like":61,"num_collection":90,"num_comments":263,"slug":"resource-java-redis-redisInterview","date":"2022-01-01T16:00:00.000Z","img":"/img/header_img/java/redisInterview.png","_id":"clhrbp2de007io5lgecichfwf","type":"like","subtitle":"常见的Redis面试题集锦","site":{"data":{}},"updated":"2022-10-28T13:32:30.116Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-redis-redisInterview.json","webPath":"2022/01/02/resource-java-redis-redisInterview/","permalink":"https://sunfy9.gitee.io/2022/01/02/resource-java-redis-redisInterview/","excerpt":null,"covers":["../../../../img/redisInterview/image-20220113112746971-6963925.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>Redis的数据结构及使⽤场景</p>\n<p>Redis的过期键的删除策略</p>\n<p>Redis线程模型、单线程快的原因</p>\n<p>简述Redis事务实现</p>\n<p>redis集群方案/Redis集群策略</p>\n<p>redis主从复制的核心原理</p>\n<p>缓存雪崩、缓存穿透、缓存击穿<sunfy-line></p>\n<h1 id=\"Redis的数据结构及使⽤场景\"><a href=\"#Redis的数据结构及使⽤场景\" class=\"headerlink\" title=\"Redis的数据结构及使⽤场景\"></a>Redis的数据结构及使⽤场景</h1><p>Redis的数据结构有：</p>\n<p>1、字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</p>\n<p>2、哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</p>\n<p>3、列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信公众号、微博等消息流数据</p>\n<p>4、集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</p>\n<p>5、有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</p>\n<h1 id=\"Redis的过期键的删除策略\"><a href=\"#Redis的过期键的删除策略\" class=\"headerlink\" title=\"Redis的过期键的删除策略\"></a>Redis的过期键的删除策略</h1><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>\n<ul>\n<li><p>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>\n</li>\n<li><p>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>\n</li>\n</ul>\n<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>\n<font color=red>Redis中同时使用了惰性过期和定期过期两种过期策略。</font>\n\n<h1 id=\"Redis线程模型、单线程快的原因\"><a href=\"#Redis线程模型、单线程快的原因\" class=\"headerlink\" title=\"Redis线程模型、单线程快的原因\"></a>Redis线程模型、单线程快的原因</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器file event handler。这个文件事件处理器，它是单线程的，所以Redis才叫做单线程的模型，</p>\n<p>它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。</p>\n<p>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。</p>\n<p>多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</p>\n<p>单线程快的原因：</p>\n<ul>\n<li>纯内存操作</li>\n<li>核心是基于非阻塞的IO多路复用机制</li>\n<li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li>\n</ul>\n<h1 id=\"简述Redis事务实现\"><a href=\"#简述Redis事务实现\" class=\"headerlink\" title=\"简述Redis事务实现\"></a>简述Redis事务实现</h1><p>1、事务开始</p>\n<p>MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的flags属性中打开REDIS_MULTI标识来完成的。</p>\n<p>2、命令入队</p>\n<p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p>\n<ul>\n<li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li>\n<li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的flags属性关闭REDIS_MULTI标识，并且返回错误信息给客户端。</li>\n</ul>\n<p>如果正确，将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p>\n<p>事务队列是按照FIFO的方式保存入队的命令</p>\n<p>3、事务执行</p>\n<p>客户端发送EXEC命令，服务器执行EXEC命令逻辑。</p>\n<ul>\n<li>如果客户端状态的flags属性不包含REDIS_MULTI标识，或者包含REDIS_DIRTY_CAS或者REDIS_DIRTY_EXEC标识，那么就直接取消事务的执行。</li>\n<li>否则客户端处于事务状态（flags有REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</li>\n</ul>\n<font color=red>redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。 </font>\n\n<p>Redis事务不支持检查那些程序员自己逻辑错误。例如对String类型的数据库键执行对HashMap类型的操作！</p>\n<ul>\n<li>WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set（CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>\n<li>MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>\n<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil。</li>\n<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li>\n<li>UNWATCH命令可以取消watch对所有key的监控。</li>\n</ul>\n<h1 id=\"redis集群方案-Redis集群策略\"><a href=\"#redis集群方案-Redis集群策略\" class=\"headerlink\" title=\"redis集群方案/Redis集群策略\"></a>redis集群方案/Redis集群策略</h1><p>Redis提供了三种集群策略：</p>\n<p><strong>主从模式</strong>：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</p>\n<p>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。</p>\n<p><strong>哨兵模式</strong>：sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：</p>\n<ul>\n<li><p>集群监控：负责监控redis master 和slave进程是否正常工作。</p>\n</li>\n<li><p>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p>\n</li>\n<li><p>故障转移：如果master node 挂掉了，会自动转移到 slave node上。</p>\n</li>\n<li><p>配置中心：如果故障转移发生了，通知client客户端新的master地址。</p>\n</li>\n</ul>\n<p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>\n<ul>\n<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li>\n<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li>\n<li>哨兵通常需要3个实例，来保证自己的健壮性。</li>\n<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性。</li>\n<li>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>\n</ul>\n<p><strong>Cluster模式</strong>：Cluster模式是⽤得⽐较多的模式，它支持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。</p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位</li>\n<li>每份数据分片会存储在多个互为主从的多节点上</li>\n<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>\n<li>同一分片多个节点间的数据不保持强一致性</li>\n<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>\n<li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无中心架构，支持动态扩容，对业务透明</li>\n<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>\n<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>\n<li>高性能，客户端直接连接redis服务</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>运维也很复杂，数据迁移需要人工干预</li>\n<li>只能使用0号数据库</li>\n<li>不支持批量操作(pipeline管道操作)</li>\n<li>分布式逻辑和存储模块耦合等</li>\n</ul>\n<p>对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且需要持续的扩容，那么选择Cluster模式。</p>\n<h1 id=\"redis主从复制的核心原理\"><a href=\"#redis主从复制的核心原理\" class=\"headerlink\" title=\"redis主从复制的核心原理\"></a>redis主从复制的核心原理</h1><p>通过执行slaveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p>\n<h2 id=\"全量复制：\"><a href=\"#全量复制：\" class=\"headerlink\" title=\"全量复制：\"></a>全量复制：</h2><ul>\n<li>主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li>\n<li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li>\n<li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</li>\n</ul>\n<h2 id=\"部分复制：\"><a href=\"#部分复制：\" class=\"headerlink\" title=\"部分复制：\"></a>部分复制：</h2><ul>\n<li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量offset</li>\n<li>复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li>\n<li>服务器运行ID(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：<ul>\n<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>\n<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"过程原理：\"><a href=\"#过程原理：\" class=\"headerlink\" title=\"过程原理：\"></a>过程原理：</h2><p><img src=\"../../../../img/redisInterview/image-20220113112746971-6963925.png\" alt=\"image-20220113112746971\"></p>\n<h1 id=\"缓存雪崩、缓存穿透、缓存击穿\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿\"></a>缓存雪崩、缓存穿透、缓存击穿</h1><h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>\n<li>缓存预热</li>\n<li>互斥锁</li>\n</ul>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>\n<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>设置热点数据永远不过期</li>\n<li>加互斥锁</li>\n</ul>\n","more":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>Redis的数据结构及使⽤场景</p>\n<p>Redis的过期键的删除策略</p>\n<p>Redis线程模型、单线程快的原因</p>\n<p>简述Redis事务实现</p>\n<p>redis集群方案/Redis集群策略</p>\n<p>redis主从复制的核心原理</p>\n<p>缓存雪崩、缓存穿透、缓存击穿<sunfy-line></p>\n<h1 id=\"Redis的数据结构及使⽤场景\"><a href=\"#Redis的数据结构及使⽤场景\" class=\"headerlink\" title=\"Redis的数据结构及使⽤场景\"></a>Redis的数据结构及使⽤场景</h1><p>Redis的数据结构有：</p>\n<p>1、字符串：可以⽤来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</p>\n<p>2、哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</p>\n<p>3、列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信公众号、微博等消息流数据</p>\n<p>4、集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</p>\n<p>5、有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</p>\n<h1 id=\"Redis的过期键的删除策略\"><a href=\"#Redis的过期键的删除策略\" class=\"headerlink\" title=\"Redis的过期键的删除策略\"></a>Redis的过期键的删除策略</h1><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>\n<ul>\n<li><p>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>\n</li>\n<li><p>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>\n</li>\n</ul>\n<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>\n<font color=red>Redis中同时使用了惰性过期和定期过期两种过期策略。</font>\n\n<h1 id=\"Redis线程模型、单线程快的原因\"><a href=\"#Redis线程模型、单线程快的原因\" class=\"headerlink\" title=\"Redis线程模型、单线程快的原因\"></a>Redis线程模型、单线程快的原因</h1><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器file event handler。这个文件事件处理器，它是单线程的，所以Redis才叫做单线程的模型，</p>\n<p>它采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。</p>\n<p>文件事件处理器的结构包含4个部分：多个Socket、IO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。</p>\n<p>多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</p>\n<p>单线程快的原因：</p>\n<ul>\n<li>纯内存操作</li>\n<li>核心是基于非阻塞的IO多路复用机制</li>\n<li>单线程反而避免了多线程的频繁上下文切换带来的性能问题</li>\n</ul>\n<h1 id=\"简述Redis事务实现\"><a href=\"#简述Redis事务实现\" class=\"headerlink\" title=\"简述Redis事务实现\"></a>简述Redis事务实现</h1><p>1、事务开始</p>\n<p>MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的flags属性中打开REDIS_MULTI标识来完成的。</p>\n<p>2、命令入队</p>\n<p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p>\n<ul>\n<li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li>\n<li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的flags属性关闭REDIS_MULTI标识，并且返回错误信息给客户端。</li>\n</ul>\n<p>如果正确，将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p>\n<p>事务队列是按照FIFO的方式保存入队的命令</p>\n<p>3、事务执行</p>\n<p>客户端发送EXEC命令，服务器执行EXEC命令逻辑。</p>\n<ul>\n<li>如果客户端状态的flags属性不包含REDIS_MULTI标识，或者包含REDIS_DIRTY_CAS或者REDIS_DIRTY_EXEC标识，那么就直接取消事务的执行。</li>\n<li>否则客户端处于事务状态（flags有REDIS_MULTI标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</li>\n</ul>\n<font color=red>redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。 </font>\n\n<p>Redis事务不支持检查那些程序员自己逻辑错误。例如对String类型的数据库键执行对HashMap类型的操作！</p>\n<ul>\n<li>WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set（CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>\n<li>MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>\n<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil。</li>\n<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li>\n<li>UNWATCH命令可以取消watch对所有key的监控。</li>\n</ul>\n<h1 id=\"redis集群方案-Redis集群策略\"><a href=\"#redis集群方案-Redis集群策略\" class=\"headerlink\" title=\"redis集群方案/Redis集群策略\"></a>redis集群方案/Redis集群策略</h1><p>Redis提供了三种集群策略：</p>\n<p><strong>主从模式</strong>：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</p>\n<p>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。</p>\n<p><strong>哨兵模式</strong>：sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：</p>\n<ul>\n<li><p>集群监控：负责监控redis master 和slave进程是否正常工作。</p>\n</li>\n<li><p>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p>\n</li>\n<li><p>故障转移：如果master node 挂掉了，会自动转移到 slave node上。</p>\n</li>\n<li><p>配置中心：如果故障转移发生了，通知client客户端新的master地址。</p>\n</li>\n</ul>\n<p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>\n<ul>\n<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li>\n<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li>\n<li>哨兵通常需要3个实例，来保证自己的健壮性。</li>\n<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性。</li>\n<li>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>\n</ul>\n<p><strong>Cluster模式</strong>：Cluster模式是⽤得⽐较多的模式，它支持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。</p>\n<p><strong>方案说明</strong></p>\n<ul>\n<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位</li>\n<li>每份数据分片会存储在多个互为主从的多节点上</li>\n<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>\n<li>同一分片多个节点间的数据不保持强一致性</li>\n<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>\n<li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>无中心架构，支持动态扩容，对业务透明</li>\n<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>\n<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>\n<li>高性能，客户端直接连接redis服务</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>运维也很复杂，数据迁移需要人工干预</li>\n<li>只能使用0号数据库</li>\n<li>不支持批量操作(pipeline管道操作)</li>\n<li>分布式逻辑和存储模块耦合等</li>\n</ul>\n<p>对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且需要持续的扩容，那么选择Cluster模式。</p>\n<h1 id=\"redis主从复制的核心原理\"><a href=\"#redis主从复制的核心原理\" class=\"headerlink\" title=\"redis主从复制的核心原理\"></a>redis主从复制的核心原理</h1><p>通过执行slaveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p>\n<h2 id=\"全量复制：\"><a href=\"#全量复制：\" class=\"headerlink\" title=\"全量复制：\"></a>全量复制：</h2><ul>\n<li>主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li>\n<li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li>\n<li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</li>\n</ul>\n<h2 id=\"部分复制：\"><a href=\"#部分复制：\" class=\"headerlink\" title=\"部分复制：\"></a>部分复制：</h2><ul>\n<li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量offset</li>\n<li>复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li>\n<li>服务器运行ID(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：<ul>\n<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>\n<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"过程原理：\"><a href=\"#过程原理：\" class=\"headerlink\" title=\"过程原理：\"></a>过程原理：</h2><p><img src=\"../../../../img/redisInterview/image-20220113112746971-6963925.png\" alt=\"image-20220113112746971\"></p>\n<h1 id=\"缓存雪崩、缓存穿透、缓存击穿\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿\"></a>缓存雪崩、缓存穿透、缓存击穿</h1><h2 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h2><p>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>\n<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>\n<li>缓存预热</li>\n<li>互斥锁</li>\n</ul>\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><p>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>\n<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>\n<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力</li>\n</ul>\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><p>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>\n<p><strong>解决方案：</strong></p>\n<ul>\n<li>设置热点数据永远不过期</li>\n<li>加互斥锁</li>\n</ul>\n","next":{"title":"sentinel简介","path":"api/articles/resource-MicroService-sentinel-sentinel.json","image":"/img/header_img/MicroService/sentinel.png","num_read":1187,"num_like":656,"num_collection":180,"num_comments":81},"prev":{"title":"Zookeeper常见的面试题","path":"api/articles/resource-java-Zookeeper-zkInterview.json","image":"/img/header_img/zookeeper.png","num_read":1289,"num_like":1006,"num_collection":728,"num_comments":67},"categories":[{"name":"分布式中间件","path":"api/categories/分布式中间件.json","pathContent":"api/categories/分布式中间件","description":"包含Zookeeper、Redis、等相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}],"tags":[{"name":"Redis","path":"api/tags/Redis.json","pathContent":"api/tags/Redis","description":"[Redis]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"},{"name":"Interview","path":"api/tags/Interview.json","pathContent":"api/tags/Interview","description":"面试题相关内容","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}