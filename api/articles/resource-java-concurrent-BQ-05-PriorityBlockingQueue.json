{"title":"PriorityBlockingQueue介绍","num_read":1539,"num_like":631,"num_collection":310,"num_comments":270,"slug":"resource-java-concurrent-BQ-05-PriorityBlockingQueue","date":"2021-12-16T16:00:00.000Z","img":"/img/header_img/concurrent/PriorityBlockingQueue.png","minNumber":600,"format":"standard","_id":"clhrbp2dn009to5lg9k6p57ea","project":"concurrent","subtitle":"PriorityBlockingQueue是一个无界的基于数组的优先级阻塞队列","site":{"data":{}},"updated":"2022-09-19T14:48:55.933Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-05-PriorityBlockingQueue.json","webPath":"2021/12/17/resource-java-concurrent-BQ-05-PriorityBlockingQueue/","permalink":"https://sunfy9.gitee.io/2021/12/17/resource-java-concurrent-BQ-05-PriorityBlockingQueue/","excerpt":null,"covers":["../../../../img/BQ-05-PriorityBlockingQueue/31536.png","../../../../img/BQ-05-PriorityBlockingQueue/31542.png","../../../../img/BQ-05-PriorityBlockingQueue/31551.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a><strong>PriorityBlockingQueue</strong></h1><p>PriorityBlockingQueue是一个无界的基于数组的优先级阻塞队列，数组的默认长度是11，虽然指定了数组的长度，但是可以无限的扩充，直到资源消耗尽为止，每次出队都返回优先级别最高的或者最低的元素。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。</p>\n<p>优先级队列PriorityQueue： 队列中每个元素都有一个优先级，出队的时候，优先级最高的先出。</p>\n<p><strong>一个支持优先级排序的无界阻塞队列</strong>：优先级高的先出队，优先级低的后出队</p>\n<p>数据结构：数组+二叉堆：默认容量11，可指定初级容量，会自动扩容，最大容量是（Integer.MAX_VALUE - 8）</p>\n<p>锁：ReentrantLock：存取是同一把锁</p>\n<p>阻塞对象：NotEmpty：出队，队列为空时阻塞</p>\n<p>入队：<sunfy-line></p>\n<ul>\n<li>不阻塞，永远返回成功，无界</li>\n<li>根据比较器进行堆化（排序）自上而下<ul>\n<li>传入比较器对象就按照比较器的顺序排序</li>\n<li>传入比较器对象就按照比较器的顺序排序</li>\n</ul>\n</li>\n</ul>\n<p>出队：</p>\n<ul>\n<li>优先级最高的元素在堆顶（弹出堆顶元素）</li>\n<li>弹出前比较两个子节点再进行堆化（自上而下）</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>业务办理排队叫号，VIP客户插队</li>\n<li>电商抢购活动，会员级别高的用户优先抢购到商品</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建优先级阻塞队列  Comparator为null,自然排序</span></span><br><span class=\"line\">PriorityBlockingQueue&lt;Integer&gt; queue=<span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Integer&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//自定义Comparator</span></span><br><span class=\"line\">PriorityBlockingQueue queue=<span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Integer&gt;(</span><br><span class=\"line\">        <span class=\"number\">5</span>, <span class=\"keyword\">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o2-o1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"如何实现一个优先级队列？\"><a href=\"#如何实现一个优先级队列？\" class=\"headerlink\" title=\"如何实现一个优先级队列？\"></a>如何实现一个优先级队列？</h1><p><strong>如何构造优先级队列</strong></p>\n<p><strong>使用普通线性数组(无序)来表示优先级队列</strong></p>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31536.png\" alt=\"img\"></p>\n<ul>\n<li>执行插入操作时，直接将元素插入到数组末端，需要的成本为O(1),</li>\n<li>获取优先级最高元素，我们需要遍历整个线性队列，匹配出优先级最高元素，需要的成本为o(n)</li>\n<li>删除优先级最高元素，我们需要两个步骤，第一找出优先级最高元素，第二步删除优先级最高元素，然后将后面的元素依次迁移，填补空缺，需要的成本为O(n)+O(n)=O(n)</li>\n</ul>\n<p><strong>使用一个按顺序排列的有序向量实现优先级队列</strong></p>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31542.png\" alt=\"img\"></p>\n<ul>\n<li>获取优先级最高元素，O(1)</li>\n<li>删除优先级最高元素，O(1)</li>\n<li>插入一个元素，需要两个步骤，第一步我们需要找出要插的位置，这里我们可以使用二分查找，成本为O(logn)，第二步是插入元素之后，将其所有后继进行后移操作，成本为O(n)，所有总成本为O(logn)+O(n)=O(n)</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a><strong>二叉堆</strong></h2><p>完全二叉树：除了最后一行，其他行都满的二叉树，而且最后一行所有叶子节点都从左向右开始排序。</p>\n<p>二叉堆：完全二叉树的基础上，加以一定的条件约束的一种特殊的二叉树。根据约束条件的不同，二叉堆又可以分为两个类型：</p>\n<p>大顶堆和小顶堆。</p>\n<ul>\n<li>大顶堆（最大堆）：父结点的键值总是大于或等于任何一个子节点的键值；</li>\n<li>小顶堆（最小堆）：父结点的键值总是小于或等于任何一个子节点的键值。</li>\n</ul>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31551.png\" alt=\"img\"></p>\n","more":"<h1 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a><strong>PriorityBlockingQueue</strong></h1><p>PriorityBlockingQueue是一个无界的基于数组的优先级阻塞队列，数组的默认长度是11，虽然指定了数组的长度，但是可以无限的扩充，直到资源消耗尽为止，每次出队都返回优先级别最高的或者最低的元素。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。</p>\n<p>优先级队列PriorityQueue： 队列中每个元素都有一个优先级，出队的时候，优先级最高的先出。</p>\n<p><strong>一个支持优先级排序的无界阻塞队列</strong>：优先级高的先出队，优先级低的后出队</p>\n<p>数据结构：数组+二叉堆：默认容量11，可指定初级容量，会自动扩容，最大容量是（Integer.MAX_VALUE - 8）</p>\n<p>锁：ReentrantLock：存取是同一把锁</p>\n<p>阻塞对象：NotEmpty：出队，队列为空时阻塞</p>\n<p>入队：<sunfy-line></p>\n<ul>\n<li>不阻塞，永远返回成功，无界</li>\n<li>根据比较器进行堆化（排序）自上而下<ul>\n<li>传入比较器对象就按照比较器的顺序排序</li>\n<li>传入比较器对象就按照比较器的顺序排序</li>\n</ul>\n</li>\n</ul>\n<p>出队：</p>\n<ul>\n<li>优先级最高的元素在堆顶（弹出堆顶元素）</li>\n<li>弹出前比较两个子节点再进行堆化（自上而下）</li>\n</ul>\n<p>应用场景：</p>\n<ul>\n<li>业务办理排队叫号，VIP客户插队</li>\n<li>电商抢购活动，会员级别高的用户优先抢购到商品</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建优先级阻塞队列  Comparator为null,自然排序</span></span><br><span class=\"line\">PriorityBlockingQueue&lt;Integer&gt; queue=<span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Integer&gt;(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">//自定义Comparator</span></span><br><span class=\"line\">PriorityBlockingQueue queue=<span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Integer&gt;(</span><br><span class=\"line\">        <span class=\"number\">5</span>, <span class=\"keyword\">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o2-o1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"如何实现一个优先级队列？\"><a href=\"#如何实现一个优先级队列？\" class=\"headerlink\" title=\"如何实现一个优先级队列？\"></a>如何实现一个优先级队列？</h1><p><strong>如何构造优先级队列</strong></p>\n<p><strong>使用普通线性数组(无序)来表示优先级队列</strong></p>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31536.png\" alt=\"img\"></p>\n<ul>\n<li>执行插入操作时，直接将元素插入到数组末端，需要的成本为O(1),</li>\n<li>获取优先级最高元素，我们需要遍历整个线性队列，匹配出优先级最高元素，需要的成本为o(n)</li>\n<li>删除优先级最高元素，我们需要两个步骤，第一找出优先级最高元素，第二步删除优先级最高元素，然后将后面的元素依次迁移，填补空缺，需要的成本为O(n)+O(n)=O(n)</li>\n</ul>\n<p><strong>使用一个按顺序排列的有序向量实现优先级队列</strong></p>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31542.png\" alt=\"img\"></p>\n<ul>\n<li>获取优先级最高元素，O(1)</li>\n<li>删除优先级最高元素，O(1)</li>\n<li>插入一个元素，需要两个步骤，第一步我们需要找出要插的位置，这里我们可以使用二分查找，成本为O(logn)，第二步是插入元素之后，将其所有后继进行后移操作，成本为O(n)，所有总成本为O(logn)+O(n)=O(n)</li>\n</ul>\n<h2 id=\"二叉堆\"><a href=\"#二叉堆\" class=\"headerlink\" title=\"二叉堆\"></a><strong>二叉堆</strong></h2><p>完全二叉树：除了最后一行，其他行都满的二叉树，而且最后一行所有叶子节点都从左向右开始排序。</p>\n<p>二叉堆：完全二叉树的基础上，加以一定的条件约束的一种特殊的二叉树。根据约束条件的不同，二叉堆又可以分为两个类型：</p>\n<p>大顶堆和小顶堆。</p>\n<ul>\n<li>大顶堆（最大堆）：父结点的键值总是大于或等于任何一个子节点的键值；</li>\n<li>小顶堆（最小堆）：父结点的键值总是小于或等于任何一个子节点的键值。</li>\n</ul>\n<p><img src=\"../../../../img/BQ-05-PriorityBlockingQueue/31551.png\" alt=\"img\"></p>\n","next":{"title":"DelayQueue介绍","path":"api/articles/resource-java-concurrent-BQ-04-DelayQueue.json","image":"/img/header_img/concurrent/DelayQueue.png","num_read":1017,"num_like":1054,"num_collection":794,"num_comments":112},"prev":{"title":"如何选择适合的阻塞队列","path":"api/articles/resource-java-concurrent-BlockingQueueSelect.json","image":"/img/header_img/concurrent/SelectBlockingQueue.png","num_read":1837,"num_like":340,"num_collection":790,"num_comments":127},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}