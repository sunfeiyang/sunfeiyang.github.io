{"title":"数据结构测试题---树","num_read":235,"num_like":331,"num_collection":598,"num_comments":253,"slug":"resource-dataStructure-leetcode-leetcode-tree","date":"2021-09-02T16:00:00.000Z","img":"/img/header_img/dataStructure/tree.jpg","format":"gallery","_id":"clhrbp2am0005o5lgc8ju9zkl","project":"dataStructure","site":{"data":{}},"updated":"2022-09-20T01:15:40.125Z","comments":true,"path":"api/articles/resource-dataStructure-leetcode-leetcode-tree.json","webPath":"2021/09/03/resource-dataStructure-leetcode-leetcode-tree/","permalink":"https://sunfy9.gitee.io/2021/09/03/resource-dataStructure-leetcode-leetcode-tree/","excerpt":null,"covers":["../../../../img/leetcode-tree/inorder_1.jpg","../../../../img/leetcode-tree/inorder_5.jpg","../../../../img/leetcode-tree/inorder_4.jpg","../../../../img/leetcode-tree/image-20210831132255926.png","../../../../img/leetcode-tree/list1-16303876262124.gif","../../../../img/leetcode-tree/image-20220920090659174.png","../../../../img/leetcode-tree/image-20220920090734940.png","../../../../img/leetcode-tree/image-20220920090756214.png","../../../../img/leetcode-tree/image-20210831133930797.png","../../../../img/leetcode-tree/list2.gif","../../../../img/leetcode-tree/image-20210831134345973.png","../../../../img/leetcode-tree/list3.gif","../../../../img/leetcode-tree/image-20210831134816501.png","../../../../img/leetcode-tree/list4.gif","../../../../img/leetcode-tree/list4-16305072446221.gif","../../../../img/leetcode-tree/101_fig1.PNG","../../../../img/leetcode-tree/101_fig2.PNG","../../../../img/leetcode-tree/pathsum1.jpg","../../../../img/leetcode-tree/pathsum2.jpg","../../../../img/leetcode-tree/list.gif","../../../../img/leetcode-tree/bst.png","../../../../img/leetcode-tree/recursion-16305614381523.png","../../../../img/leetcode-tree/image-20210902134449527.png","../../../../img/leetcode-tree/iteration.png","../../../../img/leetcode-tree/image-20210902134605594.png","../../../../img/leetcode-tree/insertbst.jpg","../../../../img/leetcode-tree/bst.jpg","../../../../img/leetcode-tree/image-20210902134857500.png","../../../../img/leetcode-tree/image-20210902135151261.png","../../../../img/leetcode-tree/list-16305619911838.gif","../../../../img/leetcode-tree/image-20210902135354367.png","../../../../img/leetcode-tree/image-20210902135414334.png","../../../../img/leetcode-tree/image-20220920091455015.png","../../../../img/leetcode-tree/sum_tree_1.jpg","../../../../img/leetcode-tree/sum_tree_2.jpg","../../../../img/leetcode-tree/binarysearchtree_improved.png","../../../../img/leetcode-tree/image-20210902140548484.png","../../../../img/leetcode-tree/image-20210902140618113.png","../../../../img/leetcode-tree/list1-163056291675612.gif"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：root = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_5.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_4.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归\"><a href=\"#方法一：递归\" class=\"headerlink\" title=\"方法一：递归\"></a><sunfy-line>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831132255926.png\" alt=\"image-20210831132255926\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        preorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        preorder(root.left, res);</span><br><span class=\"line\">        preorder(root.right, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法二：迭代\"><a href=\"#方法二：迭代\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list1-16303876262124.gif\" alt=\"list1\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                res.add(node.val);</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            node = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法三：Morris-遍历\"><a href=\"#方法三：Morris-遍历\" class=\"headerlink\" title=\"方法三：Morris 遍历\"></a>方法三：Morris 遍历</h2><p>思路与算法</p>\n<p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p>\n<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p>\n<ol>\n<li>新建临时节点，令该节点为 root；</li>\n<li>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</li>\n<li><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：</p>\n<ol>\n<li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li>\n<li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li>\n</ol>\n</li>\n<li><p>重复步骤 2 和步骤 3，直到遍历结束。</p>\n</li>\n</ol>\n<p>这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode p1 = root, p2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            p2 = p1.left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p2.right != <span class=\"keyword\">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class=\"line\">                    p2 = p2.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p2.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    res.add(p1.val);</span><br><span class=\"line\">                    p2.right = p1;</span><br><span class=\"line\">                    p1 = p1.left;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p2.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.add(p1.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p1 = p1.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li>\n<li>空间复杂度：<code>O(1)</code>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li>\n</ul>\n<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090659174.png\" alt=\"image-20220920090659174\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,3,2]</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：root = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090734940.png\" alt=\"image-20220920090734940\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090756214.png\" alt=\"image-20220920090756214\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归-1\"><a href=\"#方法一：递归-1\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831133930797.png\" alt=\"image-20210831133930797\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        inorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, res);</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        inorder(root.right, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>\n<li>空间复杂度：<code>O(n)</code>。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 <code>O(n)</code> 的级别。</li>\n</ul>\n<h2 id=\"方法二：迭代-1\"><a href=\"#方法二：迭代-1\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list2.gif\" alt=\"list2\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stk = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stk.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stk.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.pop();</span><br><span class=\"line\">            res.add(root.val);</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code>为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>\n<li>空间复杂度：<code>O(n)</code>。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 <code>O(n)</code> 的级别。</li>\n</ul>\n<h2 id=\"方法三：Morris-中序遍历\"><a href=\"#方法三：Morris-中序遍历\" class=\"headerlink\" title=\"方法三：Morris 中序遍历\"></a>方法三：Morris 中序遍历</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831134345973.png\" alt=\"image-20210831134345973\"></p>\n<p><img src=\"../../../../img/leetcode-tree/list3.gif\" alt=\"list3\"></p>\n<p>其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        TreeNode predecessor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class=\"line\">                predecessor = root.left;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (predecessor.right != <span class=\"keyword\">null</span> &amp;&amp; predecessor.right != root) &#123;</span><br><span class=\"line\">                    predecessor = predecessor.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (predecessor.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    predecessor.right = root;</span><br><span class=\"line\">                    root = root.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.add(root.val);</span><br><span class=\"line\">                    predecessor.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    root = root.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 <code>O(2n)=O(n)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145. 二叉树的后序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">145. 二叉树的后序遍历</a></h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例</span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [3,2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归-2\"><a href=\"#方法一：递归-2\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831134816501.png\" alt=\"image-20210831134816501\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        postorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        postorder(root.left, res);</span><br><span class=\"line\">        postorder(root.right, res);</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法二：迭代-2\"><a href=\"#方法二：迭代-2\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list4.gif\" alt=\"list4\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"keyword\">null</span> || root.right == prev) &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法三：Morris-遍历-1\"><a href=\"#方法三：Morris-遍历-1\" class=\"headerlink\" title=\"方法三：Morris 遍历\"></a>方法三：Morris 遍历</h2><p>思路与算法</p>\n<p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p>\n<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：</p>\n<ol>\n<li>新建临时节点，令该节点为 root；</li>\n<li>如果当前节点的左子节点为空，则遍历当前节点的右子节点；</li>\n<li><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；</p>\n<ol>\n<li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。</li>\n<li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。</li>\n</ol>\n</li>\n<li><p>重复步骤 2 和步骤 3，直到遍历结束。</p>\n</li>\n</ol>\n<p>这样我们利用 Morris 遍历的方法，后序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode p1 = root, p2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            p2 = p1.left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p2.right != <span class=\"keyword\">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class=\"line\">                    p2 = p2.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p2.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p2.right = p1;</span><br><span class=\"line\">                    p1 = p1.left;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p2.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    addPath(res, p1.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p1 = p1.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addPath(res, root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addPath</span><span class=\"params\">(List&lt;Integer&gt; res, TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            res.add(node.val);</span><br><span class=\"line\">            node = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = res.size() - count, right = res.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = res.get(left);</span><br><span class=\"line\">            res.set(left, res.get(right));</span><br><span class=\"line\">            res.set(right, temp);</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li>\n<li>空间复杂度：<code>O(1)</code>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li>\n</ul>\n<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">102. 二叉树的层序遍历</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n<p>返回其层序遍历结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[</span></span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  <span class=\"section\">[15,7]</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：广度优先搜索\"><a href=\"#方法一：广度优先搜索\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路和算法</p>\n<p>我们可以用广度优先搜索解决这个问题。</p>\n<p>我们可以想到最朴素的方法是用一个二元组 (node, level) 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 level 值都是父亲节点的 level 值加一。最后根据每个点的 level 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 level 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 level 从小到大取出所有值，组成答案返回即可。</p>\n<p>考虑如何优化空间开销：如何不用哈希映射，并且只用一个变量 node 表示状态，实现这个功能呢？</p>\n<p>我们可以用一种巧妙的方法修改广度优先搜索：</p>\n<ul>\n<li>首先根元素入队</li>\n<li>当队列不为空的时候<ul>\n<li>求当前队列的长度 s_i</li>\n<li>依次从队列中取 s_i个元素进行拓展，然后进入下一次迭代</li>\n</ul>\n</li>\n</ul>\n<p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 s_i个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 s_i个元素。</p>\n<p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 i 次迭代前，队列中的所有元素就是第 i 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p>\n<ul>\n<li><strong>初始化</strong>：i=1 的时候，队列里面只有 root，是唯一的层数为 1 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；</li>\n<li><strong>保持</strong>：如果 i=k 时性质成立，即第 k 轮中出队 s<em>k的元素是第 k 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 k 层的点拓展出的点一定也只能是 k+1 层的点，并且 k+1 层的点只能由第 k 层的点拓展到，所以由这 s_k个点能拓展到下一层所有的 s</em>{k+1} 个点。又因为队列的先进先出（FIFO）特性，既然第 k 层的点的出队顺序是从左向右，那么第 k+1 层也一定是从左向右。<strong>至此，我们已经可以通过数学归纳法证明循环不变式的正确性。</strong></li>\n<li><strong>终止</strong>：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。<strong>至此，我们证明了算法是正确的。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; level = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentLevelSize = queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                level.add(node.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.add(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<p>记树上所有节点的个数为 n。</p>\n<ul>\n<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h1 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">104. 二叉树的最大深度</a></h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n<p>返回它的最大深度 3 。</p>\n<h2 id=\"方法一：深度优先搜索\"><a href=\"#方法一：深度优先搜索\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p><strong>思路与算法</strong></p>\n<p>如果我们知道了左子树和右子树的最大深度 <em>l</em> 和 <em>r</em>，那么该二叉树的最大深度即为 max(<em>l</em>,<em>r</em>)+1</p>\n<p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>\n<p><img src=\"../../../../img/leetcode-tree/list4-16305072446221.gif\" alt=\"list4\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> leftHeight = maxDepth(root.left);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rightHeight = maxDepth(root.right);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(leftHeight, rightHeight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉树节点的个数。每个节点在递归中只被遍历一次。</li>\n<li>空间复杂度：<code>O(height)</code>，其中 <code>height</code> 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li>\n</ul>\n<h2 id=\"方法二：广度优先搜索\"><a href=\"#方法二：广度优先搜索\" class=\"headerlink\" title=\"方法二：广度优先搜索\"></a>方法二：广度优先搜索</h2><p>思路与算法</p>\n<p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 <code>ans</code> 来维护拓展的次数，该二叉树的最大深度即为 <code>ans</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>\n<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>\n</ul>\n<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">101. 对称二叉树</a></h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\">3  4 4  3</span><br></pre></td></tr></table></figure>\n<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">2   2</span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> 3    3</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：递归-3\"><a href=\"#方法一：递归-3\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><strong>思路和算法</strong></p>\n<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>\n<p><img src=\"../../../../img/leetcode-tree/101_fig1.PNG\" alt=\"fig1\" style=\"zoom:50%;\" /></p>\n<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>\n<p>如果同时满足下面的条件，两个树互为镜像：</p>\n<ul>\n<li>它们的两个根结点具有相同的值</li>\n<li>每个树的右子树都与另一个树的左子树镜像对称</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/101_fig2.PNG\" alt=\"fig2\" style=\"zoom:50%;\" /></p>\n<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，pp 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<p>假设树上一共 n 个节点。</p>\n<ul>\n<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h2 id=\"方法二：迭代-3\"><a href=\"#方法二：迭代-3\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路和算法</p>\n<p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        q.offer(u);</span><br><span class=\"line\">        q.offer(v);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            u = q.poll();</span><br><span class=\"line\">            v = q.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (u == <span class=\"keyword\">null</span> &amp;&amp; v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((u == <span class=\"keyword\">null</span> || v == <span class=\"keyword\">null</span>) || (u.val != v.val)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.left);</span><br><span class=\"line\">            q.offer(v.right);</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.right);</span><br><span class=\"line\">            q.offer(v.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，同「方法一」。</li>\n<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h1 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\" target=\"_blank\" rel=\"noopener\">226. 翻转二叉树</a></h1><p>翻转一棵二叉树。</p>\n<p><strong>示例：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  2     7</span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\">1   3 6   9</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   &#x2F;   \\</span><br><span class=\"line\">  7     2</span><br><span class=\"line\"> &#x2F; \\   &#x2F; \\</span><br><span class=\"line\">9   6 3   1</span><br></pre></td></tr></table></figure>\n<p><strong>备注:</strong><br>这个问题是受到 <a href=\"https://twitter.com/mxcl\" target=\"_blank\" rel=\"noopener\">Max Howell </a>的 <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\" rel=\"noopener\">原问题</a> 启发的 ：</p>\n<h2 id=\"方法一：递归-4\"><a href=\"#方法一：递归-4\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p>思路与算法</p>\n<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 <code>root</code> 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 <code>root</code> 为根节点的整棵子树的翻转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode left = invertTree(root.left);</span><br><span class=\"line\">        TreeNode right = invertTree(root.right);</span><br><span class=\"line\">        root.left = right;</span><br><span class=\"line\">        root.right = left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</li>\n<li>空间复杂度：<code>O(N)</code>。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 <code>O(logN)</code>。而在最坏情况下，树形成链状，空间复杂度为 <code>O(N)</code>。</li>\n</ul>\n<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">112. 路径总和</a></h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/pathsum1.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/pathsum2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>树中节点的数目在范围 [0, 5000] 内</li>\n<li>-1000 &lt;= <code>Node.val</code> &lt;= 1000</li>\n<li>-1000 &lt;= <code>targetSum</code> &lt;= 1000</li>\n</ul>\n<p>注意到本题的要求是，询问是否有从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<blockquote>\n<p>需要特别注意的是，给定的 root 可能为空。</p>\n</blockquote>\n<h2 id=\"方法一：广度优先搜索-1\"><a href=\"#方法一：广度优先搜索-1\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路及算法</p>\n<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p>\n<p><img src=\"../../../../img/leetcode-tree/list.gif\" alt=\"list\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queNode = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queVal = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        queNode.offer(root);</span><br><span class=\"line\">        queVal.offer(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queNode.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode now = queNode.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = queVal.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left == <span class=\"keyword\">null</span> &amp;&amp; now.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == sum) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.left);</span><br><span class=\"line\">                queVal.offer(now.left.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.right);</span><br><span class=\"line\">                queVal.offer(now.right.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>\n</ul>\n<h2 id=\"方法二：递归\"><a href=\"#方法二：递归\" class=\"headerlink\" title=\"方法二：递归\"></a>方法二：递归</h2><p>思路及算法</p>\n<p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p>\n<p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>\n<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum == root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<code>O(H)</code>，其中 <code>H</code> 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 <code>O(N)</code>。平均情况下树的高度与节点数的对数正相关，空间复杂度为 <code>O(logN)</code>。</li>\n</ul>\n<h1 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700. 二叉搜索树中的搜索\"></a><a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">700. 二叉搜索树中的搜索</a></h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>\n<p>例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉搜索树:</span><br><span class=\"line\"></span><br><span class=\"line\">        4</span><br><span class=\"line\">       &#x2F; \\</span><br><span class=\"line\">      2   7</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    1   3</span><br><span class=\"line\"></span><br><span class=\"line\">和值: 2</span><br></pre></td></tr></table></figure>\n<p>你应该返回如下子树:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  2     </span><br><span class=\"line\"> &#x2F; \\   </span><br><span class=\"line\">1   3</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>\n<h2 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h2><p>二叉搜索树是一棵二叉树，每个节点都有以下特性：</p>\n<ul>\n<li>大于左子树上任意一个节点的值，</li>\n<li>小于右子树上任意一个节点的值。</li>\n</ul>\n<p>一个二叉搜索树的例子：</p>\n<p><img src=\"../../../../img/leetcode-tree/bst.png\" alt=\"img\" style=\"zoom: 33%;\" /></p>\n<p>二叉搜索树中复杂度为对数时间的操作：</p>\n<ul>\n<li>查找。</li>\n<li><a href=\"https://leetcode.com/articles/insert-into-a-bst/\" target=\"_blank\" rel=\"noopener\">插入</a>。</li>\n<li><a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\" target=\"_blank\" rel=\"noopener\">删除</a>。</li>\n</ul>\n<h2 id=\"方法一：递归-5\"><a href=\"#方法一：递归-5\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><strong>算法</strong></p>\n<p>递归实现非常简单：</p>\n<ul>\n<li>如果根节点为空 root == null 或者根节点的值等于搜索值 val == root.val，返回根节点。</li>\n<li>如果 val &lt; root.val，进入根节点的左子树查找 searchBST(root.left, val)。</li>\n<li>如果 val &gt; root.val，进入根节点的右子树查找 searchBST(root.right, val)。</li>\n<li>返回根节点。</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/recursion-16305614381523.png\" alt=\"img\" style=\"zoom:33%;\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || val == root.val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> val &lt; root.val ? searchBST(root.left, val) : searchBST(root.right, val);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134449527.png\" alt=\"image-20210902134449527\"></p>\n<h2 id=\"方法二：迭代-4\"><a href=\"#方法二：迭代-4\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>为了降低空间复杂度，将递归转换为迭代：</p>\n<ul>\n<li><p>如果根节点不空 root != null 且根节点不是目的节点 val != root.val：</p>\n<ul>\n<li>如果 val &lt; root.val，进入根节点的左子树查找 root = root.left。</li>\n<li>如果 val &gt; root.val，进入根节点的右子树查找 root = root.right。</li>\n</ul>\n</li>\n<li><p>返回 root。</p>\n</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/iteration.png\" alt=\"img\" style=\"zoom: 33%;\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> &amp;&amp; val != root.val)</span><br><span class=\"line\">      root = val &lt; root.val ? root.left : root.right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134605594.png\" alt=\"image-20210902134605594\"></p>\n<h1 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">701. 二叉搜索树中的插入操作</a></h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/insertbst.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class=\"line\">输出：[4,2,7,1,3,5]</span><br><span class=\"line\">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/bst.jpg\" alt=\"img\"></p>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class=\"line\">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class=\"line\">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>给定的树上的节点数介于 0 和 10^4 之间</li>\n<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>\n<li>-10^8 &lt;= val &lt;= 10^8</li>\n<li>新值和原始二叉搜索树中的任意节点值都不同</li>\n</ul>\n<h2 id=\"方法一：模拟\"><a href=\"#方法一：模拟\" class=\"headerlink\" title=\"方法一：模拟\"></a>方法一：模拟</h2><p><strong>思路与算法</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134857500.png\" alt=\"image-20210902134857500\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode pos = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pos != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &lt; pos.val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pos.left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pos.left = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = pos.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pos.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pos.right = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = pos.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 <code>O(N)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只使用了常数大小的空间。</li>\n</ul>\n<h1 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. 验证二叉搜索树</a></h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<ul>\n<li>节点的左子树只包含小于当前节点的数。</li>\n<li>节点的右子树只包含大于当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    2</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   4</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    3   6</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class=\"line\">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一-递归\"><a href=\"#方法一-递归\" class=\"headerlink\" title=\"方法一: 递归\"></a>方法一: 递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210902135151261.png\" alt=\"image-20210902135151261\"></p>\n<p><img src=\"../../../../img/leetcode-tree/list-16305619911838.gif\" alt=\"list\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode node, <span class=\"keyword\">long</span> lower, <span class=\"keyword\">long</span> upper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902135354367.png\" alt=\"image-20210902135354367\"></p>\n<h2 id=\"方法二：中序遍历\"><a href=\"#方法二：中序遍历\" class=\"headerlink\" title=\"方法二：中序遍历\"></a>方法二：中序遍历</h2><p><img src=\"../../../../img/leetcode-tree/image-20210902135414334.png\" alt=\"image-20210902135414334\"></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920091455015.png\" alt=\"image-20220920091455015\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> inorder = -Double.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">              <span class=\"comment\">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.val &lt;= inorder) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inorder = root.val;</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度 : <code>O(n)</code>，其中 <code>n</code> 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 <code>O(n)</code>。</li>\n<li>空间复杂度 : <code>O(n)</code>，其中 <code>n</code> 为二叉树的节点个数。栈最多存储 <code>n</code> 个节点，因此需要额外的 <code>O(n)</code> 的空间。</li>\n</ul>\n<h1 id=\"653-两数之和-IV-输入-BST\"><a href=\"#653-两数之和-IV-输入-BST\" class=\"headerlink\" title=\"653. 两数之和 IV - 输入 BST\"></a><a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\" target=\"_blank\" rel=\"noopener\">653. 两数之和 IV - 输入 BST</a></h1><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/sum_tree_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/sum_tree_2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 28</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 4</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 1</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>二叉树的节点个数的范围是  [1, 104].</li>\n<li>-104 &lt;= Node.val &lt;= 104</li>\n<li>root 为二叉搜索树</li>\n<li>-105 &lt;= k &lt;= 105</li>\n</ul>\n<h2 id=\"方法一：使用-HashSet【通过】\"><a href=\"#方法一：使用-HashSet【通过】\" class=\"headerlink\" title=\"方法一：使用 HashSet【通过】\"></a>方法一：使用 HashSet【通过】</h2><p>最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 k 的一对节点。现在在此基础上做一些改进。</p>\n<p>如果存在两个元素之和为 k，即 x+y=k，并且已知 xx 是树上一个节点的值，则只需判断树上是否存在一个值为 y 的节点，使得 y=k-x。基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 set 中。</p>\n<p>对于每个值为 p 的节点，在 set 中检查是否存在 k−p。如果存在，那么可以在该树上找到两个节点的和为 k；否则，将 p 放入到 set 中。</p>\n<p>如果遍历完整棵树都没有找到一对节点和为 k，那么该树上不存在两个和为 k 的节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Set &lt; Integer &gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(root, k, set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k, Set &lt; Integer &gt; set)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (set.contains(k - root.val))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        set.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(root.left, k, set) || find(root.right, k, set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>N</code> 是节点的数量。最坏的情况下，整棵树被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>。最坏的情况下，set 存储 n 个节点的值。</li>\n</ul>\n<h2 id=\"方法二：使用-BFS-和-HashSet【通过】\"><a href=\"#方法二：使用-BFS-和-HashSet【通过】\" class=\"headerlink\" title=\"方法二：使用 BFS 和 HashSet【通过】\"></a>方法二：使用 BFS 和 HashSet【通过】</h2><p>算法</p>\n<p>本方法中，set 的用途与 方法一 相同。但是本方法使用广度优先搜索遍历二叉树，这是一种非常常见的遍历方法。</p>\n<p>使用广度优先搜索查找一对节点和为 k 的过程如下。首先维护一个与 方法一 用途相同的 set。将根节点加入 queue，然后执行以下步骤：</p>\n<ol>\n<li>从队列首部删除一个元素 p。</li>\n<li>检查 set 中是否存在 k−p。如果存在，返回 True。</li>\n<li>否则，将 p 加入 set。然后将当前节点的左孩子和右孩子加入 queue。</li>\n<li>重复步骤一至三，直到 queue 为空。</li>\n<li>如果 queue 为空，返回 False。</li>\n</ol>\n<p>按照以上步骤，逐层遍历二叉树。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Set &lt; Integer &gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        Queue &lt; TreeNode &gt; queue = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue.peek() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                TreeNode node = queue.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(k - node.val))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                set.add(node.val);</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                queue.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 n 是树中节点的数量。最坏的情况下，需要遍历整棵树。</li>\n<li>空间复杂度：<code>O(n)</code>。最坏的情况下，set 存储 n 个节点的值。</li>\n</ul>\n<h2 id=\"方法三：使用-BST【通过】\"><a href=\"#方法三：使用-BST【通过】\" class=\"headerlink\" title=\"方法三：使用 BST【通过】\"></a>方法三：使用 BST【通过】</h2><p>算法</p>\n<p>在本方法中利用 BST 的性质，BST 的中序遍历结果是按升序排列的。因此，中序遍历给定的 BST，并将遍历结果存储到 list 中。</p>\n<p>遍历完成后，使用两个指针 l 和 r 作为 list 的头部索引和尾部索引。然后执行以下操作：</p>\n<p>检查 l 和 r 索引处两元素之和是否等于 k。如果是，立即返回 True。</p>\n<p>如果当前两元素之和小于 k，则更新 l 指向下一个元素。这是因为当我们需要增大两数之和时，应该增大较小数。</p>\n<p>如果当前两元素之和大于 k，则更新 r 指向上一个元素。这是因为当我们需要减小两数之和时，应该减小较大数。</p>\n<p>重复步骤一至三，直到左指针 l 大于右指针 r。</p>\n<p>如果左指针 l 到右指针 r 的右边，则返回 False。</p>\n<p>注意，在任何情况下，都不应该增大较大的数，也不应该减小较小的数。这是因为如果当前两数之和大于 k，不应该首先增大 list[r] 的值。类似的，也不应该首先减小 list[l] 的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        List &lt; Integer &gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        inorder(root, list);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = list.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = list.get(l) + list.get(r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; k)</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List &lt; Integer &gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inorder(root.left, list);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        inorder(root.right, list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 n 是树中节点的数量。本方法需要中序遍历整棵树。</li>\n<li>空间复杂度：<code>O(n)</code>，list 中存储 n 个元素。</li>\n</ul>\n<h1 id=\"235-二叉搜索树的最近公共祖先\"><a href=\"#235-二叉搜索树的最近公共祖先\" class=\"headerlink\" title=\"235. 二叉搜索树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">235. 二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>\n<p><img src=\"../../../../img/leetcode-tree/binarysearchtree_improved.png\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong></p>\n<ul>\n<li>所有节点的值都是唯一的。</li>\n<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n<h2 id=\"方法一：两次遍历\"><a href=\"#方法一：两次遍历\" class=\"headerlink\" title=\"方法一：两次遍历\"></a>方法一：两次遍历</h2><p>思路与算法</p>\n<p>注意到题目中给出的是一棵「二叉搜索树」，因此我们可以快速地找出树中的某个节点以及从根节点到该节点的路径，例如我们需要找到节点 p：</p>\n<p>我们从根节点开始遍历；</p>\n<p>如果当前节点就是 p，那么成功地找到了节点；</p>\n<p>如果当前节点的值大于 p 的值，说明 p 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；</p>\n<p>如果当前节点的值小于 p 的值，说明 p 应该在当前节点的右子树，因此将当前节点移动到它的右子节点。</p>\n<p>对于节点 q 同理。在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。</p>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902140548484.png\" alt=\"image-20210902140548484\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;TreeNode&gt; path_p = getPath(root, p);</span><br><span class=\"line\">        List&lt;TreeNode&gt; path_q = getPath(root, q);</span><br><span class=\"line\">        TreeNode ancestor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path_p.get(i) == path_q.get(i)) &#123;</span><br><span class=\"line\">                ancestor = path_p.get(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ancestor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;TreeNode&gt; <span class=\"title\">getPath</span><span class=\"params\">(TreeNode root, TreeNode target)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;TreeNode&gt; path = <span class=\"keyword\">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != target) &#123;</span><br><span class=\"line\">            path.add(node);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target.val &lt; node.val) &#123;</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path.add(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902140618113.png\" alt=\"image-20210902140618113\"></p>\n<h2 id=\"方法二：一次遍历\"><a href=\"#方法二：一次遍历\" class=\"headerlink\" title=\"方法二：一次遍历\"></a>方法二：一次遍历</h2><p>思路与算法</p>\n<p>在方法一中，我们对从根节点开始，通过遍历找出到达节点 p 和 q 的路径，一共需要两次遍历。我们也可以考虑将这两个节点放在一起遍历。</p>\n<p>整体的遍历过程与方法一中的类似：</p>\n<ul>\n<li>我们从根节点开始遍历；</li>\n<li>如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；</li>\n<li>如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此将当前节点移动到它的右子节点；</li>\n<li>如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，p 和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。</li>\n</ul>\n<p>可以发现，如果我们将这两个节点放在一起遍历，我们就省去了存储路径需要的空间。</p>\n<p><img src=\"../../../../img/leetcode-tree/list1-163056291675612.gif\" alt=\"list1\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        TreeNode ancestor = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class=\"line\">                ancestor = ancestor.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class=\"line\">                ancestor = ancestor.right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ancestor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是给定的二叉搜索树中的节点个数。分析思路与方法一相同。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","more":"<h1 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\" target=\"_blank\" rel=\"noopener\">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：root = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_5.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/inorder_4.jpg\" alt=\"img\"></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归\"><a href=\"#方法一：递归\" class=\"headerlink\" title=\"方法一：递归\"></a><sunfy-line>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831132255926.png\" alt=\"image-20210831132255926\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        preorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        preorder(root.left, res);</span><br><span class=\"line\">        preorder(root.right, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法二：迭代\"><a href=\"#方法二：迭代\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list1-16303876262124.gif\" alt=\"list1\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                res.add(node.val);</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            node = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法三：Morris-遍历\"><a href=\"#方法三：Morris-遍历\" class=\"headerlink\" title=\"方法三：Morris 遍历\"></a>方法三：Morris 遍历</h2><p>思路与算法</p>\n<p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p>\n<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p>\n<ol>\n<li>新建临时节点，令该节点为 root；</li>\n<li>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</li>\n<li><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：</p>\n<ol>\n<li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li>\n<li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li>\n</ol>\n</li>\n<li><p>重复步骤 2 和步骤 3，直到遍历结束。</p>\n</li>\n</ol>\n<p>这样我们利用 Morris 遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode p1 = root, p2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            p2 = p1.left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p2.right != <span class=\"keyword\">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class=\"line\">                    p2 = p2.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p2.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    res.add(p1.val);</span><br><span class=\"line\">                    p2.right = p1;</span><br><span class=\"line\">                    p1 = p1.left;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p2.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.add(p1.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p1 = p1.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li>\n<li>空间复杂度：<code>O(1)</code>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li>\n</ul>\n<h1 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\" target=\"_blank\" rel=\"noopener\">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090659174.png\" alt=\"image-20220920090659174\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,3,2]</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\">输入：root = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090734940.png\" alt=\"image-20220920090734940\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920090756214.png\" alt=\"image-20220920090756214\" style=\"zoom:50%;\" /></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归-1\"><a href=\"#方法一：递归-1\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831133930797.png\" alt=\"image-20210831133930797\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        inorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inorder(root.left, res);</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">        inorder(root.right, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>\n<li>空间复杂度：<code>O(n)</code>。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 <code>O(n)</code> 的级别。</li>\n</ul>\n<h2 id=\"方法二：迭代-1\"><a href=\"#方法二：迭代-1\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list2.gif\" alt=\"list2\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stk = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stk.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stk.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.pop();</span><br><span class=\"line\">            res.add(root.val);</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code>为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</li>\n<li>空间复杂度：<code>O(n)</code>。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 <code>O(n)</code> 的级别。</li>\n</ul>\n<h2 id=\"方法三：Morris-中序遍历\"><a href=\"#方法三：Morris-中序遍历\" class=\"headerlink\" title=\"方法三：Morris 中序遍历\"></a>方法三：Morris 中序遍历</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831134345973.png\" alt=\"image-20210831134345973\"></p>\n<p><img src=\"../../../../img/leetcode-tree/list3.gif\" alt=\"list3\"></p>\n<p>其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        TreeNode predecessor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class=\"line\">                predecessor = root.left;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (predecessor.right != <span class=\"keyword\">null</span> &amp;&amp; predecessor.right != root) &#123;</span><br><span class=\"line\">                    predecessor = predecessor.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (predecessor.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    predecessor.right = root;</span><br><span class=\"line\">                    root = root.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.add(root.val);</span><br><span class=\"line\">                    predecessor.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    root = root.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 <code>O(2n)=O(n)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n<h1 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145. 二叉树的后序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\" target=\"_blank\" rel=\"noopener\">145. 二叉树的后序遍历</a></h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例</span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [3,2,1]</span><br></pre></td></tr></table></figure>\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<h2 id=\"方法一：递归-2\"><a href=\"#方法一：递归-2\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210831134816501.png\" alt=\"image-20210831134816501\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        postorder(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postorder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        postorder(root.left, res);</span><br><span class=\"line\">        postorder(root.right, res);</span><br><span class=\"line\">        res.add(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为递归过程中栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法二：迭代-2\"><a href=\"#方法二：迭代-2\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路与算法</p>\n<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>\n<p><img src=\"../../../../img/leetcode-tree/list4.gif\" alt=\"list4\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"keyword\">null</span> || root.right == prev) &#123;</span><br><span class=\"line\">                res.add(root.val);</span><br><span class=\"line\">                prev = root;</span><br><span class=\"line\">                root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>，为迭代过程中显式栈的开销，平均情况下为 <code>O(logn)</code>，最坏情况下树呈现链状，为 <code>O(n)</code>。</li>\n</ul>\n<h2 id=\"方法三：Morris-遍历-1\"><a href=\"#方法三：Morris-遍历-1\" class=\"headerlink\" title=\"方法三：Morris 遍历\"></a>方法三：Morris 遍历</h2><p>思路与算法</p>\n<p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p>\n<p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：</p>\n<ol>\n<li>新建临时节点，令该节点为 root；</li>\n<li>如果当前节点的左子节点为空，则遍历当前节点的右子节点；</li>\n<li><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；</p>\n<ol>\n<li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。</li>\n<li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。</li>\n</ol>\n</li>\n<li><p>重复步骤 2 和步骤 3，直到遍历结束。</p>\n</li>\n</ol>\n<p>这样我们利用 Morris 遍历的方法，后序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode p1 = root, p2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            p2 = p1.left;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (p2.right != <span class=\"keyword\">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class=\"line\">                    p2 = p2.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p2.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p2.right = p1;</span><br><span class=\"line\">                    p1 = p1.left;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    p2.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    addPath(res, p1.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p1 = p1.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addPath(res, root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addPath</span><span class=\"params\">(List&lt;Integer&gt; res, TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            res.add(node.val);</span><br><span class=\"line\">            node = node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = res.size() - count, right = res.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = res.get(left);</span><br><span class=\"line\">            res.set(left, res.get(right));</span><br><span class=\"line\">            res.set(right, temp);</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li>\n<li>空间复杂度：<code>O(1)</code>。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li>\n</ul>\n<h1 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\" target=\"_blank\" rel=\"noopener\">102. 二叉树的层序遍历</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n<p>返回其层序遍历结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[</span></span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  <span class=\"section\">[15,7]</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：广度优先搜索\"><a href=\"#方法一：广度优先搜索\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路和算法</p>\n<p>我们可以用广度优先搜索解决这个问题。</p>\n<p>我们可以想到最朴素的方法是用一个二元组 (node, level) 来表示状态，它表示某个节点和它所在的层数，每个新进队列的节点的 level 值都是父亲节点的 level 值加一。最后根据每个点的 level 对点进行分类，分类的时候我们可以利用哈希表，维护一个以 level 为键，对应节点值组成的数组为值，广度优先搜索结束以后按键 level 从小到大取出所有值，组成答案返回即可。</p>\n<p>考虑如何优化空间开销：如何不用哈希映射，并且只用一个变量 node 表示状态，实现这个功能呢？</p>\n<p>我们可以用一种巧妙的方法修改广度优先搜索：</p>\n<ul>\n<li>首先根元素入队</li>\n<li>当队列不为空的时候<ul>\n<li>求当前队列的长度 s_i</li>\n<li>依次从队列中取 s_i个元素进行拓展，然后进入下一次迭代</li>\n</ul>\n</li>\n</ul>\n<p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 s_i个元素。在上述过程中的第 i 次迭代就得到了二叉树的第 i 层的 s_i个元素。</p>\n<p>为什么这么做是对的呢？我们观察这个算法，可以归纳出这样的循环不变式：第 i 次迭代前，队列中的所有元素就是第 i 层的所有元素，并且按照从左向右的顺序排列。证明它的三条性质（你也可以把它理解成数学归纳法）：</p>\n<ul>\n<li><strong>初始化</strong>：i=1 的时候，队列里面只有 root，是唯一的层数为 1 的元素，因为只有一个元素，所以也显然满足「从左向右排列」；</li>\n<li><strong>保持</strong>：如果 i=k 时性质成立，即第 k 轮中出队 s<em>k的元素是第 k 层的所有元素，并且顺序从左到右。因为对树进行广度优先搜索的时候由低 k 层的点拓展出的点一定也只能是 k+1 层的点，并且 k+1 层的点只能由第 k 层的点拓展到，所以由这 s_k个点能拓展到下一层所有的 s</em>{k+1} 个点。又因为队列的先进先出（FIFO）特性，既然第 k 层的点的出队顺序是从左向右，那么第 k+1 层也一定是从左向右。<strong>至此，我们已经可以通过数学归纳法证明循环不变式的正确性。</strong></li>\n<li><strong>终止</strong>：因为该循环不变式是正确的，所以按照这个方法迭代之后每次迭代得到的也就是当前层的层次遍历结果。<strong>至此，我们证明了算法是正确的。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; level = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentLevelSize = queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                level.add(node.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.add(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<p>记树上所有节点的个数为 n。</p>\n<ul>\n<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h1 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" target=\"_blank\" rel=\"noopener\">104. 二叉树的最大深度</a></h1><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n<p>返回它的最大深度 3 。</p>\n<h2 id=\"方法一：深度优先搜索\"><a href=\"#方法一：深度优先搜索\" class=\"headerlink\" title=\"方法一：深度优先搜索\"></a>方法一：深度优先搜索</h2><p><strong>思路与算法</strong></p>\n<p>如果我们知道了左子树和右子树的最大深度 <em>l</em> 和 <em>r</em>，那么该二叉树的最大深度即为 max(<em>l</em>,<em>r</em>)+1</p>\n<p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>\n<p><img src=\"../../../../img/leetcode-tree/list4-16305072446221.gif\" alt=\"list4\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> leftHeight = maxDepth(root.left);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> rightHeight = maxDepth(root.right);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(leftHeight, rightHeight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 为二叉树节点的个数。每个节点在递归中只被遍历一次。</li>\n<li>空间复杂度：<code>O(height)</code>，其中 <code>height</code> 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li>\n</ul>\n<h2 id=\"方法二：广度优先搜索\"><a href=\"#方法二：广度优先搜索\" class=\"headerlink\" title=\"方法二：广度优先搜索\"></a>方法二：广度优先搜索</h2><p>思路与算法</p>\n<p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 <code>ans</code> 来维护拓展的次数，该二叉树的最大深度即为 <code>ans</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    queue.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>\n<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</li>\n</ul>\n<h1 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\" target=\"_blank\" rel=\"noopener\">101. 对称二叉树</a></h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\">3  4 4  3</span><br></pre></td></tr></table></figure>\n<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  1</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">2   2</span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> 3    3</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一：递归-3\"><a href=\"#方法一：递归-3\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><strong>思路和算法</strong></p>\n<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>\n<p><img src=\"../../../../img/leetcode-tree/101_fig1.PNG\" alt=\"fig1\" style=\"zoom:50%;\" /></p>\n<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>\n<p>如果同时满足下面的条件，两个树互为镜像：</p>\n<ul>\n<li>它们的两个根结点具有相同的值</li>\n<li>每个树的右子树都与另一个树的左子树镜像对称</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/101_fig2.PNG\" alt=\"fig2\" style=\"zoom:50%;\" /></p>\n<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，pp 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> &amp;&amp; q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<p>假设树上一共 n 个节点。</p>\n<ul>\n<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</li>\n<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h2 id=\"方法二：迭代-3\"><a href=\"#方法二：迭代-3\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>思路和算法</p>\n<p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; q = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        q.offer(u);</span><br><span class=\"line\">        q.offer(v);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.isEmpty()) &#123;</span><br><span class=\"line\">            u = q.poll();</span><br><span class=\"line\">            v = q.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (u == <span class=\"keyword\">null</span> &amp;&amp; v == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((u == <span class=\"keyword\">null</span> || v == <span class=\"keyword\">null</span>) || (u.val != v.val)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.left);</span><br><span class=\"line\">            q.offer(v.right);</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.right);</span><br><span class=\"line\">            q.offer(v.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：O(n)，同「方法一」。</li>\n<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</li>\n</ul>\n<h1 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\" target=\"_blank\" rel=\"noopener\">226. 翻转二叉树</a></h1><p>翻转一棵二叉树。</p>\n<p><strong>示例：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  2     7</span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\">1   3 6   9</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   &#x2F;   \\</span><br><span class=\"line\">  7     2</span><br><span class=\"line\"> &#x2F; \\   &#x2F; \\</span><br><span class=\"line\">9   6 3   1</span><br></pre></td></tr></table></figure>\n<p><strong>备注:</strong><br>这个问题是受到 <a href=\"https://twitter.com/mxcl\" target=\"_blank\" rel=\"noopener\">Max Howell </a>的 <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\" rel=\"noopener\">原问题</a> 启发的 ：</p>\n<h2 id=\"方法一：递归-4\"><a href=\"#方法一：递归-4\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p>思路与算法</p>\n<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 <code>root</code> 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 <code>root</code> 为根节点的整棵子树的翻转。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode left = invertTree(root.left);</span><br><span class=\"line\">        TreeNode right = invertTree(root.right);</span><br><span class=\"line\">        root.left = right;</span><br><span class=\"line\">        root.right = left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</li>\n<li>空间复杂度：<code>O(N)</code>。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 <code>O(logN)</code>。而在最坏情况下，树形成链状，空间复杂度为 <code>O(N)</code>。</li>\n</ul>\n<h1 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a><a href=\"https://leetcode-cn.com/problems/path-sum/\" target=\"_blank\" rel=\"noopener\">112. 路径总和</a></h1><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/pathsum1.jpg\" alt=\"img\" style=\"zoom: 50%;\" /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/pathsum2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>树中节点的数目在范围 [0, 5000] 内</li>\n<li>-1000 &lt;= <code>Node.val</code> &lt;= 1000</li>\n<li>-1000 &lt;= <code>targetSum</code> &lt;= 1000</li>\n</ul>\n<p>注意到本题的要求是，询问是否有从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<blockquote>\n<p>需要特别注意的是，给定的 root 可能为空。</p>\n</blockquote>\n<h2 id=\"方法一：广度优先搜索-1\"><a href=\"#方法一：广度优先搜索-1\" class=\"headerlink\" title=\"方法一：广度优先搜索\"></a>方法一：广度优先搜索</h2><p>思路及算法</p>\n<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p>\n<p><img src=\"../../../../img/leetcode-tree/list.gif\" alt=\"list\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queNode = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queVal = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        queNode.offer(root);</span><br><span class=\"line\">        queVal.offer(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queNode.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode now = queNode.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = queVal.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left == <span class=\"keyword\">null</span> &amp;&amp; now.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == sum) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.left);</span><br><span class=\"line\">                queVal.offer(now.left.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.right);</span><br><span class=\"line\">                queVal.offer(now.right.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>\n</ul>\n<h2 id=\"方法二：递归\"><a href=\"#方法二：递归\" class=\"headerlink\" title=\"方法二：递归\"></a>方法二：递归</h2><p>思路及算法</p>\n<p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。</p>\n<p>假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>\n<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum == root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<code>O(H)</code>，其中 <code>H</code> 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 <code>O(N)</code>。平均情况下树的高度与节点数的对数正相关，空间复杂度为 <code>O(logN)</code>。</li>\n</ul>\n<h1 id=\"700-二叉搜索树中的搜索\"><a href=\"#700-二叉搜索树中的搜索\" class=\"headerlink\" title=\"700. 二叉搜索树中的搜索\"></a><a href=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">700. 二叉搜索树中的搜索</a></h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>\n<p>例如，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉搜索树:</span><br><span class=\"line\"></span><br><span class=\"line\">        4</span><br><span class=\"line\">       &#x2F; \\</span><br><span class=\"line\">      2   7</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    1   3</span><br><span class=\"line\"></span><br><span class=\"line\">和值: 2</span><br></pre></td></tr></table></figure>\n<p>你应该返回如下子树:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  2     </span><br><span class=\"line\"> &#x2F; \\   </span><br><span class=\"line\">1   3</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>\n<h2 id=\"二叉搜索树\"><a href=\"#二叉搜索树\" class=\"headerlink\" title=\"二叉搜索树\"></a>二叉搜索树</h2><p>二叉搜索树是一棵二叉树，每个节点都有以下特性：</p>\n<ul>\n<li>大于左子树上任意一个节点的值，</li>\n<li>小于右子树上任意一个节点的值。</li>\n</ul>\n<p>一个二叉搜索树的例子：</p>\n<p><img src=\"../../../../img/leetcode-tree/bst.png\" alt=\"img\" style=\"zoom: 33%;\" /></p>\n<p>二叉搜索树中复杂度为对数时间的操作：</p>\n<ul>\n<li>查找。</li>\n<li><a href=\"https://leetcode.com/articles/insert-into-a-bst/\" target=\"_blank\" rel=\"noopener\">插入</a>。</li>\n<li><a href=\"https://leetcode.com/articles/delete-node-in-a-bst/\" target=\"_blank\" rel=\"noopener\">删除</a>。</li>\n</ul>\n<h2 id=\"方法一：递归-5\"><a href=\"#方法一：递归-5\" class=\"headerlink\" title=\"方法一：递归\"></a>方法一：递归</h2><p><strong>算法</strong></p>\n<p>递归实现非常简单：</p>\n<ul>\n<li>如果根节点为空 root == null 或者根节点的值等于搜索值 val == root.val，返回根节点。</li>\n<li>如果 val &lt; root.val，进入根节点的左子树查找 searchBST(root.left, val)。</li>\n<li>如果 val &gt; root.val，进入根节点的右子树查找 searchBST(root.right, val)。</li>\n<li>返回根节点。</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/recursion-16305614381523.png\" alt=\"img\" style=\"zoom:33%;\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || val == root.val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> val &lt; root.val ? searchBST(root.left, val) : searchBST(root.right, val);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134449527.png\" alt=\"image-20210902134449527\"></p>\n<h2 id=\"方法二：迭代-4\"><a href=\"#方法二：迭代-4\" class=\"headerlink\" title=\"方法二：迭代\"></a>方法二：迭代</h2><p>为了降低空间复杂度，将递归转换为迭代：</p>\n<ul>\n<li><p>如果根节点不空 root != null 且根节点不是目的节点 val != root.val：</p>\n<ul>\n<li>如果 val &lt; root.val，进入根节点的左子树查找 root = root.left。</li>\n<li>如果 val &gt; root.val，进入根节点的右子树查找 root = root.right。</li>\n</ul>\n</li>\n<li><p>返回 root。</p>\n</li>\n</ul>\n<p><img src=\"../../../../img/leetcode-tree/iteration.png\" alt=\"img\" style=\"zoom: 33%;\" /></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> &amp;&amp; val != root.val)</span><br><span class=\"line\">      root = val &lt; root.val ? root.left : root.right;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134605594.png\" alt=\"image-20210902134605594\"></p>\n<h1 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">701. 二叉搜索树中的插入操作</a></h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/insertbst.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class=\"line\">输出：[4,2,7,1,3,5]</span><br><span class=\"line\">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/bst.jpg\" alt=\"img\"></p>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class=\"line\">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class=\"line\">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>给定的树上的节点数介于 0 和 10^4 之间</li>\n<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>\n<li>-10^8 &lt;= val &lt;= 10^8</li>\n<li>新值和原始二叉搜索树中的任意节点值都不同</li>\n</ul>\n<h2 id=\"方法一：模拟\"><a href=\"#方法一：模拟\" class=\"headerlink\" title=\"方法一：模拟\"></a>方法一：模拟</h2><p><strong>思路与算法</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902134857500.png\" alt=\"image-20210902134857500\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode pos = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pos != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &lt; pos.val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pos.left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pos.left = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = pos.left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pos.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    pos.right = <span class=\"keyword\">new</span> TreeNode(val);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    pos = pos.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(N)</code>，其中 <code>N</code> 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 <code>O(N)</code>。</li>\n<li>空间复杂度：<code>O(1)</code>。我们只使用了常数大小的空间。</li>\n</ul>\n<h1 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">98. 验证二叉搜索树</a></h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<ul>\n<li>节点的左子树只包含小于当前节点的数。</li>\n<li>节点的右子树只包含大于当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    2</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   4</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    3   6</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class=\"line\">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法一-递归\"><a href=\"#方法一-递归\" class=\"headerlink\" title=\"方法一: 递归\"></a>方法一: 递归</h2><p><img src=\"../../../../img/leetcode-tree/image-20210902135151261.png\" alt=\"image-20210902135151261\"></p>\n<p><img src=\"../../../../img/leetcode-tree/list-16305619911838.gif\" alt=\"list\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode node, <span class=\"keyword\">long</span> lower, <span class=\"keyword\">long</span> upper)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902135354367.png\" alt=\"image-20210902135354367\"></p>\n<h2 id=\"方法二：中序遍历\"><a href=\"#方法二：中序遍历\" class=\"headerlink\" title=\"方法二：中序遍历\"></a>方法二：中序遍历</h2><p><img src=\"../../../../img/leetcode-tree/image-20210902135414334.png\" alt=\"image-20210902135414334\"></p>\n<p><img src=\"../../../../img/leetcode-tree/image-20220920091455015.png\" alt=\"image-20220920091455015\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">double</span> inorder = -Double.MAX_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">              <span class=\"comment\">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.val &lt;= inorder) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            inorder = root.val;</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度 : <code>O(n)</code>，其中 <code>n</code> 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 <code>O(n)</code>。</li>\n<li>空间复杂度 : <code>O(n)</code>，其中 <code>n</code> 为二叉树的节点个数。栈最多存储 <code>n</code> 个节点，因此需要额外的 <code>O(n)</code> 的空间。</li>\n</ul>\n<h1 id=\"653-两数之和-IV-输入-BST\"><a href=\"#653-两数之和-IV-输入-BST\" class=\"headerlink\" title=\"653. 两数之和 IV - 输入 BST\"></a><a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\" target=\"_blank\" rel=\"noopener\">653. 两数之和 IV - 输入 BST</a></h1><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/sum_tree_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<p><img src=\"../../../../img/leetcode-tree/sum_tree_2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 28</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 4</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 1</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [2,1,3], k &#x3D; 3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>二叉树的节点个数的范围是  [1, 104].</li>\n<li>-104 &lt;= Node.val &lt;= 104</li>\n<li>root 为二叉搜索树</li>\n<li>-105 &lt;= k &lt;= 105</li>\n</ul>\n<h2 id=\"方法一：使用-HashSet【通过】\"><a href=\"#方法一：使用-HashSet【通过】\" class=\"headerlink\" title=\"方法一：使用 HashSet【通过】\"></a>方法一：使用 HashSet【通过】</h2><p>最简单的方法就是遍历整棵树，找出所有可能的组合，判断是否存在和为 k 的一对节点。现在在此基础上做一些改进。</p>\n<p>如果存在两个元素之和为 k，即 x+y=k，并且已知 xx 是树上一个节点的值，则只需判断树上是否存在一个值为 y 的节点，使得 y=k-x。基于这种思想，在树的每个节点上遍历它的两棵子树（左子树和右子树），寻找另外一个匹配的数。在遍历过程中，将每个节点的值都放到一个 set 中。</p>\n<p>对于每个值为 p 的节点，在 set 中检查是否存在 k−p。如果存在，那么可以在该树上找到两个节点的和为 k；否则，将 p 放入到 set 中。</p>\n<p>如果遍历完整棵树都没有找到一对节点和为 k，那么该树上不存在两个和为 k 的节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Set &lt; Integer &gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(root, k, set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k, Set &lt; Integer &gt; set)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (set.contains(k - root.val))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        set.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find(root.left, k, set) || find(root.right, k, set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>N</code> 是节点的数量。最坏的情况下，整棵树被遍历一次。</li>\n<li>空间复杂度：<code>O(n)</code>。最坏的情况下，set 存储 n 个节点的值。</li>\n</ul>\n<h2 id=\"方法二：使用-BFS-和-HashSet【通过】\"><a href=\"#方法二：使用-BFS-和-HashSet【通过】\" class=\"headerlink\" title=\"方法二：使用 BFS 和 HashSet【通过】\"></a>方法二：使用 BFS 和 HashSet【通过】</h2><p>算法</p>\n<p>本方法中，set 的用途与 方法一 相同。但是本方法使用广度优先搜索遍历二叉树，这是一种非常常见的遍历方法。</p>\n<p>使用广度优先搜索查找一对节点和为 k 的过程如下。首先维护一个与 方法一 用途相同的 set。将根节点加入 queue，然后执行以下步骤：</p>\n<ol>\n<li>从队列首部删除一个元素 p。</li>\n<li>检查 set 中是否存在 k−p。如果存在，返回 True。</li>\n<li>否则，将 p 加入 set。然后将当前节点的左孩子和右孩子加入 queue。</li>\n<li>重复步骤一至三，直到 queue 为空。</li>\n<li>如果 queue 为空，返回 False。</li>\n</ol>\n<p>按照以上步骤，逐层遍历二叉树。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        Set &lt; Integer &gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        Queue &lt; TreeNode &gt; queue = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue.peek() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                TreeNode node = queue.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.contains(k - node.val))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                set.add(node.val);</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">                queue.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 n 是树中节点的数量。最坏的情况下，需要遍历整棵树。</li>\n<li>空间复杂度：<code>O(n)</code>。最坏的情况下，set 存储 n 个节点的值。</li>\n</ul>\n<h2 id=\"方法三：使用-BST【通过】\"><a href=\"#方法三：使用-BST【通过】\" class=\"headerlink\" title=\"方法三：使用 BST【通过】\"></a>方法三：使用 BST【通过】</h2><p>算法</p>\n<p>在本方法中利用 BST 的性质，BST 的中序遍历结果是按升序排列的。因此，中序遍历给定的 BST，并将遍历结果存储到 list 中。</p>\n<p>遍历完成后，使用两个指针 l 和 r 作为 list 的头部索引和尾部索引。然后执行以下操作：</p>\n<p>检查 l 和 r 索引处两元素之和是否等于 k。如果是，立即返回 True。</p>\n<p>如果当前两元素之和小于 k，则更新 l 指向下一个元素。这是因为当我们需要增大两数之和时，应该增大较小数。</p>\n<p>如果当前两元素之和大于 k，则更新 r 指向上一个元素。这是因为当我们需要减小两数之和时，应该减小较大数。</p>\n<p>重复步骤一至三，直到左指针 l 大于右指针 r。</p>\n<p>如果左指针 l 到右指针 r 的右边，则返回 False。</p>\n<p>注意，在任何情况下，都不应该增大较大的数，也不应该减小较小的数。这是因为如果当前两数之和大于 k，不应该首先增大 list[r] 的值。类似的，也不应该首先减小 list[l] 的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        List &lt; Integer &gt; list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        inorder(root, list);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = list.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = list.get(l) + list.get(r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &lt; k)</span><br><span class=\"line\">                l++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode root, List &lt; Integer &gt; list)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inorder(root.left, list);</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        inorder(root.right, list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 n 是树中节点的数量。本方法需要中序遍历整棵树。</li>\n<li>空间复杂度：<code>O(n)</code>，list 中存储 n 个元素。</li>\n</ul>\n<h1 id=\"235-二叉搜索树的最近公共祖先\"><a href=\"#235-二叉搜索树的最近公共祖先\" class=\"headerlink\" title=\"235. 二叉搜索树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\" target=\"_blank\" rel=\"noopener\">235. 二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>\n<p><img src=\"../../../../img/leetcode-tree/binarysearchtree_improved.png\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong></p>\n<ul>\n<li>所有节点的值都是唯一的。</li>\n<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n<h2 id=\"方法一：两次遍历\"><a href=\"#方法一：两次遍历\" class=\"headerlink\" title=\"方法一：两次遍历\"></a>方法一：两次遍历</h2><p>思路与算法</p>\n<p>注意到题目中给出的是一棵「二叉搜索树」，因此我们可以快速地找出树中的某个节点以及从根节点到该节点的路径，例如我们需要找到节点 p：</p>\n<p>我们从根节点开始遍历；</p>\n<p>如果当前节点就是 p，那么成功地找到了节点；</p>\n<p>如果当前节点的值大于 p 的值，说明 p 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；</p>\n<p>如果当前节点的值小于 p 的值，说明 p 应该在当前节点的右子树，因此将当前节点移动到它的右子节点。</p>\n<p>对于节点 q 同理。在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。</p>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902140548484.png\" alt=\"image-20210902140548484\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;TreeNode&gt; path_p = getPath(root, p);</span><br><span class=\"line\">        List&lt;TreeNode&gt; path_q = getPath(root, q);</span><br><span class=\"line\">        TreeNode ancestor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path_p.get(i) == path_q.get(i)) &#123;</span><br><span class=\"line\">                ancestor = path_p.get(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ancestor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;TreeNode&gt; <span class=\"title\">getPath</span><span class=\"params\">(TreeNode root, TreeNode target)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;TreeNode&gt; path = <span class=\"keyword\">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != target) &#123;</span><br><span class=\"line\">            path.add(node);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target.val &lt; node.val) &#123;</span><br><span class=\"line\">                node = node.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = node.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path.add(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../img/leetcode-tree/image-20210902140618113.png\" alt=\"image-20210902140618113\"></p>\n<h2 id=\"方法二：一次遍历\"><a href=\"#方法二：一次遍历\" class=\"headerlink\" title=\"方法二：一次遍历\"></a>方法二：一次遍历</h2><p>思路与算法</p>\n<p>在方法一中，我们对从根节点开始，通过遍历找出到达节点 p 和 q 的路径，一共需要两次遍历。我们也可以考虑将这两个节点放在一起遍历。</p>\n<p>整体的遍历过程与方法一中的类似：</p>\n<ul>\n<li>我们从根节点开始遍历；</li>\n<li>如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；</li>\n<li>如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此将当前节点移动到它的右子节点；</li>\n<li>如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，p 和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。</li>\n</ul>\n<p>可以发现，如果我们将这两个节点放在一起遍历，我们就省去了存储路径需要的空间。</p>\n<p><img src=\"../../../../img/leetcode-tree/list1-163056291675612.gif\" alt=\"list1\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        TreeNode ancestor = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;</span><br><span class=\"line\">                ancestor = ancestor.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;</span><br><span class=\"line\">                ancestor = ancestor.right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ancestor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是给定的二叉搜索树中的节点个数。分析思路与方法一相同。</li>\n<li>空间复杂度：<code>O(1)</code>。</li>\n</ul>\n","next":{"title":"微服务基本介绍","path":"api/articles/resource-MicroService-other-微服务基本介绍.json","image":"/img/header_img/MicroService/MicroService.PNG","num_read":318,"num_like":1038,"num_collection":188,"num_comments":178},"prev":{"title":"Spring底层核心原理","path":"api/articles/resource-Spring-Spring-Spring底层核心原理.json","image":"/img/header_img/spring/Principles.PNG","num_read":935,"num_like":838,"num_collection":674,"num_comments":31},"categories":[{"name":"数据结构","path":"api/categories/数据结构.json","pathContent":"api/categories/数据结构","description":"一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合。","cover":"https://sunfy9.gitee.io/project/photo/project/dataStructure.png"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json","pathContent":"api/tags/leetcode","description":"[leetcode]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}