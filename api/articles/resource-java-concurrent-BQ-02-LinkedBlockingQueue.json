{"title":"LinkedBlockingQueue介绍","num_read":1703,"num_like":308,"num_collection":496,"num_comments":50,"slug":"resource-java-concurrent-BQ-02-LinkedBlockingQueue","date":"2021-12-13T16:00:00.000Z","img":"/img/header_img/concurrent/LinkedBlockingQueue.png","minNumber":600,"format":"standard","_id":"clhrbp2dl0094o5lg0c6r5e80","project":"concurrent","subtitle":"LinkedBlockingQueue是一个基于链表实现的阻塞队列","site":{"data":{}},"updated":"2022-01-12T05:39:34.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-02-LinkedBlockingQueue.json","webPath":"2021/12/14/resource-java-concurrent-BQ-02-LinkedBlockingQueue/","permalink":"https://sunfy9.gitee.io/2021/12/14/resource-java-concurrent-BQ-02-LinkedBlockingQueue/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a><strong>LinkedBlockingQueue</strong></h1><p>LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限，队列可以随着元素的添加而动态增长，但是如果没有剩余内存，则队列将抛出OOM错误。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小。</p>\n<p>LinkedBlockingQueue内部由单链表实现，只能从head取元素，从tail添加元素。LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞，添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写操作可以并行执行。</p>\n<p>无界阻塞队列，可以指定容量，默认为Integer.MAX_VALUE，先进先出，存取互不干扰</p>\n<p>数据结构：链表，可以指定容量，默认为Integer.MAX_VALUE，内部为Node存储元素</p>\n<p>锁分离：存取互不干扰，存取操作的是不同的Node对象（删除元素时两个一起锁）<sunfy-line></p>\n<ul>\n<li>takeLock：取Node节点保证前驱后继不会乱</li>\n<li>putLock：存Node节点保证前驱后继不会乱</li>\n</ul>\n<p>阻塞对象：</p>\n<ul>\n<li>notEmpty：出队：队列count=0，无元素可取时，阻塞在该对象上</li>\n<li>notFull：入队：队列count=capacity，放不进去元素时，阻塞在该对象上</li>\n</ul>\n<p>入队：队尾入队，由last指针记录</p>\n<p>出队：队首出队，由haed指针记录</p>\n<p>先进先出</p>\n<p>线程池中为什么使用LinkedBlockingQueue而不用ArrayBlockingQueue？锁分离</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定队列的大小创建有界队列</span></span><br><span class=\"line\">BlockingQueue&lt;Integer&gt; boundedQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">//无界队列</span></span><br><span class=\"line\">BlockingQueue&lt;Integer&gt; unboundedQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><strong>原理</strong></h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容量,指定容量就是有界队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"><span class=\"comment\">// 元素数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"><span class=\"comment\">// 链表头  本身是不存储任何元素的，初始化时item指向null</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; head;</span><br><span class=\"line\"><span class=\"comment\">// 链表尾</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br><span class=\"line\"><span class=\"comment\">// take锁   锁分离，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// notEmpty条件</span></span><br><span class=\"line\"><span class=\"comment\">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class=\"line\"><span class=\"comment\">// put锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// notFull条件</span></span><br><span class=\"line\"><span class=\"comment\">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notFull = putLock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//典型的单链表结构</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;  <span class=\"comment\">//存储元素</span></span><br><span class=\"line\">    Node&lt;E&gt; next;  <span class=\"comment\">//后继节点    单链表结构</span></span><br><span class=\"line\">    Node(E x) &#123; item = x; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a><strong>构造器</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedBlockingQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没传容量，就使用最大int值初始化其容量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Integer.MAX_VALUE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化head和last指针为空值节点</span></span><br><span class=\"line\">    last = head = <span class=\"keyword\">new</span> Node&lt;E&gt;(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"入队put方法\"><a href=\"#入队put方法\" class=\"headerlink\" title=\"入队put方法\"></a><strong>入队put方法</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;    </span><br><span class=\"line\">    <span class=\"comment\">// 不允许null元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个节点</span></span><br><span class=\"line\">    Node&lt;E&gt; node = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">this</span>.putLock;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    <span class=\"comment\">// 使用put锁加锁</span></span><br><span class=\"line\">    putLock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列满了，就阻塞在notFull上等待被其它线程唤醒（阻塞生产者线程）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == capacity) &#123;</span><br><span class=\"line\">            notFull.await();</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 队列不满，就入队</span></span><br><span class=\"line\">        enqueue(node);</span><br><span class=\"line\">        c = count.getAndIncrement();<span class=\"comment\">// 队列长度加1，返回原值</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果现队列长度小于容量，notFull条件队列转同步队列，准备唤醒一个阻塞在notFull条件上的线程(可以继续入队) </span></span><br><span class=\"line\">        <span class=\"comment\">// 这里为啥要唤醒一下呢？</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为可能有很多线程阻塞在notFull这个条件上,而取元素时只有取之前队列是满的才会唤醒notFull,此处不用等到取元素时才唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c + <span class=\"number\">1</span> &lt; capacity)</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putLock.unlock(); <span class=\"comment\">// 真正唤醒生产者线程</span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 如果原队列长度为0，现在加了一个元素后立即唤醒阻塞在notEmpty上的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">        signalNotEmpty();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Node&lt;E&gt; node)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 直接加到last后面,last指向入队元素</span></span><br><span class=\"line\">    last = last.next = node;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">signalNotEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock; </span><br><span class=\"line\">    takeLock.lock();<span class=\"comment\">// 加take锁</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        notEmpty.signal();<span class=\"comment\">// notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        takeLock.unlock();  <span class=\"comment\">// 真正唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"出队take方法\"><a href=\"#出队take方法\" class=\"headerlink\" title=\"出队take方法\"></a><strong>出队take方法</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    E x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock;</span><br><span class=\"line\">    <span class=\"comment\">// 使用takeLock加锁</span></span><br><span class=\"line\">    takeLock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列无元素，则阻塞在notEmpty条件上（消费者线程阻塞）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            notEmpty.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 否则，出队</span></span><br><span class=\"line\">        x = dequeue();</span><br><span class=\"line\">        c = count.getAndDecrement();<span class=\"comment\">//长度-1，返回原值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &gt; <span class=\"number\">1</span>)<span class=\"comment\">// 如果取之前队列长度大于1，notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程，原因与入队同理</span></span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        takeLock.unlock(); <span class=\"comment\">// 真正唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为什么队列是满的才唤醒阻塞在notFull上的线程呢？</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为唤醒是需要加putLock的，这是为了减少锁的次数,所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程,</span></span><br><span class=\"line\">    <span class=\"comment\">// 这也是锁分离带来的代价</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果取之前队列长度等于容量（已满），则唤醒阻塞在notFull的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == capacity)</span><br><span class=\"line\">        signalNotFull();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// head节点本身是不存储任何元素的</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里把head删除，并把head下一个节点作为新的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 并把其值置空，返回原来的值</span></span><br><span class=\"line\">    Node&lt;E&gt; h = head;</span><br><span class=\"line\">    Node&lt;E&gt; first = h.next;</span><br><span class=\"line\">    h.next = h; <span class=\"comment\">// 方便GC</span></span><br><span class=\"line\">    head = first;</span><br><span class=\"line\">    E x = first.item;</span><br><span class=\"line\">    first.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">signalNotFull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">this</span>.putLock;</span><br><span class=\"line\">    putLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        notFull.signal();<span class=\"comment\">// notFull条件队列转同步队列，准备唤醒阻塞在notFull上的线程</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putLock.unlock(); <span class=\"comment\">// 解锁，这才会真正的唤醒生产者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"LinkedBlockingQueue与ArrayBlockingQueue对比\"><a href=\"#LinkedBlockingQueue与ArrayBlockingQueue对比\" class=\"headerlink\" title=\"LinkedBlockingQueue与ArrayBlockingQueue对比\"></a><strong>LinkedBlockingQueue与ArrayBlockingQueue对比</strong></h1><p>LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：</p>\n<ul>\n<li>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</li>\n<li><strong>数据存储容器不同</strong>，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</li>\n<li>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据时，对于GC可能存在较大影响。</li>\n<li>两者的实现队列添加或移除的锁不一样，<strong>ArrayBlockingQueue实现的队列中的锁是没有分离的</strong>，即添加操作和移除操作采用的同一个ReenterLock锁，而<strong>LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock</strong>，<strong>这样能大大提高队列的吞吐量</strong>，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。正是因为这一点，线程池中使用LinkedBlockingQueue而不用ArrayBlockingQueue</li>\n</ul>\n","more":"<h1 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a><strong>LinkedBlockingQueue</strong></h1><p>LinkedBlockingQueue是一个基于链表实现的阻塞队列，默认情况下，该阻塞队列的大小为Integer.MAX_VALUE，由于这个数值特别大，所以 LinkedBlockingQueue 也被称作无界队列，代表它几乎没有界限，队列可以随着元素的添加而动态增长，但是如果没有剩余内存，则队列将抛出OOM错误。所以为了避免队列过大造成机器负载或者内存爆满的情况出现，我们在使用的时候建议手动传一个队列的大小。</p>\n<p>LinkedBlockingQueue内部由单链表实现，只能从head取元素，从tail添加元素。LinkedBlockingQueue采用两把锁的锁分离技术实现入队出队互不阻塞，添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写操作可以并行执行。</p>\n<p>无界阻塞队列，可以指定容量，默认为Integer.MAX_VALUE，先进先出，存取互不干扰</p>\n<p>数据结构：链表，可以指定容量，默认为Integer.MAX_VALUE，内部为Node存储元素</p>\n<p>锁分离：存取互不干扰，存取操作的是不同的Node对象（删除元素时两个一起锁）<sunfy-line></p>\n<ul>\n<li>takeLock：取Node节点保证前驱后继不会乱</li>\n<li>putLock：存Node节点保证前驱后继不会乱</li>\n</ul>\n<p>阻塞对象：</p>\n<ul>\n<li>notEmpty：出队：队列count=0，无元素可取时，阻塞在该对象上</li>\n<li>notFull：入队：队列count=capacity，放不进去元素时，阻塞在该对象上</li>\n</ul>\n<p>入队：队尾入队，由last指针记录</p>\n<p>出队：队首出队，由haed指针记录</p>\n<p>先进先出</p>\n<p>线程池中为什么使用LinkedBlockingQueue而不用ArrayBlockingQueue？锁分离</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//指定队列的大小创建有界队列</span></span><br><span class=\"line\">BlockingQueue&lt;Integer&gt; boundedQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">//无界队列</span></span><br><span class=\"line\">BlockingQueue&lt;Integer&gt; unboundedQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><strong>原理</strong></h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容量,指定容量就是有界队列</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"><span class=\"comment\">// 元素数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"><span class=\"comment\">// 链表头  本身是不存储任何元素的，初始化时item指向null</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; head;</span><br><span class=\"line\"><span class=\"comment\">// 链表尾</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br><span class=\"line\"><span class=\"comment\">// take锁   锁分离，提高效率</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// notEmpty条件</span></span><br><span class=\"line\"><span class=\"comment\">// 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class=\"line\"><span class=\"comment\">// put锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"comment\">// notFull条件</span></span><br><span class=\"line\"><span class=\"comment\">// 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notFull = putLock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//典型的单链表结构</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    E item;  <span class=\"comment\">//存储元素</span></span><br><span class=\"line\">    Node&lt;E&gt; next;  <span class=\"comment\">//后继节点    单链表结构</span></span><br><span class=\"line\">    Node(E x) &#123; item = x; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a><strong>构造器</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedBlockingQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没传容量，就使用最大int值初始化其容量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Integer.MAX_VALUE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (capacity &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化head和last指针为空值节点</span></span><br><span class=\"line\">    last = head = <span class=\"keyword\">new</span> Node&lt;E&gt;(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"入队put方法\"><a href=\"#入队put方法\" class=\"headerlink\" title=\"入队put方法\"></a><strong>入队put方法</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;    </span><br><span class=\"line\">    <span class=\"comment\">// 不允许null元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个节点</span></span><br><span class=\"line\">    Node&lt;E&gt; node = <span class=\"keyword\">new</span> Node&lt;E&gt;(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">this</span>.putLock;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    <span class=\"comment\">// 使用put锁加锁</span></span><br><span class=\"line\">    putLock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列满了，就阻塞在notFull上等待被其它线程唤醒（阻塞生产者线程）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == capacity) &#123;</span><br><span class=\"line\">            notFull.await();</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 队列不满，就入队</span></span><br><span class=\"line\">        enqueue(node);</span><br><span class=\"line\">        c = count.getAndIncrement();<span class=\"comment\">// 队列长度加1，返回原值</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果现队列长度小于容量，notFull条件队列转同步队列，准备唤醒一个阻塞在notFull条件上的线程(可以继续入队) </span></span><br><span class=\"line\">        <span class=\"comment\">// 这里为啥要唤醒一下呢？</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为可能有很多线程阻塞在notFull这个条件上,而取元素时只有取之前队列是满的才会唤醒notFull,此处不用等到取元素时才唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c + <span class=\"number\">1</span> &lt; capacity)</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putLock.unlock(); <span class=\"comment\">// 真正唤醒生产者线程</span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 如果原队列长度为0，现在加了一个元素后立即唤醒阻塞在notEmpty上的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">        signalNotEmpty();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Node&lt;E&gt; node)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 直接加到last后面,last指向入队元素</span></span><br><span class=\"line\">    last = last.next = node;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">signalNotEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock; </span><br><span class=\"line\">    takeLock.lock();<span class=\"comment\">// 加take锁</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        notEmpty.signal();<span class=\"comment\">// notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        takeLock.unlock();  <span class=\"comment\">// 真正唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"出队take方法\"><a href=\"#出队take方法\" class=\"headerlink\" title=\"出队take方法\"></a><strong>出队take方法</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    E x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock;</span><br><span class=\"line\">    <span class=\"comment\">// 使用takeLock加锁</span></span><br><span class=\"line\">    takeLock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果队列无元素，则阻塞在notEmpty条件上（消费者线程阻塞）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count.get() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            notEmpty.await();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 否则，出队</span></span><br><span class=\"line\">        x = dequeue();</span><br><span class=\"line\">        c = count.getAndDecrement();<span class=\"comment\">//长度-1，返回原值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &gt; <span class=\"number\">1</span>)<span class=\"comment\">// 如果取之前队列长度大于1，notEmpty条件队列转同步队列，准备唤醒阻塞在notEmpty上的线程，原因与入队同理</span></span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        takeLock.unlock(); <span class=\"comment\">// 真正唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 为什么队列是满的才唤醒阻塞在notFull上的线程呢？</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为唤醒是需要加putLock的，这是为了减少锁的次数,所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程,</span></span><br><span class=\"line\">    <span class=\"comment\">// 这也是锁分离带来的代价</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果取之前队列长度等于容量（已满），则唤醒阻塞在notFull的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == capacity)</span><br><span class=\"line\">        signalNotFull();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// head节点本身是不存储任何元素的</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里把head删除，并把head下一个节点作为新的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 并把其值置空，返回原来的值</span></span><br><span class=\"line\">    Node&lt;E&gt; h = head;</span><br><span class=\"line\">    Node&lt;E&gt; first = h.next;</span><br><span class=\"line\">    h.next = h; <span class=\"comment\">// 方便GC</span></span><br><span class=\"line\">    head = first;</span><br><span class=\"line\">    E x = first.item;</span><br><span class=\"line\">    first.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">signalNotFull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock putLock = <span class=\"keyword\">this</span>.putLock;</span><br><span class=\"line\">    putLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        notFull.signal();<span class=\"comment\">// notFull条件队列转同步队列，准备唤醒阻塞在notFull上的线程</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        putLock.unlock(); <span class=\"comment\">// 解锁，这才会真正的唤醒生产者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"LinkedBlockingQueue与ArrayBlockingQueue对比\"><a href=\"#LinkedBlockingQueue与ArrayBlockingQueue对比\" class=\"headerlink\" title=\"LinkedBlockingQueue与ArrayBlockingQueue对比\"></a><strong>LinkedBlockingQueue与ArrayBlockingQueue对比</strong></h1><p>LinkedBlockingQueue是一个阻塞队列，内部由两个ReentrantLock来实现出入队列的线程安全，由各自的Condition对象的await和signal来实现等待和唤醒功能。它和ArrayBlockingQueue的不同点在于：</p>\n<ul>\n<li>队列大小有所不同，ArrayBlockingQueue是有界的初始化必须指定大小，而LinkedBlockingQueue可以是有界的也可以是无界的(Integer.MAX_VALUE)，对于后者而言，当添加速度大于移除速度时，在无界的情况下，可能会造成内存溢出等问题。</li>\n<li><strong>数据存储容器不同</strong>，ArrayBlockingQueue采用的是数组作为数据存储容器，而LinkedBlockingQueue采用的则是以Node节点作为连接对象的链表。</li>\n<li>由于ArrayBlockingQueue采用的是数组的存储容器，因此在插入或删除元素时不会产生或销毁任何额外的对象实例，而LinkedBlockingQueue则会生成一个额外的Node对象。这可能在长时间内需要高效并发地处理大批量数据时，对于GC可能存在较大影响。</li>\n<li>两者的实现队列添加或移除的锁不一样，<strong>ArrayBlockingQueue实现的队列中的锁是没有分离的</strong>，即添加操作和移除操作采用的同一个ReenterLock锁，而<strong>LinkedBlockingQueue实现的队列中的锁是分离的，其添加采用的是putLock，移除采用的则是takeLock</strong>，<strong>这样能大大提高队列的吞吐量</strong>，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。正是因为这一点，线程池中使用LinkedBlockingQueue而不用ArrayBlockingQueue</li>\n</ul>\n","next":{"title":"ArrayBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-01-ArrayBlockingQueue.json","image":"/img/header_img/concurrent/ArrayBlockingQueue.png","num_read":1856,"num_like":551,"num_collection":324,"num_comments":80},"prev":{"title":"SynchronousQueue介绍","path":"api/articles/resource-java-concurrent-BQ-03-SynchronousQueue.json","image":"/img/header_img/concurrent/SynchronousQueue.png","num_read":136,"num_like":504,"num_collection":47,"num_comments":176},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}