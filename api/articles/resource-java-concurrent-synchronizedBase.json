{"title":"synchronized基本使用","num_read":1575,"num_like":942,"num_collection":143,"num_comments":165,"slug":"resource-java-concurrent-synchronizedBase","date":"2021-11-16T16:00:00.000Z","img":"/img/header_img/concurrent/synchronizedBase.png","_id":"clhrbp2dm009ho5lgfbbq2aqp","project":"concurrent","subtitle":"用于屏蔽掉各种硬件和操作系统的内存访问差异，基本使用","site":{"data":{}},"updated":"2022-09-19T14:44:37.283Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-synchronizedBase.json","webPath":"2021/11/17/resource-java-concurrent-synchronizedBase/","permalink":"https://sunfy9.gitee.io/2021/11/17/resource-java-concurrent-synchronizedBase/","excerpt":null,"covers":["../../../../img/synchronizedBase/image-20211117093634739.png","../../../../img/synchronizedBase/image-20211117093721218.png","../../../../img/synchronizedBase/image-20211117094004355.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>解决线程安全问题</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>加锁： 序列化的访问临界资源</p>\n<p>java中的实现 :    </p>\n<ul>\n<li>阻塞： synchronized reentrantLock</li>\n<li>非阻塞：  cas+自旋</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>代码很简单，创建两个线程，一个线程做累加操作，一个线程做递减操作，且操作的是同一个变量，按照我们预期值最终输出结果应该为0，但是结果会符合我们预计吗？<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        counter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) &#123;</span><br><span class=\"line\">                increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) &#123;</span><br><span class=\"line\">                decrement();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        <span class=\"comment\">//思考： counter=？</span></span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;\"</span>, counter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码运行结果显而易见，输出结果不确定，且很难得到我们的预期值。</p>\n<h1 id=\"示例分析\"><a href=\"#示例分析\" class=\"headerlink\" title=\"示例分析\"></a>示例分析</h1><p>首先从我们的理解来说，上面示例中一个线程自增，一个线程递减，不论哪个线程执行，都会去操作共享变量counter。然而在自增操作中，会先从内存中获取共享变量值，然后进行累加，最后再将结果赋值给共享变量。可想变量的累加并不是原子操作，递减操作也是同理，最终会出现累加时获取了值，还没有进行累加或者累加后还没有赋值给共享变量，此时又在同步进行递减操作，那最终结果可想而知会出现正数、负数以及我们期望的0，三种情况都可能出现。</p>\n<h2 id=\"从jvm字节码层面分析\"><a href=\"#从jvm字节码层面分析\" class=\"headerlink\" title=\"从jvm字节码层面分析\"></a>从jvm字节码层面分析</h2><p>递增操作：</p>\n<p><img src=\"../../../../img/synchronizedBase/image-20211117093634739.png\" alt=\"image-20211117093634739\"></p>\n<p>递减操作：</p>\n<p><img src=\"../../../../img/synchronizedBase/image-20211117093721218.png\" alt=\"image-20211117093721218\"></p>\n<h2 id=\"两个概念\"><a href=\"#两个概念\" class=\"headerlink\" title=\"两个概念\"></a>两个概念</h2><h3 id=\"临界区（-Critical-Section）\"><a href=\"#临界区（-Critical-Section）\" class=\"headerlink\" title=\"临界区（ Critical Section）\"></a>临界区（ Critical Section）</h3><ul>\n<li>一个程序运行多个线程本身是没有问题的</li>\n<li>问题出在多个线程访问共享资源<ul>\n<li>多个线程读共享资源其实也没有问题</li>\n<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li>\n</ul>\n</li>\n</ul>\n<p>一段代码块内如果存在对共享资源的<strong>多线程读写操作</strong>，称这段代码块为临界区，其共享资源为临界资源</p>\n<h3 id=\"竞态条件（-Race-Condition-）\"><a href=\"#竞态条件（-Race-Condition-）\" class=\"headerlink\" title=\"竞态条件（ Race Condition ）\"></a>竞态条件（ Race Condition ）</h3><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>\n<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>\n<ul>\n<li>阻塞式的解决方案：synchronized，Lock </li>\n<li>非阻塞式的解决方案：原子变量</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： </p>\n<blockquote>\n<p><strong>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</strong> </p>\n<p><strong>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</strong></p>\n</blockquote>\n<h2 id=\"synchronized的使用\"><a href=\"#synchronized的使用\" class=\"headerlink\" title=\"synchronized的使用\"></a>synchronized的使用</h2><p>synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁。</p>\n<h2 id=\"加锁方式\"><a href=\"#加锁方式\" class=\"headerlink\" title=\"加锁方式\"></a>加锁方式</h2><p><img src=\"../../../../img/synchronizedBase/image-20211117094004355.png\" alt=\"image-20211117094004355\"></p>\n<h1 id=\"示例解决\"><a href=\"#示例解决\" class=\"headerlink\" title=\"示例解决\"></a>示例解决</h1><p>用<code>synchronized</code>解决上面的问题，对临界区代码进行加锁，可以直接锁住相应的累加和递减方法，我们运行多次后可以看到每次都会得到我们的预期值0</p>\n","more":"<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><p>解决线程安全问题</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>加锁： 序列化的访问临界资源</p>\n<p>java中的实现 :    </p>\n<ul>\n<li>阻塞： synchronized reentrantLock</li>\n<li>非阻塞：  cas+自旋</li>\n</ul>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>代码很简单，创建两个线程，一个线程做累加操作，一个线程做递减操作，且操作的是同一个变量，按照我们预期值最终输出结果应该为0，但是结果会符合我们预计吗？<sunfy-line></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        counter++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        counter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) &#123;</span><br><span class=\"line\">                increment();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++) &#123;</span><br><span class=\"line\">                decrement();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        <span class=\"comment\">//思考： counter=？</span></span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;\"</span>, counter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码运行结果显而易见，输出结果不确定，且很难得到我们的预期值。</p>\n<h1 id=\"示例分析\"><a href=\"#示例分析\" class=\"headerlink\" title=\"示例分析\"></a>示例分析</h1><p>首先从我们的理解来说，上面示例中一个线程自增，一个线程递减，不论哪个线程执行，都会去操作共享变量counter。然而在自增操作中，会先从内存中获取共享变量值，然后进行累加，最后再将结果赋值给共享变量。可想变量的累加并不是原子操作，递减操作也是同理，最终会出现累加时获取了值，还没有进行累加或者累加后还没有赋值给共享变量，此时又在同步进行递减操作，那最终结果可想而知会出现正数、负数以及我们期望的0，三种情况都可能出现。</p>\n<h2 id=\"从jvm字节码层面分析\"><a href=\"#从jvm字节码层面分析\" class=\"headerlink\" title=\"从jvm字节码层面分析\"></a>从jvm字节码层面分析</h2><p>递增操作：</p>\n<p><img src=\"../../../../img/synchronizedBase/image-20211117093634739.png\" alt=\"image-20211117093634739\"></p>\n<p>递减操作：</p>\n<p><img src=\"../../../../img/synchronizedBase/image-20211117093721218.png\" alt=\"image-20211117093721218\"></p>\n<h2 id=\"两个概念\"><a href=\"#两个概念\" class=\"headerlink\" title=\"两个概念\"></a>两个概念</h2><h3 id=\"临界区（-Critical-Section）\"><a href=\"#临界区（-Critical-Section）\" class=\"headerlink\" title=\"临界区（ Critical Section）\"></a>临界区（ Critical Section）</h3><ul>\n<li>一个程序运行多个线程本身是没有问题的</li>\n<li>问题出在多个线程访问共享资源<ul>\n<li>多个线程读共享资源其实也没有问题</li>\n<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li>\n</ul>\n</li>\n</ul>\n<p>一段代码块内如果存在对共享资源的<strong>多线程读写操作</strong>，称这段代码块为临界区，其共享资源为临界资源</p>\n<h3 id=\"竞态条件（-Race-Condition-）\"><a href=\"#竞态条件（-Race-Condition-）\" class=\"headerlink\" title=\"竞态条件（ Race Condition ）\"></a>竞态条件（ Race Condition ）</h3><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>\n<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>\n<ul>\n<li>阻塞式的解决方案：synchronized，Lock </li>\n<li>非阻塞式的解决方案：原子变量</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： </p>\n<blockquote>\n<p><strong>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</strong> </p>\n<p><strong>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</strong></p>\n</blockquote>\n<h2 id=\"synchronized的使用\"><a href=\"#synchronized的使用\" class=\"headerlink\" title=\"synchronized的使用\"></a>synchronized的使用</h2><p>synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内置锁，也叫作监视器锁。</p>\n<h2 id=\"加锁方式\"><a href=\"#加锁方式\" class=\"headerlink\" title=\"加锁方式\"></a>加锁方式</h2><p><img src=\"../../../../img/synchronizedBase/image-20211117094004355.png\" alt=\"image-20211117094004355\"></p>\n<h1 id=\"示例解决\"><a href=\"#示例解决\" class=\"headerlink\" title=\"示例解决\"></a>示例解决</h1><p>用<code>synchronized</code>解决上面的问题，对临界区代码进行加锁，可以直接锁住相应的累加和递减方法，我们运行多次后可以看到每次都会得到我们的预期值0</p>\n","next":{"title":"AQS之独占锁ReentrantLock","path":"api/articles/resource-java-concurrent-ReentrantLock.json","image":"/img/header_img/concurrent/ReentrantLock.png","num_read":1629,"num_like":648,"num_collection":378,"num_comments":143},"prev":{"title":"synchronized原理分析","path":"api/articles/resource-java-concurrent-synchronized.json","image":"/img/header_img/concurrent/synchronized.png","num_read":1458,"num_like":342,"num_collection":480,"num_comments":101},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}