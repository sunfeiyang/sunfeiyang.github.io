{"title":"SpringBean的生命周期详解","num_read":1189,"num_like":351,"num_collection":202,"num_comments":196,"slug":"resource-Spring-Spring-SpringBean的生命周期详解","date":"2021-09-08T16:00:00.000Z","img":"/img/header_img/spring/BeanLife.png","_id":"cl89pzm9o000o19lg2g2jeq5i","project":"Spring","subtitle":"Spring源码分析，详细分析理解Spring整个bean的生命周期，理解整个Bean的生成过程","site":{"data":{}},"updated":"2022-09-20T02:19:29.983Z","author":"Sunfy","comments":true,"path":"api/articles/resource-Spring-Spring-SpringBean的生命周期详解.json","webPath":"2021/09/09/resource-Spring-Spring-SpringBean的生命周期详解/","permalink":"https://sunfy9.gitee.io/2021/09/09/resource-Spring-Spring-SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/","excerpt":null,"covers":["../../../../img/SpringBean的生命周期详解/image-20210914143837446.png","../../../../img/SpringBean的生命周期详解/image-20210909101911892.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"Spring中Bean的生成过程\"><a href=\"#Spring中Bean的生成过程\" class=\"headerlink\" title=\"Spring中Bean的生成过程\"></a>Spring中Bean的生成过程</h1><p>先从整理看下，Bean的生成过程中都包含了哪些步骤。</p>\n<blockquote>\n<p>生成<code>BeanDefinition</code></p>\n<p>合成<code>BeanDefinition</code></p>\n<p>加载类</p>\n<p>实例化前</p>\n<p>实例化</p>\n<p><code>BeanDefinition</code>的后置处理</p>\n<p>实例化后</p>\n<p>自动注入</p>\n<p>处理属性</p>\n<p>执行Aware</p>\n<p>初始化前</p>\n<p>初始化</p>\n<p>初始化后</p>\n</blockquote>\n<p><a href=\"/img/image-20210914143837446.png\">Bean生命周期流程图</a></p>\n<p><img src=\"../../../../img/SpringBean的生命周期详解/image-20210914143837446.png\" alt=\"image-20210914143837446\"></p>\n<ul>\n<li>InstantiationAwareBeanPostProcessor.postProcessBeforeinstantiation()</li>\n<li>实例化</li>\n<li>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</li>\n<li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(bean)</li>\n<li>属性赋值（Spring自带的依赖注入）</li>\n<li>InstantiationAwareBeanPostProcessor.postProcessProperties(@Autowired)</li>\n<li>初始化前</li>\n<li>初始化</li>\n<li>初始化后<sunfy-line></li>\n</ul>\n<p>首先我们了解到的，在Spring的启动过程中，针对bean的处理主要做了两个方面的</p>\n<ul>\n<li>扫描指定路径</li>\n<li>实例化bean（此处的实例化准确的说是实例化非懒加载的单例bean）。</li>\n</ul>\n<p>那我们先来分析，Spring是如何去扫描路径、加载所需要的class文件。</p>\n<p>从Spring启动过程来看，在refresh方法中，<code>invokeBeanFactoryPostProcessors(beanFactory)</code>中会调用<code>Scanner.scan</code>方法，进行bean的扫描，<code>finishBeanFactoryInitialization</code>中对扫描到的bean进行真正的实例化，完成bean工厂的初始化。</p>\n<h2 id=\"扫描\"><a href=\"#扫描\" class=\"headerlink\" title=\"扫描\"></a>扫描</h2><p>先看下扫描方法的调用栈信息</p>\n<p><img src=\"../../../../img/SpringBean的生命周期详解/image-20210909101911892.png\" alt=\"image-20210909101911892\"></p>\n<p>看代码</p>\n<p><code>ClassPathScanningCandidateComponentProvider.scanCandidateComponents</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;BeanDefinition&gt; <span class=\"title\">scanCandidateComponents</span><span class=\"params\">(String basePackage)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;BeanDefinition&gt; candidates = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取资源文件，扫描所有文件资源</span></span><br><span class=\"line\">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class=\"line\">            resolveBasePackage(basePackage) + <span class=\"string\">'/'</span> + <span class=\"keyword\">this</span>.resourcePattern;</span><br><span class=\"line\">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Resource resource : resources) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                logger.trace(<span class=\"string\">\"Scanning \"</span> + resource);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resource.isReadable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 元数据读取器，读取当前类的基本信息（ASM技术）</span></span><br><span class=\"line\">                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class=\"line\">                    <span class=\"comment\">// excludeFilters和includeFilters判断</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class=\"line\">                        ScannedGenericBeanDefinition sbd = <span class=\"keyword\">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class=\"line\">                        sbd.setSource(resource);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (debugEnabled) &#123;</span><br><span class=\"line\">                                logger.debug(<span class=\"string\">\"Identified candidate component class: \"</span> + resource);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            candidates.add(sbd);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (debugEnabled) &#123;</span><br><span class=\"line\">                                logger.debug(<span class=\"string\">\"Ignored because not a concrete top-level class: \"</span> + resource);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                            logger.trace(<span class=\"string\">\"Ignored because not matching any filter: \"</span> + resource);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanDefinitionStoreException(</span><br><span class=\"line\">                        <span class=\"string\">\"Failed to read candidate component class: \"</span> + resource, ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                    logger.trace(<span class=\"string\">\"Ignored because not readable: \"</span> + resource);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanDefinitionStoreException(<span class=\"string\">\"I/O failure during classpath scanning\"</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidates;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中读取到了传入路径的所有class文件，并按照需要进行了路径处理。然后遍历所有文件，通过元数据读取器，遍历读取每一个文件的元数据信息，然后根据元数据信息判断当前类是否需要注册成为一个bean，最终返回。</p>\n<p>在遍历元数据时，实现了<code>excludeFilters和includeFilters</code>判断，其中<code>Conditional</code>条件加载功能也在这块进行了实现，<code>Conditional</code>注解在我们实际使用中不多，但是在SpringBoot源码中使用的会很多。<code>Conditional</code>实现方式也很简单，创建一个类实现<code>Condition</code>接口，实现其中的<code>matches</code>方法，根据需要判断是否加载某个类就可以，在spring启动加载的时候，会根据某个类中是否添加了<code>@Conditional</code>，如果有则会调用注解中指明的类实现的<code>matches</code>方法。</p>\n<p>源码中的位置在<code>ConditionEvaluator.shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)</code>，具体代码就不贴了，有兴趣的可以直接从源码中找到。</p>\n<p>返回到上面的代码中，判断了当前class是一个bean之后，就开始创建<code>beanDefinition</code>，new 除 <code>beanDefinition</code>并做基本的属性赋值，然后又再一次判断了当前的bean是不是内部类、接口、抽象类、或者是（是一个抽象类，同时该类中具有被Lookup注解的方法），根据判断结果决定是否要将当前的类加入到最终返回的<code>candidates</code>对象中。</p>\n<p>这样基本的<code>BeanDefinition</code>就完成了，在扫描过程中涉及到了<code>Lookup</code>注解的使用。但是到目前为止，<code>beanDefinition</code>中大部分属性还没有赋值，目前主要是保存了beanClass内容。</p>\n<p>得到<code>BeanDefinition</code>的set集合后，接下来就需要遍历，然后对<code>BeanDefinition</code>中的属性进行赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历BeanDefinition,对其属性进行赋值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class=\"line\">    ScopeMetadata scopeMetadata = <span class=\"keyword\">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class=\"line\">    <span class=\"comment\">// 赋值scope</span></span><br><span class=\"line\">    candidate.setScope(scopeMetadata.getScopeName());</span><br><span class=\"line\">    String beanName = <span class=\"keyword\">this</span>.beanNameGenerator.generateBeanName(candidate, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidate <span class=\"keyword\">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class=\"line\">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidate <span class=\"keyword\">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析@lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class=\"line\">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class=\"line\">        BeanDefinitionHolder definitionHolder = <span class=\"keyword\">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class=\"line\">        definitionHolder =</span><br><span class=\"line\">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">        beanDefinitions.add(definitionHolder);</span><br><span class=\"line\">        registerBeanDefinition(definitionHolder, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个里面有一个细节，在生成beanName的时候，如果我们定义的BeanName名称首字母大写，且第二个字符小写的时候会将首字母小写作为默认的BeanName，但是如果第一个字母和第二个字母都是大写则不会处理。</p>\n<p>例如：User —&gt; user URL —&gt; URL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成默认的beanName，在生成默认的beanName之前会先判断自定义类的注解中是否有手动设置beanName</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">buildDefaultBeanName</span><span class=\"params\">(BeanDefinition definition)</span> </span>&#123;</span><br><span class=\"line\">    String beanClassName = definition.getBeanClassName();</span><br><span class=\"line\">    Assert.state(beanClassName != <span class=\"keyword\">null</span>, <span class=\"string\">\"No bean class name set\"</span>);</span><br><span class=\"line\">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class=\"line\">    <span class=\"comment\">// 判断首字母大写，但是字符开始有多个大写时不做操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如  User --&gt; user URL --&gt; URL</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Introspector.decapitalize(shortClassName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：下面这个方法是jdk中自带的方法，并不是spring中所提供的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">decapitalize</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class=\"number\">1</span>)) &amp;&amp;</span><br><span class=\"line\">        Character.isUpperCase(name.charAt(<span class=\"number\">0</span>)))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> chars[] = name.toCharArray();</span><br><span class=\"line\">    chars[<span class=\"number\">0</span>] = Character.toLowerCase(chars[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(chars);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这，所有的扫描工作就告一段落了。</p>\n<h2 id=\"生成BeanDefinition\"><a href=\"#生成BeanDefinition\" class=\"headerlink\" title=\"生成BeanDefinition\"></a>生成BeanDefinition</h2><p>Spring启动的时候会进行扫描，会先调用<code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents(String basePackage)</code> 扫描某个包路径，并得到BeanDefinition的Set集合。 </p>\n<p>Spring扫描底层流程：</p>\n<ul>\n<li>首先，通过ResourcePatternResolver获得指定包路径下的所有<code>.class</code>文件（Spring源码中将此文件包装成了Resource对象）</li>\n<li>遍历每个Resource对象</li>\n<li>利用MetadataReaderFactory解析Resource对象得到MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为SimpleMetadataReader）</li>\n<li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li>\n<li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li>\n<li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li>\n<li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li>\n</ul>\n<p>MetadataReader表示类的元数据读取器，主要包含了一个AnnotationMetadata，功能有</p>\n<ul>\n<li>获取类的名字、</li>\n<li>获取父类的名字</li>\n<li>获取所实现的所有接口名</li>\n<li>获取所有内部类的名字</li>\n<li>判断是不是抽象类</li>\n<li>判断是不是接口</li>\n<li>判断是不是一个注解</li>\n<li>获取拥有某个注解的方法集合</li>\n<li>获取类上添加的所有注解信息</li>\n<li>获取类上添加的所有注解类型集合</li>\n</ul>\n<p>值得注意的是，CachingMetadataReaderFactory解析某个.class文件得到MetadataReader对象是利用的<strong>ASM</strong>技术，并没有加载这个类到JVM。并且，最终得到的ScannedGenericBeanDefinition对象，<strong>beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象） </p>\n<p>最后，上面是说的通过扫描得到BeanDefinition对象，我们还可以通过直接定义BeanDefinition，或解析spring.xml文件的&lt;bean/&gt;，或者@Bean注解得到BeanDefinition对象。（后续课程会分析@Bean注解是怎么生成BeanDefinition的）。</p>\n<p>实例化非懒加载的Bean查看入口<code>finishBeanFactoryInitialization(beanFactory</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//循环我们所有的bean定义名称</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获得合并后的bean定义，这个合并的RootBeanDefinition是判断当前的bean是不是存在父子关系的bean，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果存在父bean那就会继承父类中的属性，但是如果自己本身也有定义的还是会使用自身配置的属性</span></span><br><span class=\"line\">    <span class=\"comment\">// 子类和父类合并后会生成一个新的BeanDefinition</span></span><br><span class=\"line\">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据bean定义判断是不是抽象的&amp;&amp; 不是单例的 &amp;&amp;不是懒加载的</span></span><br><span class=\"line\"><span class=\"comment\">     * 此处判断的是BeanDefinite是不是抽象的，和Bean没有关系</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个是在xml文件配置的时候，设置abstract=\"true\",如果有以上配置那对应的beanDefinite将会是抽象的</span></span><br><span class=\"line\"><span class=\"comment\">     * 抽象bean的作用，如果是抽象的，首先是不会去创建bean对象的</span></span><br><span class=\"line\"><span class=\"comment\">     * 还有一个就是抽象的beanDefinite自己不会创建Bean对象，但是可以集成给别的bean去用，xml配置文件中配置parent=“xxx抽象bean定义”</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//是不是工厂bean</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class=\"line\">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class=\"line\">            <span class=\"comment\">//是的话 给beanName+前缀&amp;符号</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> FactoryBean) &#123;</span><br><span class=\"line\">                FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEagerInit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span> &amp;&amp; factory <span class=\"keyword\">instanceof</span> SmartFactoryBean) &#123;</span><br><span class=\"line\">                    isEagerInit = AccessController.doPrivileged(</span><br><span class=\"line\">                        (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class=\"line\">                        getAccessControlContext());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 判断是否实现了SmartFactoryBean，如果实现了这个接口，就可以重写isEagerInit()返回true,在Spring容器创建的过程中就可以做一些事情</span></span><br><span class=\"line\">                    isEagerInit = (factory <span class=\"keyword\">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class=\"line\">                                   ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//调用真正的getBean的流程</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isEagerInit) &#123;</span><br><span class=\"line\">                    getBean(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//非工厂Bean 就是普通的bean</span></span><br><span class=\"line\">            getBean(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一遍历所有的beanNames，首先此处有一个概念是<code>RootBeanDefinition</code>，获得合并后的bean定义</p>\n<h2 id=\"合并BeanDefinition\"><a href=\"#合并BeanDefinition\" class=\"headerlink\" title=\"合并BeanDefinition\"></a>合并BeanDefinition</h2><p>通过扫描得到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了，但是在Spring中支持父子BeanDefinition，和Java父子类类似，但是完全不是一回事。</p>\n<p>父子BeanDefinition实际用的比较少，使用是这样的，比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Parent\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Child\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这么定义的情况下，child是单例Bean。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Parent\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Child\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"parent\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是这么定义的情况下，child就是原型Bean了。 </p>\n<p>因为child的父BeanDefinition是parent，所以会继承parent上所定义的scope属性。 </p>\n<p>而在根据child来生成Bean对象之前，需要进行BeanDefinition的合并，得到完整的child的BeanDefinition。 </p>\n<p>再次遍历所有的bean，是否实现了SmartInitializingSingleton接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所有的bean的名称</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里所有的单实例的bean已经记载到单实例bean到缓存中</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从单例缓存池中获取所有的对象</span></span><br><span class=\"line\">    Object singletonInstance = getSingleton(beanName);</span><br><span class=\"line\">    <span class=\"comment\">//判断当前的bean是否实现了SmartInitializingSingleton接口</span></span><br><span class=\"line\">    <span class=\"comment\">// sunfy- 这个也是Spring提供的一个扩展点之一，在所有的非懒加载的单例bean都创建完成之后会调用的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonInstance <span class=\"keyword\">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class=\"line\">        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class=\"line\">        <span class=\"comment\">// 安全管理器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class=\"line\">                smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;, getAccessControlContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//触发实例化之后的方法afterSingletonsInstantiated</span></span><br><span class=\"line\">            smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"加载类\"><a href=\"#加载类\" class=\"headerlink\" title=\"加载类\"></a>加载类</h2><p>BeanDefinition合并之后，就可以去创建Bean对象了，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure>\n<p>这行代码就是去加载类，该方法是这么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mbd.getBeanClass();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class=\"line\">\t\tdoResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasBeanClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.beanClass <span class=\"keyword\">instanceof</span> Class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果beanClass属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）</p>\n<p>会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用<strong>ClassUtils.getDefaultClassLoader()</strong>所返回的类加载器来加载。</p>\n<h3 id=\"ClassUtils-getDefaultClassLoader\"><a href=\"#ClassUtils-getDefaultClassLoader\" class=\"headerlink\" title=\"ClassUtils.getDefaultClassLoader()\"></a><strong>ClassUtils.getDefaultClassLoader()</strong></h3><ul>\n<li>优先返回当前线程中的ClassLoader</li>\n<li>线程中类加载器为null的情况下，返回ClassUtils类的类加载器</li>\n<li>如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器</li>\n</ul>\n","more":"<h1 id=\"Spring中Bean的生成过程\"><a href=\"#Spring中Bean的生成过程\" class=\"headerlink\" title=\"Spring中Bean的生成过程\"></a>Spring中Bean的生成过程</h1><p>先从整理看下，Bean的生成过程中都包含了哪些步骤。</p>\n<blockquote>\n<p>生成<code>BeanDefinition</code></p>\n<p>合成<code>BeanDefinition</code></p>\n<p>加载类</p>\n<p>实例化前</p>\n<p>实例化</p>\n<p><code>BeanDefinition</code>的后置处理</p>\n<p>实例化后</p>\n<p>自动注入</p>\n<p>处理属性</p>\n<p>执行Aware</p>\n<p>初始化前</p>\n<p>初始化</p>\n<p>初始化后</p>\n</blockquote>\n<p><a href=\"/img/image-20210914143837446.png\">Bean生命周期流程图</a></p>\n<p><img src=\"../../../../img/SpringBean的生命周期详解/image-20210914143837446.png\" alt=\"image-20210914143837446\"></p>\n<ul>\n<li>InstantiationAwareBeanPostProcessor.postProcessBeforeinstantiation()</li>\n<li>实例化</li>\n<li>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</li>\n<li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(bean)</li>\n<li>属性赋值（Spring自带的依赖注入）</li>\n<li>InstantiationAwareBeanPostProcessor.postProcessProperties(@Autowired)</li>\n<li>初始化前</li>\n<li>初始化</li>\n<li>初始化后<sunfy-line></li>\n</ul>\n<p>首先我们了解到的，在Spring的启动过程中，针对bean的处理主要做了两个方面的</p>\n<ul>\n<li>扫描指定路径</li>\n<li>实例化bean（此处的实例化准确的说是实例化非懒加载的单例bean）。</li>\n</ul>\n<p>那我们先来分析，Spring是如何去扫描路径、加载所需要的class文件。</p>\n<p>从Spring启动过程来看，在refresh方法中，<code>invokeBeanFactoryPostProcessors(beanFactory)</code>中会调用<code>Scanner.scan</code>方法，进行bean的扫描，<code>finishBeanFactoryInitialization</code>中对扫描到的bean进行真正的实例化，完成bean工厂的初始化。</p>\n<h2 id=\"扫描\"><a href=\"#扫描\" class=\"headerlink\" title=\"扫描\"></a>扫描</h2><p>先看下扫描方法的调用栈信息</p>\n<p><img src=\"../../../../img/SpringBean的生命周期详解/image-20210909101911892.png\" alt=\"image-20210909101911892\"></p>\n<p>看代码</p>\n<p><code>ClassPathScanningCandidateComponentProvider.scanCandidateComponents</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;BeanDefinition&gt; <span class=\"title\">scanCandidateComponents</span><span class=\"params\">(String basePackage)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;BeanDefinition&gt; candidates = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取资源文件，扫描所有文件资源</span></span><br><span class=\"line\">        String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class=\"line\">            resolveBasePackage(basePackage) + <span class=\"string\">'/'</span> + <span class=\"keyword\">this</span>.resourcePattern;</span><br><span class=\"line\">        Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Resource resource : resources) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                logger.trace(<span class=\"string\">\"Scanning \"</span> + resource);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resource.isReadable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 元数据读取器，读取当前类的基本信息（ASM技术）</span></span><br><span class=\"line\">                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class=\"line\">                    <span class=\"comment\">// excludeFilters和includeFilters判断</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class=\"line\">                        ScannedGenericBeanDefinition sbd = <span class=\"keyword\">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class=\"line\">                        sbd.setSource(resource);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (debugEnabled) &#123;</span><br><span class=\"line\">                                logger.debug(<span class=\"string\">\"Identified candidate component class: \"</span> + resource);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            candidates.add(sbd);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (debugEnabled) &#123;</span><br><span class=\"line\">                                logger.debug(<span class=\"string\">\"Ignored because not a concrete top-level class: \"</span> + resource);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                            logger.trace(<span class=\"string\">\"Ignored because not matching any filter: \"</span> + resource);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanDefinitionStoreException(</span><br><span class=\"line\">                        <span class=\"string\">\"Failed to read candidate component class: \"</span> + resource, ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (traceEnabled) &#123;</span><br><span class=\"line\">                    logger.trace(<span class=\"string\">\"Ignored because not readable: \"</span> + resource);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanDefinitionStoreException(<span class=\"string\">\"I/O failure during classpath scanning\"</span>, ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidates;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中读取到了传入路径的所有class文件，并按照需要进行了路径处理。然后遍历所有文件，通过元数据读取器，遍历读取每一个文件的元数据信息，然后根据元数据信息判断当前类是否需要注册成为一个bean，最终返回。</p>\n<p>在遍历元数据时，实现了<code>excludeFilters和includeFilters</code>判断，其中<code>Conditional</code>条件加载功能也在这块进行了实现，<code>Conditional</code>注解在我们实际使用中不多，但是在SpringBoot源码中使用的会很多。<code>Conditional</code>实现方式也很简单，创建一个类实现<code>Condition</code>接口，实现其中的<code>matches</code>方法，根据需要判断是否加载某个类就可以，在spring启动加载的时候，会根据某个类中是否添加了<code>@Conditional</code>，如果有则会调用注解中指明的类实现的<code>matches</code>方法。</p>\n<p>源码中的位置在<code>ConditionEvaluator.shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)</code>，具体代码就不贴了，有兴趣的可以直接从源码中找到。</p>\n<p>返回到上面的代码中，判断了当前class是一个bean之后，就开始创建<code>beanDefinition</code>，new 除 <code>beanDefinition</code>并做基本的属性赋值，然后又再一次判断了当前的bean是不是内部类、接口、抽象类、或者是（是一个抽象类，同时该类中具有被Lookup注解的方法），根据判断结果决定是否要将当前的类加入到最终返回的<code>candidates</code>对象中。</p>\n<p>这样基本的<code>BeanDefinition</code>就完成了，在扫描过程中涉及到了<code>Lookup</code>注解的使用。但是到目前为止，<code>beanDefinition</code>中大部分属性还没有赋值，目前主要是保存了beanClass内容。</p>\n<p>得到<code>BeanDefinition</code>的set集合后，接下来就需要遍历，然后对<code>BeanDefinition</code>中的属性进行赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历BeanDefinition,对其属性进行赋值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class=\"line\">    ScopeMetadata scopeMetadata = <span class=\"keyword\">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class=\"line\">    <span class=\"comment\">// 赋值scope</span></span><br><span class=\"line\">    candidate.setScope(scopeMetadata.getScopeName());</span><br><span class=\"line\">    String beanName = <span class=\"keyword\">this</span>.beanNameGenerator.generateBeanName(candidate, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidate <span class=\"keyword\">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class=\"line\">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (candidate <span class=\"keyword\">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析@lazy、@Primary、@DependsOn、@Role、@Description</span></span><br><span class=\"line\">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class=\"line\">        BeanDefinitionHolder definitionHolder = <span class=\"keyword\">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class=\"line\">        definitionHolder =</span><br><span class=\"line\">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">        beanDefinitions.add(definitionHolder);</span><br><span class=\"line\">        registerBeanDefinition(definitionHolder, <span class=\"keyword\">this</span>.registry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个里面有一个细节，在生成beanName的时候，如果我们定义的BeanName名称首字母大写，且第二个字符小写的时候会将首字母小写作为默认的BeanName，但是如果第一个字母和第二个字母都是大写则不会处理。</p>\n<p>例如：User —&gt; user URL —&gt; URL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成默认的beanName，在生成默认的beanName之前会先判断自定义类的注解中是否有手动设置beanName</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">buildDefaultBeanName</span><span class=\"params\">(BeanDefinition definition)</span> </span>&#123;</span><br><span class=\"line\">    String beanClassName = definition.getBeanClassName();</span><br><span class=\"line\">    Assert.state(beanClassName != <span class=\"keyword\">null</span>, <span class=\"string\">\"No bean class name set\"</span>);</span><br><span class=\"line\">    String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class=\"line\">    <span class=\"comment\">// 判断首字母大写，但是字符开始有多个大写时不做操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如  User --&gt; user URL --&gt; URL</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Introspector.decapitalize(shortClassName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意：下面这个方法是jdk中自带的方法，并不是spring中所提供的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">decapitalize</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">1</span> &amp;&amp; Character.isUpperCase(name.charAt(<span class=\"number\">1</span>)) &amp;&amp;</span><br><span class=\"line\">        Character.isUpperCase(name.charAt(<span class=\"number\">0</span>)))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> chars[] = name.toCharArray();</span><br><span class=\"line\">    chars[<span class=\"number\">0</span>] = Character.toLowerCase(chars[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(chars);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这，所有的扫描工作就告一段落了。</p>\n<h2 id=\"生成BeanDefinition\"><a href=\"#生成BeanDefinition\" class=\"headerlink\" title=\"生成BeanDefinition\"></a>生成BeanDefinition</h2><p>Spring启动的时候会进行扫描，会先调用<code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents(String basePackage)</code> 扫描某个包路径，并得到BeanDefinition的Set集合。 </p>\n<p>Spring扫描底层流程：</p>\n<ul>\n<li>首先，通过ResourcePatternResolver获得指定包路径下的所有<code>.class</code>文件（Spring源码中将此文件包装成了Resource对象）</li>\n<li>遍历每个Resource对象</li>\n<li>利用MetadataReaderFactory解析Resource对象得到MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为SimpleMetadataReader）</li>\n<li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li>\n<li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li>\n<li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li>\n<li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li>\n</ul>\n<p>MetadataReader表示类的元数据读取器，主要包含了一个AnnotationMetadata，功能有</p>\n<ul>\n<li>获取类的名字、</li>\n<li>获取父类的名字</li>\n<li>获取所实现的所有接口名</li>\n<li>获取所有内部类的名字</li>\n<li>判断是不是抽象类</li>\n<li>判断是不是接口</li>\n<li>判断是不是一个注解</li>\n<li>获取拥有某个注解的方法集合</li>\n<li>获取类上添加的所有注解信息</li>\n<li>获取类上添加的所有注解类型集合</li>\n</ul>\n<p>值得注意的是，CachingMetadataReaderFactory解析某个.class文件得到MetadataReader对象是利用的<strong>ASM</strong>技术，并没有加载这个类到JVM。并且，最终得到的ScannedGenericBeanDefinition对象，<strong>beanClass属性存储的是当前类的名字，而不是class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象） </p>\n<p>最后，上面是说的通过扫描得到BeanDefinition对象，我们还可以通过直接定义BeanDefinition，或解析spring.xml文件的&lt;bean/&gt;，或者@Bean注解得到BeanDefinition对象。（后续课程会分析@Bean注解是怎么生成BeanDefinition的）。</p>\n<p>实例化非懒加载的Bean查看入口<code>finishBeanFactoryInitialization(beanFactory</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//循环我们所有的bean定义名称</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获得合并后的bean定义，这个合并的RootBeanDefinition是判断当前的bean是不是存在父子关系的bean，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果存在父bean那就会继承父类中的属性，但是如果自己本身也有定义的还是会使用自身配置的属性</span></span><br><span class=\"line\">    <span class=\"comment\">// 子类和父类合并后会生成一个新的BeanDefinition</span></span><br><span class=\"line\">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据bean定义判断是不是抽象的&amp;&amp; 不是单例的 &amp;&amp;不是懒加载的</span></span><br><span class=\"line\"><span class=\"comment\">     * 此处判断的是BeanDefinite是不是抽象的，和Bean没有关系</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个是在xml文件配置的时候，设置abstract=\"true\",如果有以上配置那对应的beanDefinite将会是抽象的</span></span><br><span class=\"line\"><span class=\"comment\">     * 抽象bean的作用，如果是抽象的，首先是不会去创建bean对象的</span></span><br><span class=\"line\"><span class=\"comment\">     * 还有一个就是抽象的beanDefinite自己不会创建Bean对象，但是可以集成给别的bean去用，xml配置文件中配置parent=“xxx抽象bean定义”</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//是不是工厂bean</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class=\"line\">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class=\"line\">            <span class=\"comment\">//是的话 给beanName+前缀&amp;符号</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> FactoryBean) &#123;</span><br><span class=\"line\">                FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> isEagerInit;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span> &amp;&amp; factory <span class=\"keyword\">instanceof</span> SmartFactoryBean) &#123;</span><br><span class=\"line\">                    isEagerInit = AccessController.doPrivileged(</span><br><span class=\"line\">                        (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class=\"line\">                        getAccessControlContext());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 判断是否实现了SmartFactoryBean，如果实现了这个接口，就可以重写isEagerInit()返回true,在Spring容器创建的过程中就可以做一些事情</span></span><br><span class=\"line\">                    isEagerInit = (factory <span class=\"keyword\">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class=\"line\">                                   ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//调用真正的getBean的流程</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isEagerInit) &#123;</span><br><span class=\"line\">                    getBean(beanName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//非工厂Bean 就是普通的bean</span></span><br><span class=\"line\">            getBean(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一遍历所有的beanNames，首先此处有一个概念是<code>RootBeanDefinition</code>，获得合并后的bean定义</p>\n<h2 id=\"合并BeanDefinition\"><a href=\"#合并BeanDefinition\" class=\"headerlink\" title=\"合并BeanDefinition\"></a>合并BeanDefinition</h2><p>通过扫描得到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了，但是在Spring中支持父子BeanDefinition，和Java父子类类似，但是完全不是一回事。</p>\n<p>父子BeanDefinition实际用的比较少，使用是这样的，比如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Parent\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Child\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这么定义的情况下，child是单例Bean。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Parent\"</span> <span class=\"attr\">scope</span>=<span class=\"string\">\"prototype\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sunfy.service.Child\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"parent\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是这么定义的情况下，child就是原型Bean了。 </p>\n<p>因为child的父BeanDefinition是parent，所以会继承parent上所定义的scope属性。 </p>\n<p>而在根据child来生成Bean对象之前，需要进行BeanDefinition的合并，得到完整的child的BeanDefinition。 </p>\n<p>再次遍历所有的bean，是否实现了SmartInitializingSingleton接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所有的bean的名称</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里所有的单实例的bean已经记载到单实例bean到缓存中</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String beanName : beanNames) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从单例缓存池中获取所有的对象</span></span><br><span class=\"line\">    Object singletonInstance = getSingleton(beanName);</span><br><span class=\"line\">    <span class=\"comment\">//判断当前的bean是否实现了SmartInitializingSingleton接口</span></span><br><span class=\"line\">    <span class=\"comment\">// sunfy- 这个也是Spring提供的一个扩展点之一，在所有的非懒加载的单例bean都创建完成之后会调用的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singletonInstance <span class=\"keyword\">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class=\"line\">        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class=\"line\">        <span class=\"comment\">// 安全管理器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class=\"line\">                smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;, getAccessControlContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//触发实例化之后的方法afterSingletonsInstantiated</span></span><br><span class=\"line\">            smartSingleton.afterSingletonsInstantiated();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"加载类\"><a href=\"#加载类\" class=\"headerlink\" title=\"加载类\"></a>加载类</h2><p>BeanDefinition合并之后，就可以去创建Bean对象了，而创建Bean就必须实例化对象，而实例化就必须先加载当前BeanDefinition所对应的class，在AbstractAutowireCapableBeanFactory类的createBean()方法中，一开始就会调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure>\n<p>这行代码就是去加载类，该方法是这么实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mbd.getBeanClass();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (System.getSecurityManager() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;</span><br><span class=\"line\">\t\tdoResolveBeanClass(mbd, typesToMatch), getAccessControlContext());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasBeanClass</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.beanClass <span class=\"keyword\">instanceof</span> Class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果beanClass属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）</p>\n<p>会利用BeanFactory所设置的类加载器来加载类，如果没有设置，则默认使用<strong>ClassUtils.getDefaultClassLoader()</strong>所返回的类加载器来加载。</p>\n<h3 id=\"ClassUtils-getDefaultClassLoader\"><a href=\"#ClassUtils-getDefaultClassLoader\" class=\"headerlink\" title=\"ClassUtils.getDefaultClassLoader()\"></a><strong>ClassUtils.getDefaultClassLoader()</strong></h3><ul>\n<li>优先返回当前线程中的ClassLoader</li>\n<li>线程中类加载器为null的情况下，返回ClassUtils类的类加载器</li>\n<li>如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器</li>\n</ul>\n","next":{"title":"Spring底层核心原理","path":"api/articles/resource-Spring-Spring-Spring底层核心原理.json","image":"/img/header_img/spring/Principles.PNG","num_read":59,"num_like":395,"num_collection":390,"num_comments":69},"prev":{"title":"Spring依赖注入方式和源码分析","path":"api/articles/resource-Spring-Spring-Spring依赖注入方式和源码分析.json","image":"/img/header_img/spring/DependencyInjection.png","num_read":751,"num_like":260,"num_collection":530,"num_comments":129},"categories":[{"name":"Spring全家桶","path":"api/categories/Spring全家桶.json","pathContent":"api/categories/Spring全家桶","description":"更快、更容易、更安全","cover":"https://sunfy9.gitee.io/project/photo/project/spring.png"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json","pathContent":"api/tags/Spring","description":"更快、更容易、更安全","cover":"https://sunfy9.gitee.io/project/photo/project/spring.png"}]}