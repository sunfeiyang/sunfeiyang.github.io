{"title":"并发的可见性深入分析","num_read":1607,"num_like":510,"num_collection":403,"num_comments":225,"slug":"resource-java-concurrent-visibility","date":"2021-10-25T16:00:00.000Z","img":"/img/header_img/concurrent/visibility.png","_id":"clhrbp2dj008qo5lg7yya0tjn","project":"concurrent","type":"hot","subtitle":"一个线程修改了共享变量的值，其他线程能够看到修改的值","site":{"data":{}},"updated":"2022-09-19T14:44:01.724Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-visibility.json","webPath":"2021/10/26/resource-java-concurrent-visibility/","permalink":"https://sunfy9.gitee.io/2021/10/26/resource-java-concurrent-visibility/","excerpt":null,"covers":["../../../../img/visibility/image-20211028140628892.png","../../../../img/visibility/image-20211028142132716.png","../../../../img/visibility/image-20211028143531157.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"并发可见性\"><a href=\"#并发可见性\" class=\"headerlink\" title=\"并发可见性\"></a>并发可见性</h1><p>首先我们来回顾一下什么是并发，允许两个任务彼此干扰，同一时间点，只有一个任务运行，交替执行。</p>\n<p>正因为并发时两个任务交替执行，两个任务间的彼此干扰，我们假设一种场景，线程A和线程B共享一个成员变量，线程A基于共享变量判断当前程序执行情况，在线程B中可以修改成员变量的内容，那这个时候我们想要通过线程B对成员变量的修改，达到控制线程A执行的目的。</p>\n<p>那我们先写一个不加任何控制的代码，看能否实现我们的目的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> sunfy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@className</span> ThreadDemo</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-26 11:43</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 修改执行装置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeRun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        isRunning = !isRunning;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"改变执行状态，操作的线程为\"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 任务执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"线程正在执行中...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isRunning) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"线程执行结束。i=\"</span> + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ThreadDemo threadDemo = <span class=\"keyword\">new</span> ThreadDemo();</span><br><span class=\"line\">        <span class=\"comment\">// 线程A模拟线程执行</span></span><br><span class=\"line\">        Thread threadA = <span class=\"keyword\">new</span> Thread(() -&gt; threadDemo.run(), <span class=\"string\">\"threadA\"</span>);</span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 让线程A执行一段时间</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 线程B通过改变isRunning来控制threadA的执行情况</span></span><br><span class=\"line\">        Thread threadB = <span class=\"keyword\">new</span> Thread(() -&gt; threadDemo.changeRun(), <span class=\"string\">\"threadB\"</span>);</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<p><img src=\"../../../../img/visibility/image-20211028140628892.png\" alt=\"image-20211028140628892\"></p>\n<p>可以看到，最终并没有达到我们想要的效果，线程A持续在执行，并没有执行结束。</p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因<sunfy-line></h1><p>本篇我们主题就是说明并发的三大特性中的可见性，自然上述问题的根本原因就是因为线程A和线程B对成员变量<code>isRunning</code>的可见性问题导致。线程A运行中获取到成员变量的值，进入循环中执行，而在执行中线程B修改了成员变量的值，但是线程A并没有及时读取到线程B修改后的值，而是依然从线程A的本地内存中读取数据，自然就不会影响到线程A的执行情况了。</p>\n<p>那什么是可见性呢？</p>\n<p><strong>当一个线程修改了共享变量的值，其他线程能够看到修改的值。</strong></p>\n<p>java内存模型是通过变量修改后将新值同步回主内存，在变量读取前从内存刷新变量值依赖主内存作为传递媒介的方法来实现可见性的。</p>\n<h1 id=\"如何保证可见性\"><a href=\"#如何保证可见性\" class=\"headerlink\" title=\"如何保证可见性\"></a>如何保证可见性</h1><ul>\n<li>通过<code>volatile</code>关键字</li>\n<li>通过内存屏障保证可见性（Java级别）</li>\n<li>通过<code>synchronized</code>关键字保证可见性</li>\n<li>通过<code>Lock</code>保证可见性</li>\n<li>通过<code>final</code>关键字保证可见性</li>\n</ul>\n<h1 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h1><ul>\n<li>在上述代码中给成员变量添加<code>volatile</code>关键字，程序能够成功执行结束</li>\n</ul>\n<p><img src=\"../../../../img/visibility/image-20211028142132716.png\" alt=\"image-20211028142132716\"></p>\n<ul>\n<li><p>添加内存屏障</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnsafeFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Unsafe 对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title\">getUnsafe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnsafeFactory.getUnsafe.storeFence();</p>\n</blockquote>\n</li>\n<li><p>在循环中添加输出语句</p>\n<blockquote>\n<p>System.out.println(i);</p>\n</blockquote>\n<p>输出什么不重要，关键是有输出语句，这个之所以能解决，我们可以点进去看一下println中的代码</p>\n<p><img src=\"../../../../img/visibility/image-20211028143531157.png\" alt=\"image-20211028143531157\"></p>\n<p>可以看到是<code>synchronized</code>修饰的，正是因为这个关键字，才得以解决上述的问题。</p>\n</li>\n<li><p>主动调用<code>Thread.yield()</code>，主动调用释放时间片</p>\n</li>\n<li><p><code>LockSupport.unpark(Thread.currentThread());</code>，发放许可</p>\n</li>\n<li><p>将<code>int i</code>修改为成员变量并用<code>volatile</code>修饰</p>\n</li>\n<li><p>将int类型的i修改为Integer类型</p>\n</li>\n</ul>\n<p>上面的方案都是可以解决当前问题的，但是为什么呢？</p>\n<p>想要分析这个的原因，那我们首先需要了解<code>JMM</code>内存模型，这个的java的内存模型，是一种共享内存模型。每个线程都有自己的内存空间，用来存储成员变量的副本。</p>\n<p>通过内存模型中的，我们可以了解到，线程B在修改了内存变量的值后，线程A没有及时去从主内存中获取最新的值，而是从线程A的本地内存中读取缓存的变量值，就会出现问题。我们要解决问题，只需要让线程A的本地缓存失效，或者通过添加内存屏障、或者主动调用让线程A切换上下文，重新从主内存中获取最新的值。那就能解决问题了。</p>\n<p><code>volatile</code></p>\n<p><code>storeLoad JVM</code>内存屏障  —-&gt; (汇编层面指令)lock前缀指令: <code>lock addl $0, $0(%rsp)</code> </p>\n<p>lock前缀指令不是内存屏障的指令，但是有内存屏障的效果，缓存失效</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>java并发中可见性的保证？总的来说就是两种：</p>\n<ul>\n<li><code>jvm</code>层面 <code>storeLoad</code>内存屏障</li>\n<li>上下文切换 （<code>Thread.yield()</code>）</li>\n</ul>\n","more":"<h1 id=\"并发可见性\"><a href=\"#并发可见性\" class=\"headerlink\" title=\"并发可见性\"></a>并发可见性</h1><p>首先我们来回顾一下什么是并发，允许两个任务彼此干扰，同一时间点，只有一个任务运行，交替执行。</p>\n<p>正因为并发时两个任务交替执行，两个任务间的彼此干扰，我们假设一种场景，线程A和线程B共享一个成员变量，线程A基于共享变量判断当前程序执行情况，在线程B中可以修改成员变量的内容，那这个时候我们想要通过线程B对成员变量的修改，达到控制线程A执行的目的。</p>\n<p>那我们先写一个不加任何控制的代码，看能否实现我们的目的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> sunfy</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@className</span> ThreadDemo</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021-10-26 11:43</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 修改执行装置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeRun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        isRunning = !isRunning;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"改变执行状态，操作的线程为\"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 任务执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"线程正在执行中...\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (isRunning) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"线程执行结束。i=\"</span> + i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ThreadDemo threadDemo = <span class=\"keyword\">new</span> ThreadDemo();</span><br><span class=\"line\">        <span class=\"comment\">// 线程A模拟线程执行</span></span><br><span class=\"line\">        Thread threadA = <span class=\"keyword\">new</span> Thread(() -&gt; threadDemo.run(), <span class=\"string\">\"threadA\"</span>);</span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 让线程A执行一段时间</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 线程B通过改变isRunning来控制threadA的执行情况</span></span><br><span class=\"line\">        Thread threadB = <span class=\"keyword\">new</span> Thread(() -&gt; threadDemo.changeRun(), <span class=\"string\">\"threadB\"</span>);</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<p><img src=\"../../../../img/visibility/image-20211028140628892.png\" alt=\"image-20211028140628892\"></p>\n<p>可以看到，最终并没有达到我们想要的效果，线程A持续在执行，并没有执行结束。</p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因<sunfy-line></h1><p>本篇我们主题就是说明并发的三大特性中的可见性，自然上述问题的根本原因就是因为线程A和线程B对成员变量<code>isRunning</code>的可见性问题导致。线程A运行中获取到成员变量的值，进入循环中执行，而在执行中线程B修改了成员变量的值，但是线程A并没有及时读取到线程B修改后的值，而是依然从线程A的本地内存中读取数据，自然就不会影响到线程A的执行情况了。</p>\n<p>那什么是可见性呢？</p>\n<p><strong>当一个线程修改了共享变量的值，其他线程能够看到修改的值。</strong></p>\n<p>java内存模型是通过变量修改后将新值同步回主内存，在变量读取前从内存刷新变量值依赖主内存作为传递媒介的方法来实现可见性的。</p>\n<h1 id=\"如何保证可见性\"><a href=\"#如何保证可见性\" class=\"headerlink\" title=\"如何保证可见性\"></a>如何保证可见性</h1><ul>\n<li>通过<code>volatile</code>关键字</li>\n<li>通过内存屏障保证可见性（Java级别）</li>\n<li>通过<code>synchronized</code>关键字保证可见性</li>\n<li>通过<code>Lock</code>保证可见性</li>\n<li>通过<code>final</code>关键字保证可见性</li>\n</ul>\n<h1 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h1><ul>\n<li>在上述代码中给成员变量添加<code>volatile</code>关键字，程序能够成功执行结束</li>\n</ul>\n<p><img src=\"../../../../img/visibility/image-20211028142132716.png\" alt=\"image-20211028142132716\"></p>\n<ul>\n<li><p>添加内存屏障</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnsafeFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 Unsafe 对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title\">getUnsafe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");</span><br><span class=\"line\">            field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Unsafe) field.get(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>UnsafeFactory.getUnsafe.storeFence();</p>\n</blockquote>\n</li>\n<li><p>在循环中添加输出语句</p>\n<blockquote>\n<p>System.out.println(i);</p>\n</blockquote>\n<p>输出什么不重要，关键是有输出语句，这个之所以能解决，我们可以点进去看一下println中的代码</p>\n<p><img src=\"../../../../img/visibility/image-20211028143531157.png\" alt=\"image-20211028143531157\"></p>\n<p>可以看到是<code>synchronized</code>修饰的，正是因为这个关键字，才得以解决上述的问题。</p>\n</li>\n<li><p>主动调用<code>Thread.yield()</code>，主动调用释放时间片</p>\n</li>\n<li><p><code>LockSupport.unpark(Thread.currentThread());</code>，发放许可</p>\n</li>\n<li><p>将<code>int i</code>修改为成员变量并用<code>volatile</code>修饰</p>\n</li>\n<li><p>将int类型的i修改为Integer类型</p>\n</li>\n</ul>\n<p>上面的方案都是可以解决当前问题的，但是为什么呢？</p>\n<p>想要分析这个的原因，那我们首先需要了解<code>JMM</code>内存模型，这个的java的内存模型，是一种共享内存模型。每个线程都有自己的内存空间，用来存储成员变量的副本。</p>\n<p>通过内存模型中的，我们可以了解到，线程B在修改了内存变量的值后，线程A没有及时去从主内存中获取最新的值，而是从线程A的本地内存中读取缓存的变量值，就会出现问题。我们要解决问题，只需要让线程A的本地缓存失效，或者通过添加内存屏障、或者主动调用让线程A切换上下文，重新从主内存中获取最新的值。那就能解决问题了。</p>\n<p><code>volatile</code></p>\n<p><code>storeLoad JVM</code>内存屏障  —-&gt; (汇编层面指令)lock前缀指令: <code>lock addl $0, $0(%rsp)</code> </p>\n<p>lock前缀指令不是内存屏障的指令，但是有内存屏障的效果，缓存失效</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>java并发中可见性的保证？总的来说就是两种：</p>\n<ul>\n<li><code>jvm</code>层面 <code>storeLoad</code>内存屏障</li>\n<li>上下文切换 （<code>Thread.yield()</code>）</li>\n</ul>\n","next":{"title":"java内存模型（JMM）","path":"api/articles/resource-java-concurrent-JMM.json","image":"/img/header_img/concurrent/jmm.png","num_read":1057,"num_like":233,"num_collection":63,"num_comments":179},"prev":{"title":"并发线程池原理分析","path":"api/articles/resource-java-concurrent-threadPool.json","image":"/img/header_img/concurrent/threadpool.png","num_read":291,"num_like":583,"num_collection":394,"num_comments":121},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}