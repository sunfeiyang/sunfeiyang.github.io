{"title":"Java面试题002-说一下ThreadLocal","num_read":175,"num_like":795,"num_collection":357,"num_comments":226,"slug":"resource-java-Base-002ThreadLocal","date":"2021-07-13T16:00:00.000Z","img":"/img/header_img/2.jpg","_id":"clhrbp2dq00aho5lg69tc7wot","subtitle":"是什么--》底层实现--》优缺点--》应用场景","site":{"data":{}},"updated":"2022-09-19T14:59:36.322Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-Base-002ThreadLocal.json","webPath":"2021/07/14/resource-java-Base-002ThreadLocal/","permalink":"https://sunfy9.gitee.io/2021/07/14/resource-java-Base-002ThreadLocal/","excerpt":null,"covers":["../../../../img/002ThreadLocal/image-20210713231133655.png","../../../../img/002ThreadLocal/image-20210713232214175.png","../../../../img/002ThreadLocal/image-20210713233047404.png","../../../../img/002ThreadLocal/image-20210713233215930.png","../../../../img/002ThreadLocal/image-20210713232349257.png","../../../../img/002ThreadLocal/image-20210713232536975.png","../../../../img/002ThreadLocal/image-20210713234033492.png"],"keywords":"sunfy, hexo-theme-snail","content":"<p><strong>思路</strong></p>\n<p>是什么—》底层实现—》优缺点—》应用场景</p>\n<hr>\n<h2 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题\"></a>两个问题</h2><ul>\n<li>什么是<code>ThreadLocal</code>？<br><code>ThreadLocal</code>类顾名思义可以理解为线程本地变量。也就是说如果定义了一个<code>ThreadLocal</code>，每个线程往这个<code>ThreadLocal</code>中读写是线程隔离，互相之间不会影响的。它提供了一种将可变数据通过每个线程有自己的独立副本从而实现线程封闭的机制。</li>\n<li>它大致的实现思路是怎样的？<br>Thread类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。<code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的key视作<code>ThreadLocal</code>，value为代码中放入的值（实际上key并不是<code>ThreadLocal</code>本身，而是它的一个弱引用）。每个线程在往某个<code>ThreadLocal</code>里塞值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以某个<code>ThreadLocal</code>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li>\n</ul>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>ThreadLocal是java中的所提供的<strong>线程本地</strong>存储机制，可以利用该机制将某个数据、某个对象、某个值缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取到相应的内容。</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现<sunfy-line></h2><p>ThreadLocal底层通过<code>ThreadLocalMap</code>实现，每个<strong>Thread</strong>对象中都存在一个<code>ThreadLocalMap</code>，Map的key为ThreadLocal对象，Map的value为需要缓存的值。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>1、<code>ThreadLocalMap</code>对象存储在Thread对象中。<br><img src=\"../../../../img/002ThreadLocal/image-20210713231133655.png\" alt=\"image-20210713231133655\"></p>\n<p>2、存储形式</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232214175.png\" alt=\"image-20210713232214175\"></p>\n<h2 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h2><p>如果在线程池中使用<code>ThreadLocal</code>会造成内存泄露，因为当<code>ThreadLocal</code>对象使用完之后，应该把设置的key、value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏。</p>\n<p>解决方法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713233047404.png\" alt=\"image-20210713233047404\"></p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713233215930.png\" alt=\"image-20210713233215930\"></p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>1、使用的好处</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232349257.png\" alt=\"image-20210713232349257\"></p>\n<p>开启两个线程，一个是普通的Person类，一个使用<code>ThreaLocal</code>的，运行程度得到的结果</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232536975.png\" alt=\"image-20210713232536975\"></p>\n<p>2、强引用</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713234033492.png\" alt=\"image-20210713234033492\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p><code>ThreadLocal</code>经典的使用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）</p>\n<h3 id=\"场景1：\"><a href=\"#场景1：\" class=\"headerlink\" title=\"场景1：\"></a>场景1：</h3><p><code>ThreadLocal</code>用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p>\n<h3 id=\"场景2：\"><a href=\"#场景2：\" class=\"headerlink\" title=\"场景2：\"></a>场景2：</h3><p><code>ThreadLocal</code>用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过<code>ThreadLocal</code> 直接获取到，避免了传参，类似于全局变量的概念。</p>\n","more":"<p><strong>思路</strong></p>\n<p>是什么—》底层实现—》优缺点—》应用场景</p>\n<hr>\n<h2 id=\"两个问题\"><a href=\"#两个问题\" class=\"headerlink\" title=\"两个问题\"></a>两个问题</h2><ul>\n<li>什么是<code>ThreadLocal</code>？<br><code>ThreadLocal</code>类顾名思义可以理解为线程本地变量。也就是说如果定义了一个<code>ThreadLocal</code>，每个线程往这个<code>ThreadLocal</code>中读写是线程隔离，互相之间不会影响的。它提供了一种将可变数据通过每个线程有自己的独立副本从而实现线程封闭的机制。</li>\n<li>它大致的实现思路是怎样的？<br>Thread类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。<code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的key视作<code>ThreadLocal</code>，value为代码中放入的值（实际上key并不是<code>ThreadLocal</code>本身，而是它的一个弱引用）。每个线程在往某个<code>ThreadLocal</code>里塞值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以某个<code>ThreadLocal</code>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li>\n</ul>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p>ThreadLocal是java中的所提供的<strong>线程本地</strong>存储机制，可以利用该机制将某个数据、某个对象、某个值缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取到相应的内容。</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现<sunfy-line></h2><p>ThreadLocal底层通过<code>ThreadLocalMap</code>实现，每个<strong>Thread</strong>对象中都存在一个<code>ThreadLocalMap</code>，Map的key为ThreadLocal对象，Map的value为需要缓存的值。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>1、<code>ThreadLocalMap</code>对象存储在Thread对象中。<br><img src=\"../../../../img/002ThreadLocal/image-20210713231133655.png\" alt=\"image-20210713231133655\"></p>\n<p>2、存储形式</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232214175.png\" alt=\"image-20210713232214175\"></p>\n<h2 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h2><p>如果在线程池中使用<code>ThreadLocal</code>会造成内存泄露，因为当<code>ThreadLocal</code>对象使用完之后，应该把设置的key、value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏。</p>\n<p>解决方法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713233047404.png\" alt=\"image-20210713233047404\"></p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713233215930.png\" alt=\"image-20210713233215930\"></p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>1、使用的好处</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232349257.png\" alt=\"image-20210713232349257\"></p>\n<p>开启两个线程，一个是普通的Person类，一个使用<code>ThreaLocal</code>的，运行程度得到的结果</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713232536975.png\" alt=\"image-20210713232536975\"></p>\n<p>2、强引用</p>\n<p><img src=\"../../../../img/002ThreadLocal/image-20210713234033492.png\" alt=\"image-20210713234033492\"></p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p><code>ThreadLocal</code>经典的使用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同方法之间进行传递，线程之间不共享同一个连接）</p>\n<h3 id=\"场景1：\"><a href=\"#场景1：\" class=\"headerlink\" title=\"场景1：\"></a>场景1：</h3><p><code>ThreadLocal</code>用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。</p>\n<h3 id=\"场景2：\"><a href=\"#场景2：\" class=\"headerlink\" title=\"场景2：\"></a>场景2：</h3><p><code>ThreadLocal</code>用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过<code>ThreadLocal</code> 直接获取到，避免了传参，类似于全局变量的概念。</p>\n","next":{"title":"算法常用的解题思路---滑动窗口","path":"api/articles/resource-java-algorithm-801-SlidingWindow.json","image":"/img/header_img/interview/SlidingWindows.gif","num_read":60,"num_like":104,"num_collection":246,"num_comments":25},"prev":{"title":"算法常用的解题思路---快速排序及优化","path":"api/articles/resource-java-algorithm-802-qualkSort.json","image":"/img/header_img/10.jpg","num_read":699,"num_like":1034,"num_collection":167,"num_comments":106},"categories":[{"name":"Java","path":"api/categories/Java.json","pathContent":"api/categories/Java","description":"知识点、常用功能","cover":"https://sunfy9.gitee.io/project/photo/project/java.png"}],"tags":[{"name":"Interviewenen","path":"api/tags/Interviewenen.json","pathContent":"api/tags/Interviewenen","description":"[Interviewenen]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}