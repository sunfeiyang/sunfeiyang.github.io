{"title":"ArrayBlockingQueue介绍","num_read":1316,"num_like":240,"num_collection":828,"num_comments":129,"slug":"resource-java-concurrent-BQ-01-ArrayBlockingQueue","date":"2021-12-12T16:00:00.000Z","img":"/img/header_img/concurrent/ArrayBlockingQueue.png","minNumber":600,"format":"standard","_id":"clhrbp2dp00a2o5lgajxc3eog","project":"concurrent","subtitle":"ArrayBlockingQueue是最典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用ReentrantLock实现线程安全。","site":{"data":{}},"updated":"2022-09-19T14:50:28.093Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-01-ArrayBlockingQueue.json","webPath":"2021/12/13/resource-java-concurrent-BQ-01-ArrayBlockingQueue/","permalink":"https://sunfy9.gitee.io/2021/12/13/resource-java-concurrent-BQ-01-ArrayBlockingQueue/","excerpt":null,"covers":["../../../../img/BQ-01-ArrayBlockingQueue/image-20211214144217068.png","../../../../img/BQ-01-ArrayBlockingQueue/31232.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a><strong>ArrayBlockingQueue</strong></h1><p><strong>ArrayBlockingQueue是最典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用 ReentrantLock 实现线程安全。</strong></p>\n<p>在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错选择；但如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞。</p>\n<p>使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。</p>\n<p>ArrayBlockingQueue：<strong>有界阻塞队列，先进先出，存取相互排斥</strong></p>\n<p><img src=\"../../../../img/BQ-01-ArrayBlockingQueue/image-20211214144217068.png\" alt=\"image-20211214144217068\"></p>\n<p>数据结构：静态数组</p>\n<ul>\n<li>容量固定必须指定长度。没有扩容机制</li>\n<li>没有元素的位置也占用空间，被null占位</li>\n</ul>\n<p>锁(ReentrantLook)：<strong>存取是同一把锁，操作的是同一个数组对象，存取互相排斥</strong><sunfy-line></p>\n<p>阻塞对象：</p>\n<ul>\n<li>notEmpty：出队：队列count=0，无元素可取时，阻塞在该对象上</li>\n<li>notFull：入队：队列count=length，放不进去元素时，阻塞在该对象上</li>\n</ul>\n<p>两个操作：</p>\n<ul>\n<li><p>入队：从队首开始添加元素，记录putIndex（到队尾时设置为0）<strong>唤醒notEmpty</strong></p>\n</li>\n<li><p>出队：从队首开始提取元素，记录takeIndex（到队尾时设置为0）<strong>唤醒notFull</strong></p>\n</li>\n<li><p><strong>两个指针都是从队首向队尾移动，保证队列的先进先出原则</strong></p>\n</li>\n</ul>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue queue = <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">1024</span>);</span><br><span class=\"line\">queue.put(<span class=\"string\">\"1\"</span>);   <span class=\"comment\">//向队列中添加元素</span></span><br><span class=\"line\">Object object = queue.take();   <span class=\"comment\">//从队列中取出元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p><strong>数据结构</strong></p>\n<p>利用了Lock锁的Condition通知机制进行阻塞控制。</p>\n<p>核心：一把锁，两个条件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数据元素数组</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Object[] items;</span><br><span class=\"line\"><span class=\"comment\">//下一个待取出元素索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> takeIndex;</span><br><span class=\"line\"><span class=\"comment\">//下一个待添加元素索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> putIndex;</span><br><span class=\"line\"><span class=\"comment\">//元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count;</span><br><span class=\"line\"><span class=\"comment\">//内部锁</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReentrantLock lock;</span><br><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notEmpty;</span><br><span class=\"line\"><span class=\"comment\">//生产者</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notFull;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(capacity, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    lock = <span class=\"keyword\">new</span> ReentrantLock(fair); <span class=\"comment\">//公平，非公平</span></span><br><span class=\"line\">    notEmpty = lock.newCondition();</span><br><span class=\"line\">    notFull =  lock.newCondition();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>入队put方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//检查是否为空</span></span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">//加锁，如果线程中断抛出异常 </span></span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//阻塞队列已满，则将生产者挂起，等待消费者唤醒</span></span><br><span class=\"line\">       <span class=\"comment\">//设计注意点： 用while不用if是为了防止虚假唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">            notFull.await(); <span class=\"comment\">//队列满了，使用notFull等待（生产者阻塞）</span></span><br><span class=\"line\">        <span class=\"comment\">// 入队</span></span><br><span class=\"line\">        enqueue(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock(); <span class=\"comment\">// 唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"comment\">//入队   使用的putIndex</span></span><br><span class=\"line\">    items[putIndex] = x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++putIndex == items.length) </span><br><span class=\"line\">        putIndex = <span class=\"number\">0</span>;  <span class=\"comment\">//设计的精髓： 环形数组，putIndex指针到数组尽头了，返回头部</span></span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"comment\">//notEmpty条件队列转同步队列，准备唤醒消费者线程，因为入队了一个元素，肯定不为空了</span></span><br><span class=\"line\">    notEmpty.signal();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"出队take方法\"><a href=\"#出队take方法\" class=\"headerlink\" title=\"出队take方法\"></a>出队take方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">//加锁，如果线程中断抛出异常 </span></span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//如果队列为空，则消费者挂起</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">            notEmpty.await();</span><br><span class=\"line\">        <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();<span class=\"comment\">// 唤醒生产者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    E x = (E) items[takeIndex]; <span class=\"comment\">//取出takeIndex位置的元素</span></span><br><span class=\"line\">    items[takeIndex] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++takeIndex == items.length)</span><br><span class=\"line\">        takeIndex = <span class=\"number\">0</span>; <span class=\"comment\">//设计的精髓： 环形数组，takeIndex 指针到数组尽头了，返回头部</span></span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itrs != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        itrs.elementDequeued();</span><br><span class=\"line\">    <span class=\"comment\">//notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位</span></span><br><span class=\"line\">    notFull.signal();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"环形数组\"><a href=\"#环形数组\" class=\"headerlink\" title=\"环形数组\"></a>环形数组</h2><p><img src=\"../../../../img/BQ-01-ArrayBlockingQueue/31232.png\" alt=\"img\"></p>\n","more":"<h1 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a><strong>ArrayBlockingQueue</strong></h1><p><strong>ArrayBlockingQueue是最典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用 ReentrantLock 实现线程安全。</strong></p>\n<p>在生产者-消费者模型中使用时，如果生产速度和消费速度基本匹配的情况下，使用ArrayBlockingQueue是个不错选择；但如果生产速度远远大于消费速度，则会导致队列填满，大量生产线程被阻塞。</p>\n<p>使用独占锁ReentrantLock实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作；这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈。</p>\n<p>ArrayBlockingQueue：<strong>有界阻塞队列，先进先出，存取相互排斥</strong></p>\n<p><img src=\"../../../../img/BQ-01-ArrayBlockingQueue/image-20211214144217068.png\" alt=\"image-20211214144217068\"></p>\n<p>数据结构：静态数组</p>\n<ul>\n<li>容量固定必须指定长度。没有扩容机制</li>\n<li>没有元素的位置也占用空间，被null占位</li>\n</ul>\n<p>锁(ReentrantLook)：<strong>存取是同一把锁，操作的是同一个数组对象，存取互相排斥</strong><sunfy-line></p>\n<p>阻塞对象：</p>\n<ul>\n<li>notEmpty：出队：队列count=0，无元素可取时，阻塞在该对象上</li>\n<li>notFull：入队：队列count=length，放不进去元素时，阻塞在该对象上</li>\n</ul>\n<p>两个操作：</p>\n<ul>\n<li><p>入队：从队首开始添加元素，记录putIndex（到队尾时设置为0）<strong>唤醒notEmpty</strong></p>\n</li>\n<li><p>出队：从队首开始提取元素，记录takeIndex（到队尾时设置为0）<strong>唤醒notFull</strong></p>\n</li>\n<li><p><strong>两个指针都是从队首向队尾移动，保证队列的先进先出原则</strong></p>\n</li>\n</ul>\n<h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue queue = <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">1024</span>);</span><br><span class=\"line\">queue.put(<span class=\"string\">\"1\"</span>);   <span class=\"comment\">//向队列中添加元素</span></span><br><span class=\"line\">Object object = queue.take();   <span class=\"comment\">//从队列中取出元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p><strong>数据结构</strong></p>\n<p>利用了Lock锁的Condition通知机制进行阻塞控制。</p>\n<p>核心：一把锁，两个条件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//数据元素数组</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Object[] items;</span><br><span class=\"line\"><span class=\"comment\">//下一个待取出元素索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> takeIndex;</span><br><span class=\"line\"><span class=\"comment\">//下一个待添加元素索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> putIndex;</span><br><span class=\"line\"><span class=\"comment\">//元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count;</span><br><span class=\"line\"><span class=\"comment\">//内部锁</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ReentrantLock lock;</span><br><span class=\"line\"><span class=\"comment\">//消费者</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notEmpty;</span><br><span class=\"line\"><span class=\"comment\">//生产者</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition notFull;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(capacity, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayBlockingQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    lock = <span class=\"keyword\">new</span> ReentrantLock(fair); <span class=\"comment\">//公平，非公平</span></span><br><span class=\"line\">    notEmpty = lock.newCondition();</span><br><span class=\"line\">    notFull =  lock.newCondition();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>入队put方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(E e)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//检查是否为空</span></span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">//加锁，如果线程中断抛出异常 </span></span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//阻塞队列已满，则将生产者挂起，等待消费者唤醒</span></span><br><span class=\"line\">       <span class=\"comment\">//设计注意点： 用while不用if是为了防止虚假唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">            notFull.await(); <span class=\"comment\">//队列满了，使用notFull等待（生产者阻塞）</span></span><br><span class=\"line\">        <span class=\"comment\">// 入队</span></span><br><span class=\"line\">        enqueue(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock(); <span class=\"comment\">// 唤醒消费者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"comment\">//入队   使用的putIndex</span></span><br><span class=\"line\">    items[putIndex] = x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++putIndex == items.length) </span><br><span class=\"line\">        putIndex = <span class=\"number\">0</span>;  <span class=\"comment\">//设计的精髓： 环形数组，putIndex指针到数组尽头了，返回头部</span></span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"comment\">//notEmpty条件队列转同步队列，准备唤醒消费者线程，因为入队了一个元素，肯定不为空了</span></span><br><span class=\"line\">    notEmpty.signal();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"出队take方法\"><a href=\"#出队take方法\" class=\"headerlink\" title=\"出队take方法\"></a>出队take方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">//加锁，如果线程中断抛出异常 </span></span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//如果队列为空，则消费者挂起</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">            notEmpty.await();</span><br><span class=\"line\">        <span class=\"comment\">//出队</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();<span class=\"comment\">// 唤醒生产者线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">this</span>.items;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    E x = (E) items[takeIndex]; <span class=\"comment\">//取出takeIndex位置的元素</span></span><br><span class=\"line\">    items[takeIndex] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++takeIndex == items.length)</span><br><span class=\"line\">        takeIndex = <span class=\"number\">0</span>; <span class=\"comment\">//设计的精髓： 环形数组，takeIndex 指针到数组尽头了，返回头部</span></span><br><span class=\"line\">    count--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (itrs != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        itrs.elementDequeued();</span><br><span class=\"line\">    <span class=\"comment\">//notFull条件队列转同步队列，准备唤醒生产者线程，此时队列有空位</span></span><br><span class=\"line\">    notFull.signal();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"环形数组\"><a href=\"#环形数组\" class=\"headerlink\" title=\"环形数组\"></a>环形数组</h2><p><img src=\"../../../../img/BQ-01-ArrayBlockingQueue/31232.png\" alt=\"img\"></p>\n","next":{"title":"BlockingQueue概览","path":"api/articles/resource-java-concurrent-BlockingQueue.json","image":"/img/header_img/concurrent/BlockingQueue.png","num_read":1777,"num_like":259,"num_collection":46,"num_comments":169},"prev":{"title":"LinkedBlockingQueue介绍","path":"api/articles/resource-java-concurrent-BQ-02-LinkedBlockingQueue.json","image":"/img/header_img/concurrent/LinkedBlockingQueue.png","num_read":197,"num_like":480,"num_collection":642,"num_comments":55},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}