{"title":"JDK1.8新特性之Lambda表达式","num_read":1290,"num_like":636,"num_collection":559,"num_comments":40,"slug":"resource-java-Base-jdk8-Lambda","date":"2021-09-15T16:00:00.000Z","img":"/img/header_img/java/Lambda.png","_id":"clhrbp2dw00beo5lg7svjgmmy","project":"Java","type":"hot","subtitle":"闭包与高阶函数、惰性计算、没有“副作用”，一段匿名内部类，也可以是一段可以传递的代码","site":{"data":{}},"updated":"2022-01-12T05:25:44.000Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-Base-jdk8-Lambda.json","webPath":"2021/09/16/resource-java-Base-jdk8-Lambda/","permalink":"https://sunfy9.gitee.io/2021/09/16/resource-java-Base-jdk8-Lambda/","excerpt":null,"covers":null,"keywords":"sunfy, hexo-theme-snail","content":"<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>函数编程非常关键的几个特性如下： </p>\n<ul>\n<li>闭包与高阶函数：函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上， 闭包是起函数的作用并可以像对象一样操作的对象。 与此类似，FP 语言支持 高阶函数。高阶函数可以用另一个函数（间接地，用一个表达式） 作为其输入参数，在某些情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在 一起使得可以用优雅的方式进行模块化编程，这是使用 FP 的最大好处。 </li>\n<li>惰性计算：在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值 时进行计算。延迟的计算使您可以编写可能潜在地生成无穷输出的函数。因为不会计算多于 程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。 </li>\n<li>没有“副作用”： 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局 变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持 独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 综上所述，函数式编程可以简言之是： 使用不可变值和函数， 函数对一个值进行处理， 映 射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输 入。 </li>\n</ul>\n<h2 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h2><p>lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>完整的Lambda表达式由三部分组成：参数列表、箭头、声明语句； </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. return statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<sunfy-line>\n\n<ol>\n<li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类 型，所以参数可以省略：  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. r eturn statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式的参数个数只有一个，可以省略小括号： </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param1 ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. return statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的 分号： </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param1 ‐&gt; statment</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数接口\"><a href=\"#函数接口\" class=\"headerlink\" title=\"函数接口\"></a>函数接口</h3><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。 接口包路径为java.util.function，然后接口类上面都有@FunctionalInterface这个注解。 </p>\n<p>这些函数接口在使用Lambda表达式时做为返回类型，JDK定义了很多现在的函 数接口，实际自己也可以定义接口去做为表达式的返回，只是大多数情况下JDK 定义的直接拿来就可以用了。而且这些接口在JDK8集合类使用流操作时大量被 使用</p>\n<h3 id=\"类型检查、类型推断\"><a href=\"#类型检查、类型推断\" class=\"headerlink\" title=\"类型检查、类型推断\"></a>类型检查、类型推断</h3><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依 然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是 所谓的类型推断。Lambda 表达式中的类型推断， 实际上是 Java 7 就引入的目标 类型推断的扩展 有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更 好；对于如何让代码更易读，你必须做出自己的选择 </p>\n<h3 id=\"局部变量限制\"><a href=\"#局部变量限制\" class=\"headerlink\" title=\"局部变量限制\"></a>局部变量限制</h3><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像 匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体 中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。 </p>\n<p>为什么局部变量有这些限制？ </p>\n<ul>\n<li>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变 量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用 的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变 量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变 量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>\n<li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式。</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// todo @FunctionalInterface注解会检测接口是否有且只有一个抽象方法，还可以有默认方法和静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Name\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getName2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Name2\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lambda</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"实现类方法\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">222</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Lambda lambda)</span> </span>&#123;</span><br><span class=\"line\">        lambda.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递实现类</span></span><br><span class=\"line\">        test(<span class=\"keyword\">new</span> LambdaImpl());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类</span></span><br><span class=\"line\">        test(<span class=\"keyword\">new</span> Lambda() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"匿名内部类实现\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Lambda</span></span><br><span class=\"line\">        test(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Lambda调用\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当lambda表单式只包含一条语句时，可以省略大括号，return和语句结尾的分号；</span></span><br><span class=\"line\">        test(() -&gt; returnInt());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">returnInt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Lambda简化调用\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1234</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","more":"<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>函数编程非常关键的几个特性如下： </p>\n<ul>\n<li>闭包与高阶函数：函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上， 闭包是起函数的作用并可以像对象一样操作的对象。 与此类似，FP 语言支持 高阶函数。高阶函数可以用另一个函数（间接地，用一个表达式） 作为其输入参数，在某些情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在 一起使得可以用优雅的方式进行模块化编程，这是使用 FP 的最大好处。 </li>\n<li>惰性计算：在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值 时进行计算。延迟的计算使您可以编写可能潜在地生成无穷输出的函数。因为不会计算多于 程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。 </li>\n<li>没有“副作用”： 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局 变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持 独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。 综上所述，函数式编程可以简言之是： 使用不可变值和函数， 函数对一个值进行处理， 映 射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输 入。 </li>\n</ul>\n<h2 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h2><p>lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>完整的Lambda表达式由三部分组成：参数列表、箭头、声明语句； </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. return statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<sunfy-line>\n\n<ol>\n<li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类 型，所以参数可以省略：  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. r eturn statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式的参数个数只有一个，可以省略小括号： </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param1 ‐&gt; &#123; statment1; statment2; &#x2F;&#x2F;............. return statmentM;&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的 分号： </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param1 ‐&gt; statment</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数接口\"><a href=\"#函数接口\" class=\"headerlink\" title=\"函数接口\"></a>函数接口</h3><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。 接口包路径为java.util.function，然后接口类上面都有@FunctionalInterface这个注解。 </p>\n<p>这些函数接口在使用Lambda表达式时做为返回类型，JDK定义了很多现在的函 数接口，实际自己也可以定义接口去做为表达式的返回，只是大多数情况下JDK 定义的直接拿来就可以用了。而且这些接口在JDK8集合类使用流操作时大量被 使用</p>\n<h3 id=\"类型检查、类型推断\"><a href=\"#类型检查、类型推断\" class=\"headerlink\" title=\"类型检查、类型推断\"></a>类型检查、类型推断</h3><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依 然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是 所谓的类型推断。Lambda 表达式中的类型推断， 实际上是 Java 7 就引入的目标 类型推断的扩展 有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更 好；对于如何让代码更易读，你必须做出自己的选择 </p>\n<h3 id=\"局部变量限制\"><a href=\"#局部变量限制\" class=\"headerlink\" title=\"局部变量限制\"></a>局部变量限制</h3><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像 匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体 中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。 </p>\n<p>为什么局部变量有这些限制？ </p>\n<ul>\n<li>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变 量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用 的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变 量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变 量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</li>\n<li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式。</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Lambda</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// todo @FunctionalInterface注解会检测接口是否有且只有一个抽象方法，还可以有默认方法和静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Name\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">getName2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Name2\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LambdaImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lambda</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"实现类方法\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">222</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Lambda lambda)</span> </span>&#123;</span><br><span class=\"line\">        lambda.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传递实现类</span></span><br><span class=\"line\">        test(<span class=\"keyword\">new</span> LambdaImpl());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类</span></span><br><span class=\"line\">        test(<span class=\"keyword\">new</span> Lambda() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"匿名内部类实现\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Lambda</span></span><br><span class=\"line\">        test(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Lambda调用\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当lambda表单式只包含一条语句时，可以省略大括号，return和语句结尾的分号；</span></span><br><span class=\"line\">        test(() -&gt; returnInt());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">returnInt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Lambda简化调用\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1234</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","next":{"title":"SpringBean的销毁","path":"api/articles/resource-Spring-Spring-SpringBean的销毁.json","image":"/img/header_img/spring/destruction.png","num_read":1710,"num_like":952,"num_collection":318,"num_comments":184},"prev":{"title":"Java安全管理器入门","path":"api/articles/resource-java-Base-securityManager.json","image":"/img/header_img/java/securityManager.png","num_read":394,"num_like":103,"num_collection":331,"num_comments":167},"categories":[{"name":"Java","path":"api/categories/Java.json","pathContent":"api/categories/Java","description":"知识点、常用功能","cover":"https://sunfy9.gitee.io/project/photo/project/java.png"}],"tags":[{"name":"jdk","path":"api/tags/jdk.json","pathContent":"api/tags/jdk","description":"[jdk]暂未设置说明","cover":"https://sunfy9.gitee.io/img/header_img/sunfy-default.png"}]}