{"title":"并发线程池原理分析","num_read":1054,"num_like":445,"num_collection":575,"num_comments":262,"slug":"resource-java-concurrent-threadPool","date":"2021-11-05T16:00:00.000Z","img":"/img/header_img/concurrent/threadpool.png","format":"gallery","_id":"clhrbp2dp00a5o5lg6nw759jv","project":"concurrent","subtitle":"并发线程与线程池区别以及线程池原理分析","site":{"data":{}},"updated":"2022-09-19T14:43:21.677Z","author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-threadPool.json","webPath":"2021/11/06/resource-java-concurrent-threadPool/","permalink":"https://sunfy9.gitee.io/2021/11/06/resource-java-concurrent-threadPool/","excerpt":null,"covers":["../../../../img/threadPool/image-20211106231735493.png","../../../../img/threadPool/image-20211107145649860.png","../../../../img/threadPool/image-20211107145215044.png","../../../../img/threadPool/image-20211107152353491.png","../../../../img/threadPool/image-20211108092550393.png","../../../../img/threadPool/image-20220919223930024.png"],"keywords":"sunfy, hexo-theme-snail","content":"<h1 id=\"线程池与线程对比\"><a href=\"#线程池与线程对比\" class=\"headerlink\" title=\"线程池与线程对比\"></a>线程池与线程对比</h1><h2 id=\"new-Thread-的弊端\"><a href=\"#new-Thread-的弊端\" class=\"headerlink\" title=\"new Thread 的弊端\"></a>new Thread 的弊端</h2><ul>\n<li><strong>创建：</strong>每次new Thread时，新建对象性能差。</li>\n<li><strong>管理：</strong>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，可能占用过多系统资源导致死机或<code>oom</code>。</li>\n<li><strong>功能：</strong>缺乏更多功能，如定时执行、定期执行、线程中断。</li>\n</ul>\n<h2 id=\"Java提供的四种线程池相比new-Thread的优势\"><a href=\"#Java提供的四种线程池相比new-Thread的优势\" class=\"headerlink\" title=\"Java提供的四种线程池相比new Thread的优势\"></a>Java提供的四种线程池相比new Thread的优势</h2><ul>\n<li><strong>创建：</strong>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li>\n<li><strong>管理：</strong>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>\n<li><strong>功能：</strong>提供定时执行、定期执行、单线程、并发数控制等功能。</li>\n</ul>\n<h2 id=\"Java线程池\"><a href=\"#Java线程池\" class=\"headerlink\" title=\"Java线程池\"></a>Java线程池</h2><p>Java通过Executors提供四种线程池<sunfy-line></p>\n<ul>\n<li><code>newCachedThreadPool</code> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖 于操作系统（或者说JVM）能够创建的最大线程大小。</li>\n<li><code>newFixedThreadPool</code> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束 ，那么线程池会补充一个新线程。</li>\n<li><code>newScheduledThreadPool</code> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>\n<li><code>newSingleThreadExecutor</code> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行(FIFO, LIFO)。</li>\n</ul>\n<h1 id=\"实例对比\"><a href=\"#实例对比\" class=\"headerlink\" title=\"实例对比\"></a>实例对比</h1><p>看一个例子，来对别线程与线程池的执行效率</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程执行情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录开始时间</span></span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                list.add(random.nextInt());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 输出运行时间和运行list结果</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"时间：\"</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"大小：\"</span> + list.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果，因电脑而异</span></span><br><span class=\"line\">时间：<span class=\"number\">16733</span></span><br><span class=\"line\">大小：<span class=\"number\">100000</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java线程池执行相同的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个单线程化的线程池</span></span><br><span class=\"line\">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                list.add(random.nextInt());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    executorService.shutdown();</span><br><span class=\"line\">    <span class=\"comment\">// 阻塞直到所有任务在关闭请求后完成执行，或发生超时，或当前线程被中断，以先发生者为准。</span></span><br><span class=\"line\">    executorService.awaitTermination(<span class=\"number\">1</span>, TimeUnit.DAYS);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"时间：\"</span>+(System.currentTimeMillis() - start));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"大小：\"</span>+list.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果，因电脑而异</span></span><br><span class=\"line\">时间：<span class=\"number\">62</span></span><br><span class=\"line\">大小：<span class=\"number\">100000</span></span><br></pre></td></tr></table></figure>\n<p>从执行结果看，很显而易见。线程池和线程执行效率完全不在一个数量级。</p>\n<p>对比来看，使用线程运行的程序：</p>\n<ul>\n<li>创建线程数：100001个</li>\n<li>创建对象数：100000个</li>\n</ul>\n<p>使用线程池的程序：</p>\n<ul>\n<li>创建线程数：2个</li>\n<li>创建对象数：100000个</li>\n</ul>\n<p>从上面的例子来看，确实线程池比线程的执行效率快很多，但是使用线程池一定比线程快吗？</p>\n<p>这个答案肯定也是否定的，接下来我们来对比一下java中提供的几种线程池的执行？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池执行方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<span class=\"comment\">//快</span></span><br><span class=\"line\">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">2</span>);<span class=\"comment\">//慢</span></span><br><span class=\"line\">    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<span class=\"comment\">//最慢</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用线程池执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        singleThreadExecutor.execute(<span class=\"keyword\">new</span> MyTask(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTask</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.i = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输出打印日志</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"线程\"</span> + Thread.currentThread().getName() + <span class=\"string\">\"执行第\"</span> + i + <span class=\"string\">\"个任务\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000L</span>);<span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果分析：</p>\n<p>最终不论采用哪个线程池，最终十个任务都会被执行这个是必然的，但是在执行的效率上差别还是很大的。</p>\n<ul>\n<li><p><code>cachedThreadPool</code>：可以看到执行效率是最快的，从执行结果来看，分别为每一个任务new了一个线程是去单独执行相应的任务。</p>\n<blockquote>\n<p>线程pool-1-thread-1执行第1个任务<br>线程pool-1-thread-2执行第2个任务<br>线程pool-1-thread-3执行第3个任务<br>线程pool-1-thread-4执行第4个任务<br>线程pool-1-thread-5执行第5个任务<br>线程pool-1-thread-6执行第6个任务<br>线程pool-1-thread-7执行第7个任务<br>线程pool-1-thread-8执行第8个任务<br>线程pool-1-thread-9执行第9个任务<br>线程pool-1-thread-10执行第10个任务</p>\n</blockquote>\n</li>\n<li><p><code>fixedThreadPool</code>：这个线程池执行效率应该是居中，同时这个线程池的执行效率和传入的参数是有关的，从输出的结果可以看到，传入参数是多少，就会创建多少个线程同步执行任务。</p>\n<blockquote>\n<p>线程pool-2-thread-2执行第2个任务<br>线程pool-2-thread-1执行第1个任务<br>线程pool-2-thread-2执行第3个任务<br>线程pool-2-thread-1执行第4个任务<br>线程pool-2-thread-2执行第5个任务<br>线程pool-2-thread-1执行第6个任务<br>线程pool-2-thread-2执行第7个任务<br>线程pool-2-thread-1执行第8个任务<br>线程pool-2-thread-2执行第9个任务<br>线程pool-2-thread-1执行第10个任务</p>\n</blockquote>\n</li>\n<li><p><code>singleThreadExecutor</code>：从线程池的名称也可以猜到，这个是一个单线程的线程池，每次只能执行一个任务，自然效率也是最低的。执行结果中也可以很明显看到只有一个线程在执行任务。</p>\n<blockquote>\n<p>线程pool-3-thread-1执行第1个任务<br>线程pool-3-thread-1执行第2个任务<br>线程pool-3-thread-1执行第3个任务<br>线程pool-3-thread-1执行第4个任务<br>线程pool-3-thread-1执行第5个任务<br>线程pool-3-thread-1执行第6个任务<br>线程pool-3-thread-1执行第7个任务<br>线程pool-3-thread-1执行第8个任务<br>线程pool-3-thread-1执行第9个任务<br>线程pool-3-thread-1执行第10个任务</p>\n</blockquote>\n</li>\n</ul>\n<p>由上面分析我们可以看到java中提供了不同情况的线程池，但是在阿里代码手册中并不让使用java默认的线程池，那这又是为什么呢？</p>\n<p>我们看下阿里开发手册中关于线程与线程池的创建是如何规定的：</p>\n<p><img src=\"../../../../img/threadPool/image-20211106231735493.png\" alt=\"image-20211106231735493\"></p>\n<p>要求自定义线程工厂。</p>\n<blockquote>\n<p>//自定义线程</p>\n<p>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(10));</p>\n</blockquote>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"线程池执行流程\"><a href=\"#线程池执行流程\" class=\"headerlink\" title=\"线程池执行流程\"></a>线程池执行流程</h2><p><img src=\"../../../../img/threadPool/image-20211107145649860.png\" alt=\"image-20211107145649860\"></p>\n<p><img src=\"../../../../img/threadPool/image-20211107145215044.png\" alt=\"image-20211107145215044\"></p>\n<h2 id=\"线程池的五种状态\"><a href=\"#线程池的五种状态\" class=\"headerlink\" title=\"线程池的五种状态\"></a>线程池的五种状态</h2><p><img src=\"../../../../img/threadPool/image-20211107152353491.png\" alt=\"image-20211107152353491\"></p>\n<p>线程池的5种状态：<code>Running</code>、<code>ShutDown</code>、<code>Stop</code>、<code>Tidying</code>、<code>Terminated</code>。</p>\n<p><strong>RUNNING</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>RUNNING</code>状态时，能够接收新任务（线程池没有满的情况下），以及对已添加的任务进行处理。</li>\n<li>状态切换：线程池的初始化状态是<code>RUNNING</code>。换句话说，线程池一旦被创建，就处于<code>RUNNING</code>状态，并且线程池中的任务数为<code>0</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<p><strong>SHUTDOWN</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>SHUTDOWN</code>状态时，不接收新任务，但能处理已添加的任务。</li>\n<li>状态切换：调用线程池的<code>shutdown()</code>接口时，线程池由<code>RUNNING</code> -&gt; <code>SHUTDOWN</code>。</li>\n</ul>\n<p><strong>STOP</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>STOP</code>状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>\n<li>状态切换：调用线程池的<code>shutdownNow()</code>接口时，线程池由(<code>RUNNING</code> or <code>SHUTDOWN</code> ) -&gt; <code>STOP</code>。</li>\n</ul>\n<p><strong>TIDYING</strong></p>\n<ul>\n<li>状态说明：当所有的任务已终止，<code>ctl</code>记录的<code>任务数量</code>为<code>0</code>，线程池会变为<code>TIDYING</code>状态。当线程池变为<code>TIDYING</code>状态时，会执行钩子函数<code>terminated()</code>。<code>terminated()</code>在<code>ThreadPoolExecutor</code>类中是空的，若用户想在线程池变为<code>TIDYING</code>时，进行相应的处理；可以通过重载<code>terminated()</code>函数来实现。</li>\n<li>状态切换：当线程池在<code>SHUTDOWN</code>状态下，阻塞队列（任务队列）为空并且线程池中执行的任务也为空时，就会由 <code>SHUTDOWN</code> -&gt;<code>TIDYING</code>。 当线程池在<code>STOP</code>状态下，线程池中执行的任务为空时，就会由<code>STOP</code> -&gt; <code>TIDYING</code>。</li>\n</ul>\n<p><strong>TERMINATED</strong></p>\n<ul>\n<li>状态说明：线程池彻底终止，就变成<code>TERMINATED</code>状态。</li>\n<li>状态切换：线程池处在<code>TIDYING</code>状态时，执行完<code>terminated()</code>之后，就会由 <code>TIDYING</code> -&gt; <code>TERMINATED</code>。</li>\n</ul>\n<h2 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h2><p><code>ThreadPoolExecutor</code>内部有实现4个拒绝策略： </p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><ul>\n<li>corePoolSize：核心线程数</li>\n<li>maximumPoolSize：最大线程数</li>\n<li>workQueue：阻塞队列，存储等待执行的任务</li>\n<li>keepAliveTime：线程没有任务执行时保持存活时间</li>\n<li>unit：keepAliveTime的时间单位</li>\n<li>threadFactory：线程工厂</li>\n<li>rejectHandler：拒绝策略，当阻塞队列满了时，没有空闲的线程池，此时需要一种策略处理当前任务</li>\n</ul>\n<p><img src=\"../../../../img/threadPool/image-20211108092550393.png\" alt=\"image-20211108092550393\"></p>\n<p><img src=\"../../../../img/threadPool/image-20220919223930024.png\" alt=\"image-20220919223930024\"></p>\n","more":"<h1 id=\"线程池与线程对比\"><a href=\"#线程池与线程对比\" class=\"headerlink\" title=\"线程池与线程对比\"></a>线程池与线程对比</h1><h2 id=\"new-Thread-的弊端\"><a href=\"#new-Thread-的弊端\" class=\"headerlink\" title=\"new Thread 的弊端\"></a>new Thread 的弊端</h2><ul>\n<li><strong>创建：</strong>每次new Thread时，新建对象性能差。</li>\n<li><strong>管理：</strong>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，可能占用过多系统资源导致死机或<code>oom</code>。</li>\n<li><strong>功能：</strong>缺乏更多功能，如定时执行、定期执行、线程中断。</li>\n</ul>\n<h2 id=\"Java提供的四种线程池相比new-Thread的优势\"><a href=\"#Java提供的四种线程池相比new-Thread的优势\" class=\"headerlink\" title=\"Java提供的四种线程池相比new Thread的优势\"></a>Java提供的四种线程池相比new Thread的优势</h2><ul>\n<li><strong>创建：</strong>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li>\n<li><strong>管理：</strong>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li>\n<li><strong>功能：</strong>提供定时执行、定期执行、单线程、并发数控制等功能。</li>\n</ul>\n<h2 id=\"Java线程池\"><a href=\"#Java线程池\" class=\"headerlink\" title=\"Java线程池\"></a>Java线程池</h2><p>Java通过Executors提供四种线程池<sunfy-line></p>\n<ul>\n<li><code>newCachedThreadPool</code> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖 于操作系统（或者说JVM）能够创建的最大线程大小。</li>\n<li><code>newFixedThreadPool</code> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束 ，那么线程池会补充一个新线程。</li>\n<li><code>newScheduledThreadPool</code> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>\n<li><code>newSingleThreadExecutor</code> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行(FIFO, LIFO)。</li>\n</ul>\n<h1 id=\"实例对比\"><a href=\"#实例对比\" class=\"headerlink\" title=\"实例对比\"></a>实例对比</h1><p>看一个例子，来对别线程与线程池的执行效率</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程执行情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录开始时间</span></span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                list.add(random.nextInt());</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 输出运行时间和运行list结果</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"时间：\"</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"大小：\"</span> + list.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果，因电脑而异</span></span><br><span class=\"line\">时间：<span class=\"number\">16733</span></span><br><span class=\"line\">大小：<span class=\"number\">100000</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// java线程池执行相同的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Long start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个单线程化的线程池</span></span><br><span class=\"line\">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                list.add(random.nextInt());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    executorService.shutdown();</span><br><span class=\"line\">    <span class=\"comment\">// 阻塞直到所有任务在关闭请求后完成执行，或发生超时，或当前线程被中断，以先发生者为准。</span></span><br><span class=\"line\">    executorService.awaitTermination(<span class=\"number\">1</span>, TimeUnit.DAYS);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"时间：\"</span>+(System.currentTimeMillis() - start));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"大小：\"</span>+list.size());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果，因电脑而异</span></span><br><span class=\"line\">时间：<span class=\"number\">62</span></span><br><span class=\"line\">大小：<span class=\"number\">100000</span></span><br></pre></td></tr></table></figure>\n<p>从执行结果看，很显而易见。线程池和线程执行效率完全不在一个数量级。</p>\n<p>对比来看，使用线程运行的程序：</p>\n<ul>\n<li>创建线程数：100001个</li>\n<li>创建对象数：100000个</li>\n</ul>\n<p>使用线程池的程序：</p>\n<ul>\n<li>创建线程数：2个</li>\n<li>创建对象数：100000个</li>\n</ul>\n<p>从上面的例子来看，确实线程池比线程的执行效率快很多，但是使用线程池一定比线程快吗？</p>\n<p>这个答案肯定也是否定的，接下来我们来对比一下java中提供的几种线程池的执行？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池执行方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<span class=\"comment\">//快</span></span><br><span class=\"line\">    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">2</span>);<span class=\"comment\">//慢</span></span><br><span class=\"line\">    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<span class=\"comment\">//最慢</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用线程池执行任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        singleThreadExecutor.execute(<span class=\"keyword\">new</span> MyTask(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTask</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.i = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 输出打印日志</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"线程\"</span> + Thread.currentThread().getName() + <span class=\"string\">\"执行第\"</span> + i + <span class=\"string\">\"个任务\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000L</span>);<span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果分析：</p>\n<p>最终不论采用哪个线程池，最终十个任务都会被执行这个是必然的，但是在执行的效率上差别还是很大的。</p>\n<ul>\n<li><p><code>cachedThreadPool</code>：可以看到执行效率是最快的，从执行结果来看，分别为每一个任务new了一个线程是去单独执行相应的任务。</p>\n<blockquote>\n<p>线程pool-1-thread-1执行第1个任务<br>线程pool-1-thread-2执行第2个任务<br>线程pool-1-thread-3执行第3个任务<br>线程pool-1-thread-4执行第4个任务<br>线程pool-1-thread-5执行第5个任务<br>线程pool-1-thread-6执行第6个任务<br>线程pool-1-thread-7执行第7个任务<br>线程pool-1-thread-8执行第8个任务<br>线程pool-1-thread-9执行第9个任务<br>线程pool-1-thread-10执行第10个任务</p>\n</blockquote>\n</li>\n<li><p><code>fixedThreadPool</code>：这个线程池执行效率应该是居中，同时这个线程池的执行效率和传入的参数是有关的，从输出的结果可以看到，传入参数是多少，就会创建多少个线程同步执行任务。</p>\n<blockquote>\n<p>线程pool-2-thread-2执行第2个任务<br>线程pool-2-thread-1执行第1个任务<br>线程pool-2-thread-2执行第3个任务<br>线程pool-2-thread-1执行第4个任务<br>线程pool-2-thread-2执行第5个任务<br>线程pool-2-thread-1执行第6个任务<br>线程pool-2-thread-2执行第7个任务<br>线程pool-2-thread-1执行第8个任务<br>线程pool-2-thread-2执行第9个任务<br>线程pool-2-thread-1执行第10个任务</p>\n</blockquote>\n</li>\n<li><p><code>singleThreadExecutor</code>：从线程池的名称也可以猜到，这个是一个单线程的线程池，每次只能执行一个任务，自然效率也是最低的。执行结果中也可以很明显看到只有一个线程在执行任务。</p>\n<blockquote>\n<p>线程pool-3-thread-1执行第1个任务<br>线程pool-3-thread-1执行第2个任务<br>线程pool-3-thread-1执行第3个任务<br>线程pool-3-thread-1执行第4个任务<br>线程pool-3-thread-1执行第5个任务<br>线程pool-3-thread-1执行第6个任务<br>线程pool-3-thread-1执行第7个任务<br>线程pool-3-thread-1执行第8个任务<br>线程pool-3-thread-1执行第9个任务<br>线程pool-3-thread-1执行第10个任务</p>\n</blockquote>\n</li>\n</ul>\n<p>由上面分析我们可以看到java中提供了不同情况的线程池，但是在阿里代码手册中并不让使用java默认的线程池，那这又是为什么呢？</p>\n<p>我们看下阿里开发手册中关于线程与线程池的创建是如何规定的：</p>\n<p><img src=\"../../../../img/threadPool/image-20211106231735493.png\" alt=\"image-20211106231735493\"></p>\n<p>要求自定义线程工厂。</p>\n<blockquote>\n<p>//自定义线程</p>\n<p>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(10));</p>\n</blockquote>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"线程池执行流程\"><a href=\"#线程池执行流程\" class=\"headerlink\" title=\"线程池执行流程\"></a>线程池执行流程</h2><p><img src=\"../../../../img/threadPool/image-20211107145649860.png\" alt=\"image-20211107145649860\"></p>\n<p><img src=\"../../../../img/threadPool/image-20211107145215044.png\" alt=\"image-20211107145215044\"></p>\n<h2 id=\"线程池的五种状态\"><a href=\"#线程池的五种状态\" class=\"headerlink\" title=\"线程池的五种状态\"></a>线程池的五种状态</h2><p><img src=\"../../../../img/threadPool/image-20211107152353491.png\" alt=\"image-20211107152353491\"></p>\n<p>线程池的5种状态：<code>Running</code>、<code>ShutDown</code>、<code>Stop</code>、<code>Tidying</code>、<code>Terminated</code>。</p>\n<p><strong>RUNNING</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>RUNNING</code>状态时，能够接收新任务（线程池没有满的情况下），以及对已添加的任务进行处理。</li>\n<li>状态切换：线程池的初始化状态是<code>RUNNING</code>。换句话说，线程池一旦被创建，就处于<code>RUNNING</code>状态，并且线程池中的任务数为<code>0</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n<p><strong>SHUTDOWN</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>SHUTDOWN</code>状态时，不接收新任务，但能处理已添加的任务。</li>\n<li>状态切换：调用线程池的<code>shutdown()</code>接口时，线程池由<code>RUNNING</code> -&gt; <code>SHUTDOWN</code>。</li>\n</ul>\n<p><strong>STOP</strong></p>\n<ul>\n<li>状态说明：线程池处在<code>STOP</code>状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>\n<li>状态切换：调用线程池的<code>shutdownNow()</code>接口时，线程池由(<code>RUNNING</code> or <code>SHUTDOWN</code> ) -&gt; <code>STOP</code>。</li>\n</ul>\n<p><strong>TIDYING</strong></p>\n<ul>\n<li>状态说明：当所有的任务已终止，<code>ctl</code>记录的<code>任务数量</code>为<code>0</code>，线程池会变为<code>TIDYING</code>状态。当线程池变为<code>TIDYING</code>状态时，会执行钩子函数<code>terminated()</code>。<code>terminated()</code>在<code>ThreadPoolExecutor</code>类中是空的，若用户想在线程池变为<code>TIDYING</code>时，进行相应的处理；可以通过重载<code>terminated()</code>函数来实现。</li>\n<li>状态切换：当线程池在<code>SHUTDOWN</code>状态下，阻塞队列（任务队列）为空并且线程池中执行的任务也为空时，就会由 <code>SHUTDOWN</code> -&gt;<code>TIDYING</code>。 当线程池在<code>STOP</code>状态下，线程池中执行的任务为空时，就会由<code>STOP</code> -&gt; <code>TIDYING</code>。</li>\n</ul>\n<p><strong>TERMINATED</strong></p>\n<ul>\n<li>状态说明：线程池彻底终止，就变成<code>TERMINATED</code>状态。</li>\n<li>状态切换：线程池处在<code>TIDYING</code>状态时，执行完<code>terminated()</code>之后，就会由 <code>TIDYING</code> -&gt; <code>TERMINATED</code>。</li>\n</ul>\n<h2 id=\"四种拒绝策略\"><a href=\"#四种拒绝策略\" class=\"headerlink\" title=\"四种拒绝策略\"></a>四种拒绝策略</h2><p><code>ThreadPoolExecutor</code>内部有实现4个拒绝策略： </p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><ul>\n<li>corePoolSize：核心线程数</li>\n<li>maximumPoolSize：最大线程数</li>\n<li>workQueue：阻塞队列，存储等待执行的任务</li>\n<li>keepAliveTime：线程没有任务执行时保持存活时间</li>\n<li>unit：keepAliveTime的时间单位</li>\n<li>threadFactory：线程工厂</li>\n<li>rejectHandler：拒绝策略，当阻塞队列满了时，没有空闲的线程池，此时需要一种策略处理当前任务</li>\n</ul>\n<p><img src=\"../../../../img/threadPool/image-20211108092550393.png\" alt=\"image-20211108092550393\"></p>\n<p><img src=\"../../../../img/threadPool/image-20220919223930024.png\" alt=\"image-20220919223930024\"></p>\n","next":{"title":"并发的可见性深入分析","path":"api/articles/resource-java-concurrent-visibility.json","image":"/img/header_img/concurrent/visibility.png","num_read":173,"num_like":352,"num_collection":392,"num_comments":94},"prev":{"title":"CAS操作分析","path":"api/articles/resource-java-concurrent-CAS.json","image":"/img/header_img/concurrent/cas.png","num_read":601,"num_like":443,"num_collection":78,"num_comments":116},"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程","description":"如何充分压榨硬件性能，充分压榨CPU计算能力，减少CPU等待时间（机械同感）","cover":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}],"tags":[]}