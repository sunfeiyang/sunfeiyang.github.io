{"code":200,"total":18,"pageSize":10,"pageCount":2,"data":[{"title":"并发-分布式锁质量保障总结","slug":"resource-java-concurrent-lock","date":"2022-04-04T16:00:00.000Z","img":"/img/header_img/concurrent/lockQuality.png","_id":"clhrbp2dk008to5lg1zx38u77","image":"/img/header_img/concurrent/lockQuality.png","format":"max","project":"concurrent","subtitle":"分布式锁的方式来进行叙述如何进行质量保障","updated":"2022-09-19T14:46:44.702Z","num_read":1745,"num_like":892,"num_collection":741,"num_comments":211,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-lock.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/lock/image-20220408134506988.png","../../../../img/lock/image-20220408134700433.png","../../../../img/lock/image-20220408134732891.png","../../../../img/lock/image-20220408134900417.png","../../../../img/lock/image-20220408134931538.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"如何选择适合的阻塞队列","slug":"resource-java-concurrent-BlockingQueueSelect","date":"2021-12-16T16:00:00.000Z","img":"/img/header_img/concurrent/SelectBlockingQueue.png","_id":"clhrbp2dm009ao5lg38jh2we6","image":"/img/header_img/concurrent/SelectBlockingQueue.png","format":"max","project":"concurrent","subtitle":"如何选择适合的阻塞队列","updated":"2022-01-12T05:38:32.000Z","num_read":1637,"num_like":919,"num_collection":423,"num_comments":264,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BlockingQueueSelect.json","excerpt":null,"keywords":null,"cover":null,"covers":null,"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"PriorityBlockingQueue介绍","slug":"resource-java-concurrent-BQ-05-PriorityBlockingQueue","date":"2021-12-16T16:00:00.000Z","img":"/img/header_img/concurrent/PriorityBlockingQueue.png","_id":"clhrbp2dn009to5lg9k6p57ea","image":"/img/header_img/concurrent/PriorityBlockingQueue.png","format":"standard","project":"concurrent","subtitle":"PriorityBlockingQueue是一个无界的基于数组的优先级阻塞队列","updated":"2022-09-19T14:48:55.933Z","num_read":505,"num_like":474,"num_collection":226,"num_comments":177,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-05-PriorityBlockingQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/BQ-05-PriorityBlockingQueue/31536.png","../../../../img/BQ-05-PriorityBlockingQueue/31542.png","../../../../img/BQ-05-PriorityBlockingQueue/31551.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"DelayQueue介绍","slug":"resource-java-concurrent-BQ-04-DelayQueue","date":"2021-12-15T16:00:00.000Z","img":"/img/header_img/concurrent/DelayQueue.png","_id":"clhrbp2dn009qo5lgftma8cfk","image":"/img/header_img/concurrent/DelayQueue.png","format":"standard","project":"concurrent","subtitle":"DelayQueue 是一个支持延时获取元素的阻塞队列","updated":"2022-01-12T05:40:28.000Z","num_read":1670,"num_like":769,"num_collection":376,"num_comments":150,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-04-DelayQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":null,"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"SynchronousQueue介绍","slug":"resource-java-concurrent-BQ-03-SynchronousQueue","date":"2021-12-14T16:00:00.000Z","img":"/img/header_img/concurrent/SynchronousQueue.png","_id":"clhrbp2dm009do5lg6y5aepih","image":"/img/header_img/concurrent/SynchronousQueue.png","format":"standard","project":"concurrent","subtitle":"SynchronousQueue是一个没有数据缓冲的BlockingQueue","updated":"2022-09-19T14:49:55.631Z","num_read":452,"num_like":854,"num_collection":32,"num_comments":156,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-03-SynchronousQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/BQ-03-SynchronousQueue/image-20220919224939343.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"LinkedBlockingQueue介绍","slug":"resource-java-concurrent-BQ-02-LinkedBlockingQueue","date":"2021-12-13T16:00:00.000Z","img":"/img/header_img/concurrent/LinkedBlockingQueue.png","_id":"clhrbp2dl0094o5lg0c6r5e80","image":"/img/header_img/concurrent/LinkedBlockingQueue.png","format":"standard","project":"concurrent","subtitle":"LinkedBlockingQueue是一个基于链表实现的阻塞队列","updated":"2022-01-12T05:39:34.000Z","num_read":933,"num_like":558,"num_collection":140,"num_comments":77,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-02-LinkedBlockingQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":null,"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"ArrayBlockingQueue介绍","slug":"resource-java-concurrent-BQ-01-ArrayBlockingQueue","date":"2021-12-12T16:00:00.000Z","img":"/img/header_img/concurrent/ArrayBlockingQueue.png","_id":"clhrbp2dp00a2o5lgajxc3eog","image":"/img/header_img/concurrent/ArrayBlockingQueue.png","format":"standard","project":"concurrent","subtitle":"ArrayBlockingQueue是最典型的有界阻塞队列，其内部是用数组存储元素的，初始化时需要指定容量大小，利用ReentrantLock实现线程安全。","updated":"2022-09-19T14:50:28.093Z","num_read":826,"num_like":1001,"num_collection":855,"num_comments":158,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BQ-01-ArrayBlockingQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/BQ-01-ArrayBlockingQueue/image-20211214144217068.png","../../../../img/BQ-01-ArrayBlockingQueue/31232.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"BlockingQueue概览","slug":"resource-java-concurrent-BlockingQueue","date":"2021-12-11T16:00:00.000Z","img":"/img/header_img/concurrent/BlockingQueue.png","_id":"clhrbp2dn009ko5lghui42qmj","image":"/img/header_img/concurrent/BlockingQueue.png","format":"max","project":"concurrent","type":"banner","subtitle":"BlockingQueue是一个在队列基础上又支持了两个附加操作的队列","updated":"2022-09-19T14:51:00.959Z","num_read":447,"num_like":883,"num_collection":257,"num_comments":213,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-BlockingQueue.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/BlockingQueue/31433.png","../../../../img/BlockingQueue/31434.png","../../../../img/BlockingQueue/30911.png","../../../../img/BlockingQueue/image-20211214091850126.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"synchronized原理分析","slug":"resource-java-concurrent-synchronized","date":"2021-11-16T16:00:00.000Z","img":"/img/header_img/concurrent/synchronized.png","_id":"clhrbp2dl0097o5lgegl65gvn","image":"/img/header_img/concurrent/synchronized.png","project":"concurrent","subtitle":"用于屏蔽掉各种硬件和操作系统的内存访问差异，原理分析","updated":"2022-01-12T05:42:00.000Z","num_read":493,"num_like":984,"num_collection":599,"num_comments":155,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-synchronized.json","excerpt":null,"keywords":null,"cover":null,"covers":null,"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]},{"title":"synchronized基本使用","slug":"resource-java-concurrent-synchronizedBase","date":"2021-11-16T16:00:00.000Z","img":"/img/header_img/concurrent/synchronizedBase.png","_id":"clhrbp2dm009ho5lgfbbq2aqp","image":"/img/header_img/concurrent/synchronizedBase.png","project":"concurrent","subtitle":"用于屏蔽掉各种硬件和操作系统的内存访问差异，基本使用","updated":"2022-09-19T14:44:37.283Z","num_read":1369,"num_like":163,"num_collection":444,"num_comments":85,"author":"Sunfy","comments":true,"path":"api/articles/resource-java-concurrent-synchronizedBase.json","excerpt":null,"keywords":null,"cover":null,"covers":["../../../../img/synchronizedBase/image-20211117093634739.png","../../../../img/synchronizedBase/image-20211117093721218.png","../../../../img/synchronizedBase/image-20211117094004355.png"],"content":null,"raw":null,"categories":[{"name":"并发编程","path":"api/categories/并发编程.json","pathContent":"api/categories/并发编程"}],"tags":[]}],"name":"并发专题","description":"一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。","project":"concurrent","url":"https://sunfy9.gitee.io/project/photo/project/concurrent.png"}